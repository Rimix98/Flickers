<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Flickers Messenger ✨</title>
    
    <!-- PWA (manifest загружается только через HTTP) -->
    <meta name="theme-color" content="#6366f1">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Flickers">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="application-name" content="Flickers Messenger">
    <script>
        // Загружаем manifest только если не file:// протокол
        if (location.protocol !== 'file:') {
            const link = document.createElement('link');
            link.rel = 'manifest';
            link.href = 'manifest.json';
            document.head.appendChild(link);
        }
    </script>
    <meta name="msapplication-TileColor" content="#6366f1">
    <meta name="msapplication-TileImage" content="icon-256.png">
    
    <!-- Favicon -->
    <link rel="icon" type="image/png" sizes="16x16" href="icon-16.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icon-32.png">
    <link rel="icon" type="image/png" sizes="48x48" href="icon-48.png">
    <link rel="apple-touch-icon" sizes="128x128" href="icon-128.png">
    <link rel="apple-touch-icon" sizes="256x256" href="icon-256.png">
    <link rel="icon" type="image/svg+xml" href="icon.svg">
    
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap');
        
        :root {
            --transition-speed: 0.3s;
        }

        body { font-family: 'Inter', sans-serif; transition: background 0.5s ease, color 0.5s ease; }
        
        /* Цветовые схемы */
        body.theme-light { --bg-app: #f1f5f9; --bg-card: #ffffff; --text: #1e293b; --border: #e2e8f0; --accent: #4f46e5; }
        body.theme-dark { --bg-app: #0f172a; --bg-card: #1e293b; --text: #f1f5f9; --border: #334155; --accent: #6366f1; }
        body.theme-cosmic { --bg-app: #020617; --bg-card: rgba(30, 41, 59, 0.7); --text: #e2e8f0; --border: #334155; --accent: #818cf8; }

        body { background-color: var(--bg-app); color: var(--text); }
        .glass-panel { background-color: var(--bg-card); border: 1px solid var(--border); backdrop-filter: blur(16px); }
        
        /* Анимация появления сообщений */
        .message-bubble { 
            max-width: 80%; 
            border-radius: 1.25rem; 
            animation: msg-slide-up 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
            position: relative;
            transform-origin: bottom;
            transition: transform 0.2s ease;
        }
        
        /* Свайп для ответа */
        .message-bubble.swiping {
            transition: none;
        }
        .message-bubble .swipe-reply-hint {
            position: absolute;
            left: -40px;
            top: 50%;
            transform: translateY(-50%);
            opacity: 0;
            transition: opacity 0.2s;
            color: var(--accent);
        }
        .message-bubble.swiping .swipe-reply-hint {
            opacity: 1;
        }

        /* Цитата (ответ на сообщение) */
        .reply-quote {
            background: rgba(99, 102, 241, 0.1);
            border-left: 3px solid var(--accent);
            padding: 6px 10px;
            margin-bottom: 8px;
            border-radius: 0 8px 8px 0;
            cursor: pointer;
            transition: background 0.2s;
        }
        .reply-quote:hover {
            background: rgba(99, 102, 241, 0.2);
        }
        .reply-quote-author {
            font-size: 11px;
            font-weight: bold;
            color: var(--accent);
        }
        .reply-quote-text {
            font-size: 12px;
            opacity: 0.8;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 200px;
        }
        .sent .reply-quote {
            background: rgba(255,255,255,0.15);
            border-left-color: rgba(255,255,255,0.5);
        }
        .sent .reply-quote-author {
            color: rgba(255,255,255,0.9);
        }
        
        /* Закреплённое сообщение */
        .pinned-message-bar {
            background: linear-gradient(90deg, var(--accent), #8b5cf6);
            color: white;
            padding: 10px 16px;
            display: flex;
            align-items: center;
            gap: 12px;
            cursor: pointer;
            transition: opacity 0.2s;
        }
        .pinned-message-bar:hover {
            opacity: 0.9;
        }
        .pinned-message-bar i {
            font-size: 14px;
        }
        .pinned-message-content {
            flex: 1;
            overflow: hidden;
        }
        .pinned-message-label {
            font-size: 10px;
            opacity: 0.8;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .pinned-message-text {
            font-size: 13px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        /* Панель ответа */
        .reply-panel {
            background: var(--bg-card);
            border-top: 1px solid var(--border);
            padding: 10px 16px;
            display: flex;
            align-items: center;
            gap: 12px;
            animation: slide-down 0.2s ease;
        }
        @keyframes slide-down {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .reply-panel-content {
            flex: 1;
            border-left: 3px solid var(--accent);
            padding-left: 10px;
        }
        .reply-panel-author {
            font-size: 12px;
            font-weight: bold;
            color: var(--accent);
        }
        .reply-panel-text {
            font-size: 12px;
            opacity: 0.7;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        @keyframes msg-slide-up {
            from { opacity: 0; transform: translateY(20px) scale(0.9); }
            to { opacity: 1; transform: translateY(0) scale(1); }
        }

        .sent { background: var(--accent); color: white; align-self: flex-end; border-bottom-right-radius: 4px; }
        .received { background: var(--bg-card); border: 1px solid var(--border); align-self: flex-start; border-bottom-left-radius: 4px; }

        /* Реакции на сообщения */
        .message-reactions {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin-top: 6px;
        }
        .reaction-badge {
            display: inline-flex;
            align-items: center;
            gap: 3px;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
            background: rgba(0,0,0,0.1);
        }
        .sent .reaction-badge {
            background: rgba(255,255,255,0.2);
        }
        .reaction-badge:hover {
            transform: scale(1.1);
        }
        .reaction-badge.my-reaction {
            background: rgba(99, 102, 241, 0.3);
            box-shadow: 0 0 0 2px var(--accent);
        }
        .reaction-badge .reaction-count {
            font-size: 11px;
            font-weight: bold;
        }
        .reaction-picker {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 24px;
            padding: 6px 10px;
            display: flex;
            gap: 4px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            z-index: 100;
            animation: reaction-picker-in 0.2s ease;
        }
        @keyframes reaction-picker-in {
            from { opacity: 0; transform: translateX(-50%) translateY(10px) scale(0.9); }
            to { opacity: 1; transform: translateX(-50%) translateY(0) scale(1); }
        }
        .reaction-picker button {
            font-size: 22px;
            padding: 4px;
            border-radius: 8px;
            transition: all 0.15s;
            background: transparent;
            border: none;
            cursor: pointer;
        }
        .reaction-picker button:hover {
            transform: scale(1.3);
            background: rgba(99, 102, 241, 0.2);
        }

        /* ========== Мобильный UI (Telegram-style) ========== */
        @media (max-width: 768px) {
            #main-app {
                flex-direction: column;
            }
            
            #main-app > aside {
                position: fixed;
                inset: 0;
                width: 100%;
                z-index: 30;
                transition: transform 0.3s ease;
            }
            
            #main-app > aside.mobile-hidden {
                transform: translateX(-100%);
            }
            
            #main-app > main {
                position: fixed;
                inset: 0;
                z-index: 25;
                transform: translateX(100%);
                transition: transform 0.3s ease;
            }
            
            #main-app > main.mobile-visible {
                transform: translateX(0);
            }
            
            #chat-placeholder {
                display: none !important;
            }
            
            .mobile-back-btn {
                display: flex !important;
            }
            
            /* Убираем placeholder на мобильных */
            #main-app > main:not(.mobile-visible) {
                pointer-events: none;
            }
        }
        
        @media (min-width: 769px) {
            .mobile-back-btn {
                display: none !important;
            }
            
            #main-app > aside {
                transform: none !important;
            }
            
            #main-app > main {
                transform: none !important;
                position: relative !important;
            }
        }

        /* Уведомления */
        .notification-toast {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 200;
            background: var(--bg-card);
            border: 1px solid var(--accent);
            border-left: 5px solid var(--accent);
            padding: 16px;
            border-radius: 1rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
            display: flex;
            align-items: center;
            gap: 12px;
            animation: toast-in 0.5s ease forwards;
            cursor: pointer;
            max-width: 320px;
        }

        @keyframes toast-in {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        .toast-out {
            animation: toast-out 0.5s ease forwards;
        }
        
        /* Уведомление о демонстрации экрана */
        .screen-share-notification {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(59, 130, 246, 0.9);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            backdrop-filter: blur(10px);
            z-index: 1000;
            animation: fadeInOut 3s ease-in-out;
        }
        
        @keyframes fadeInOut {
            0%, 100% { opacity: 0; transform: translateX(-50%) translateY(-10px); }
            10%, 90% { opacity: 1; transform: translateX(-50%) translateY(0); }
        }
        
        /* Скрываем кнопку демонстрации экрана на мобильных */
        @media (max-width: 768px) {
            #screen-share-btn {
                display: none;
            }
            #screen-share-indicator {
                display: none !important;
            }
        }
        
        /* ========== ОПТИМИЗАЦИИ ДЛЯ МОБИЛЬНЫХ УСТРОЙСТВ ========== */
        @media (max-width: 768px) {
            /* Отключаем тяжёлые эффекты */
            .glass-panel {
                backdrop-filter: none !important;
                -webkit-backdrop-filter: none !important;
            }
            
            /* Упрощаем анимации */
            .message-bubble {
                animation: none !important;
                opacity: 1 !important;
                transform: none !important;
            }
            
            /* Отключаем hover эффекты (не нужны на тач-устройствах) */
            .chat-item:hover,
            .emoji-item:hover,
            .reaction-badge:hover,
            .call-btn:hover,
            .plus-menu-item:hover {
                transform: none !important;
                background: inherit;
            }
            
            /* Упрощаем тени */
            .notification-toast,
            .plus-menu,
            .emoji-panel,
            .call-minimized,
            .local-video {
                box-shadow: 0 2px 8px rgba(0,0,0,0.15) !important;
            }
            
            /* Ускоряем переходы */
            #main-app > aside,
            #main-app > main {
                transition: transform 0.2s ease !important;
            }
            
            /* Отключаем пульсацию аватара в звонке */
            .call-avatar {
                animation: none !important;
            }
            
            /* Упрощаем video controls */
            .video-controls {
                backdrop-filter: none !important;
                background: rgba(0,0,0,0.7) !important;
            }
            
            /* Отключаем анимацию реакций */
            .reaction-picker {
                animation: none !important;
            }
            
            /* Упрощаем toast */
            .notification-toast {
                animation: none !important;
                opacity: 1 !important;
                transform: none !important;
            }
            
            /* Отключаем blur на HTTP warning */
            .http-warning,
            .screen-share-notification {
                backdrop-filter: none !important;
            }
            
            /* Оптимизация скролла */
            #messages-container,
            .emoji-content,
            #chats-list {
                -webkit-overflow-scrolling: touch;
                scroll-behavior: auto !important;
            }
            
            /* Отключаем сложные переходы */
            * {
                scroll-behavior: auto !important;
            }
            
            /* Упрощаем прогресс-бар */
            .progress-fill {
                box-shadow: none !important;
                transition: width 0.1s linear !important;
            }
            
            /* Отключаем анимацию записи голоса */
            .voice-waveform span {
                animation: none !important;
                height: 15px !important;
            }
            
            /* Упрощаем minimize call button */
            .minimize-call-btn {
                backdrop-filter: none !important;
                background: rgba(255,255,255,0.3) !important;
            }
        }
        
        /* Дополнительные оптимизации для слабых устройств */
        @media (max-width: 768px) and (prefers-reduced-motion: reduce) {
            * {
                animation: none !important;
                transition: none !important;
            }
        }
        
        /* GPU ускорение для критичных элементов */
        #main-app > aside,
        #main-app > main,
        #messages-container,
        .message-bubble {
            will-change: transform;
            transform: translateZ(0);
            -webkit-transform: translateZ(0);
        }
        
        /* Предупреждение о HTTP */
        .http-warning {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(239, 68, 68, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 12px;
            z-index: 10000;
            backdrop-filter: blur(10px);
        }

        @keyframes toast-out {
            from { transform: translateX(0); opacity: 1; }
            to { transform: translateX(100%); opacity: 0; }
        }

        /* Эмодзи-панель */
        .emoji-panel {
            display: none;
            position: absolute;
            bottom: 90px;
            right: 20px;
            width: 350px;
            max-height: 400px;
            padding: 0;
            z-index: 100;
            animation: panel-pop 0.2s ease-out;
            border-radius: 1.5rem;
            box-shadow: 0 20px 25px -5px rgb(0 0 0 / 0.1);
            overflow: hidden;
            flex-direction: column;
        }
        .emoji-panel.active { display: flex; }
        
        .emoji-tabs {
            display: flex;
            border-bottom: 1px solid var(--border);
            padding: 8px;
            gap: 4px;
            overflow-x: auto;
            flex-shrink: 0;
        }
        .emoji-tab {
            padding: 8px 12px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 1.2rem;
            transition: all 0.2s;
            flex-shrink: 0;
        }
        .emoji-tab:hover { background: rgba(79, 70, 229, 0.1); }
        .emoji-tab.active { background: var(--accent); filter: grayscale(0); }
        
        .emoji-search {
            padding: 10px 15px;
            border-bottom: 1px solid var(--border);
            flex-shrink: 0;
        }
        .emoji-search input {
            width: 100%;
            padding: 8px 12px;
            border-radius: 10px;
            border: 1px solid var(--border);
            background: var(--bg-app);
            outline: none;
            font-size: 0.85rem;
        }
        .emoji-search input:focus { border-color: var(--accent); }
        
        .emoji-content {
            flex: 1;
            overflow-y: auto;
            padding: 10px 15px;
        }
        .emoji-category-title {
            font-size: 0.7rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            opacity: 0.5;
            margin: 10px 0 8px;
        }
        .emoji-grid {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 4px;
        }
        
        @keyframes panel-pop {
            from { opacity: 0; transform: scale(0.9) translateY(10px); }
            to { opacity: 1; transform: scale(1) translateY(0); }
        }
        
        /* Плюс-меню для дополнительных действий */
        .plus-menu-container {
            position: relative;
        }
        .plus-menu-btn {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background: var(--bg-app);
            border: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            color: var(--text);
            font-size: 20px;
        }
        .plus-menu-btn:hover {
            background: var(--accent);
            color: white;
            border-color: var(--accent);
        }
        .plus-menu-btn.active {
            background: var(--accent);
            color: white;
            border-color: var(--accent);
            transform: rotate(45deg);
        }
        .plus-menu {
            position: absolute;
            bottom: 60px;
            left: 0;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 8px;
            min-width: 200px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            opacity: 0;
            visibility: hidden;
            transform: translateY(10px) scale(0.95);
            transition: all 0.2s ease;
            z-index: 100;
        }
        .plus-menu.active {
            opacity: 1;
            visibility: visible;
            transform: translateY(0) scale(1);
        }
        .plus-menu-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 14px;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.15s;
            font-size: 14px;
            font-weight: 500;
        }
        .plus-menu-item:hover {
            background: rgba(99, 102, 241, 0.1);
        }
        .plus-menu-item i {
            width: 20px;
            text-align: center;
            font-size: 16px;
        }
        .plus-menu-item.file-item i { color: #6366f1; }
        .plus-menu-item.poll-item i { color: #8b5cf6; }
        .plus-menu-item.game-item i { color: #22c55e; }
        .plus-menu-item.ai-item i { color: #f97316; }

        .emoji-item { cursor: pointer; transition: transform 0.2s; font-size: 1.4rem; display: flex; justify-content: center; align-items: center; padding: 6px; border-radius: 8px; }
        .emoji-item:hover { transform: scale(1.2); background: rgba(79, 70, 229, 0.1); }

        /* Настройки */
        #settings-panel { 
            transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1); 
            transform: translateX(100%); 
        }
        #settings-panel.active { transform: translateX(0); }
        
        /* Спиннеры и прогресс */
        .progress-bar {
            height: 6px;
            background: rgba(0,0,0,0.1);
            border-radius: 10px;
            overflow: hidden;
            margin-top: 10px;
        }
        .progress-fill {
            height: 100%;
            background: var(--accent);
            width: 0%;
            transition: width 0.3s ease;
            box-shadow: 0 0 10px var(--accent);
        }

        /* Анимация списка чатов */
        .chat-item {
            transition: all 0.2s ease;
        }
        .chat-item:hover {
            transform: translateX(5px);
            background-color: rgba(79, 70, 229, 0.05);
        }

        /* Кастомный скроллбар */
        ::-webkit-scrollbar { width: 5px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 10px; }
        body.theme-dark ::-webkit-scrollbar-thumb { background: #475569; }

        /* Экран звонка */
        .call-screen {
            position: fixed;
            inset: 0;
            z-index: 200;
            background: linear-gradient(135deg, #1e1b4b 0%, #312e81 50%, #4338ca 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            animation: call-fade-in 0.3s ease;
        }
        @keyframes call-fade-in {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        .call-avatar {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            background: rgba(255,255,255,0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3rem;
            color: white;
            font-weight: bold;
            animation: call-pulse 2s infinite;
            border: 4px solid rgba(255,255,255,0.3);
        }
        @keyframes call-pulse {
            0%, 100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(255,255,255,0.4); }
            50% { transform: scale(1.05); box-shadow: 0 0 0 20px rgba(255,255,255,0); }
        }
        .call-btn {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            cursor: pointer;
            transition: all 0.2s;
            border: none;
        }
        .call-btn:hover { transform: scale(1.1); }
        .call-btn:active { transform: scale(0.95); }
        .call-btn-accept { background: #22c55e; color: white; }
        .call-btn-decline { background: #ef4444; color: white; }
        .call-btn-mute { background: rgba(255,255,255,0.2); color: white; }
        .call-btn-mute.active { background: #ef4444; }
        .call-btn-mute.screen-sharing { background: #3b82f6; }
        
        /* Видео контейнер */
        .video-container {
            position: fixed;
            inset: 0;
            z-index: 200;
            background: #000;
        }
        .remote-video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        .local-video {
            position: absolute;
            bottom: 120px;
            right: 20px;
            width: 150px;
            height: 200px;
            border-radius: 1rem;
            object-fit: cover;
            border: 3px solid rgba(255,255,255,0.3);
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }
        .video-controls {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            padding: 15px 30px;
            background: rgba(0,0,0,0.5);
            border-radius: 50px;
            backdrop-filter: blur(10px);
        }
        
        /* Групповой видео звонок */
        #group-call-participants {
            background: linear-gradient(135deg, #1e293b 0%, #312e81 100%);
        }
        #group-videos-grid video {
            background: #1e293b;
        }
        
        /* Свёрнутый звонок (мини-плеер) */
        .call-minimized {
            position: fixed;
            bottom: 100px;
            right: 20px;
            width: 280px;
            background: linear-gradient(135deg, #1e1b4b 0%, #4338ca 100%);
            border-radius: 20px;
            padding: 12px 16px;
            z-index: 250;
            box-shadow: 0 10px 40px rgba(0,0,0,0.4);
            cursor: pointer;
            animation: mini-call-in 0.3s ease;
            border: 1px solid rgba(255,255,255,0.1);
        }
        @keyframes mini-call-in {
            from { opacity: 0; transform: translateY(20px) scale(0.9); }
            to { opacity: 1; transform: translateY(0) scale(1); }
        }
        .call-minimized:hover {
            transform: scale(1.02);
            box-shadow: 0 15px 50px rgba(0,0,0,0.5);
        }
        .call-minimized-header {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        .call-minimized-avatar {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background: rgba(255,255,255,0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            font-weight: bold;
            color: white;
            overflow: hidden;
            flex-shrink: 0;
        }
        .call-minimized-avatar img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        .call-minimized-info {
            flex: 1;
            min-width: 0;
        }
        .call-minimized-name {
            color: white;
            font-weight: 600;
            font-size: 14px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .call-minimized-status {
            color: rgba(255,255,255,0.7);
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .call-minimized-status .pulse-dot {
            width: 6px;
            height: 6px;
            background: #22c55e;
            border-radius: 50%;
            animation: pulse 1.5s infinite;
        }
        .call-minimized-actions {
            display: flex;
            gap: 8px;
            margin-top: 10px;
        }
        .call-mini-btn {
            flex: 1;
            padding: 8px;
            border-radius: 12px;
            border: none;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }
        .call-mini-btn-expand {
            background: rgba(255,255,255,0.15);
            color: white;
        }
        .call-mini-btn-expand:hover {
            background: rgba(255,255,255,0.25);
        }
        .call-mini-btn-end {
            background: #ef4444;
            color: white;
        }
        .call-mini-btn-end:hover {
            background: #dc2626;
        }
        .minimize-call-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background: rgba(255,255,255,0.15);
            border: none;
            color: white;
            font-size: 18px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(10px);
            z-index: 10;
        }
        .minimize-call-btn:hover {
            background: rgba(255,255,255,0.25);
            transform: scale(1.1);
        }
        #group-videos-grid > div {
            min-height: 150px;
        }
        @media (max-width: 640px) {
            #group-videos-grid {
                grid-template-columns: repeat(2, 1fr) !important;
            }
        }

        /* Голосовые сообщения */
        .voice-btn {
            transition: all 0.2s;
        }
        .voice-btn.recording {
            background: #ef4444 !important;
            color: white !important;
            animation: recording-pulse 1s infinite;
        }
        @keyframes recording-pulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.4); }
            50% { box-shadow: 0 0 0 15px rgba(239, 68, 68, 0); }
        }
        .voice-recording-ui {
            display: flex;
            align-items: center;
            gap: 12px;
            background: var(--bg-card);
            border: 1px solid var(--border);
            padding: 12px 20px;
            border-radius: 2rem;
            animation: slide-up 0.2s ease;
        }
        @keyframes slide-up {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .recording-indicator {
            width: 12px;
            height: 12px;
            background: #ef4444;
            border-radius: 50%;
            animation: blink 1s infinite;
        }
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }
        
        /* Видео-кружки (как в Telegram) */
        .video-circle-btn {
            transition: all 0.2s;
        }
        .video-circle-btn.recording {
            background: #ef4444 !important;
            color: white !important;
            animation: recording-pulse 1s infinite;
        }
        .video-circle-overlay {
            position: fixed;
            inset: 0;
            z-index: 9999;
            background: rgba(0,0,0,0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            animation: fade-in 0.2s ease;
        }
        @keyframes fade-in {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        .video-circle-preview {
            width: 280px;
            height: 280px;
            border-radius: 50%;
            overflow: hidden;
            border: 4px solid #ef4444;
            box-shadow: 0 0 40px rgba(239, 68, 68, 0.5);
            position: relative;
        }
        .video-circle-preview video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }
        .video-circle-timer {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .video-circle-timer::before {
            content: '';
            width: 8px;
            height: 8px;
            background: #ef4444;
            border-radius: 50%;
            animation: blink 1s infinite;
        }
        .video-circle-controls {
            margin-top: 30px;
            display: flex;
            gap: 20px;
        }
        .video-circle-controls button {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: none;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .video-circle-controls button:hover {
            transform: scale(1.1);
        }
        .video-circle-cancel {
            background: #64748b;
            color: white;
        }
        .video-circle-send {
            background: #22c55e;
            color: white;
        }
        .video-circle-message {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .video-circle-message video {
            width: 200px;
            height: 200px;
            border-radius: 50%;
            object-fit: cover;
            cursor: pointer;
            border: 3px solid var(--accent);
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        .video-circle-message .video-circle-duration {
            font-size: 10px;
            opacity: 0.7;
            margin-top: 4px;
        }
        
        /* Предпросмотр ссылок */
        .link-preview {
            margin-top: 8px;
            border-left: 3px solid var(--accent);
            padding: 8px 12px;
            background: rgba(0,0,0,0.05);
            border-radius: 0 8px 8px 0;
            cursor: pointer;
            transition: all 0.2s;
        }
        .dark .link-preview {
            background: rgba(255,255,255,0.05);
        }
        .link-preview:hover {
            background: rgba(0,0,0,0.1);
        }
        .dark .link-preview:hover {
            background: rgba(255,255,255,0.1);
        }
        .link-preview-image {
            width: 100%;
            max-height: 150px;
            object-fit: cover;
            border-radius: 6px;
            margin-bottom: 8px;
        }
        .link-preview-site {
            font-size: 10px;
            color: var(--accent);
            text-transform: uppercase;
            font-weight: bold;
            margin-bottom: 4px;
        }
        .link-preview-title {
            font-size: 13px;
            font-weight: bold;
            line-height: 1.3;
            margin-bottom: 4px;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }
        .link-preview-description {
            font-size: 11px;
            opacity: 0.7;
            line-height: 1.4;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }
        
        /* Медиа-просмотрщик */
        #media-viewer-thumbnails::-webkit-scrollbar {
            height: 6px;
        }
        #media-viewer-thumbnails::-webkit-scrollbar-thumb {
            background: rgba(255,255,255,0.3);
            border-radius: 3px;
        }
        .media-thumbnail {
            width: 60px;
            height: 60px;
            border-radius: 8px;
            object-fit: cover;
            cursor: pointer;
            opacity: 0.5;
            transition: all 0.2s;
            border: 2px solid transparent;
            flex-shrink: 0;
        }
        .media-thumbnail:hover {
            opacity: 0.8;
        }
        .media-thumbnail.active {
            opacity: 1;
            border-color: var(--accent);
        }
        .media-thumbnail-video {
            position: relative;
        }
        .media-thumbnail-video::after {
            content: '▶';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 16px;
            text-shadow: 0 0 4px rgba(0,0,0,0.5);
        }
        #media-viewer-video::-webkit-media-controls-panel {
            background: linear-gradient(transparent, rgba(0,0,0,0.7));
        }
        
        .voice-waveform {
            display: flex;
            align-items: center;
            gap: 2px;
            height: 30px;
        }
        .voice-waveform span {
            width: 3px;
            background: var(--accent);
            border-radius: 3px;
            animation: wave 0.5s ease infinite;
        }
        .voice-waveform span:nth-child(1) { animation-delay: 0s; }
        .voice-waveform span:nth-child(2) { animation-delay: 0.1s; }
        .voice-waveform span:nth-child(3) { animation-delay: 0.2s; }
        .voice-waveform span:nth-child(4) { animation-delay: 0.3s; }
        .voice-waveform span:nth-child(5) { animation-delay: 0.4s; }
        @keyframes wave {
            0%, 100% { height: 8px; }
            50% { height: 25px; }
        }
        .voice-message {
            display: flex;
            align-items: center;
            gap: 10px;
            min-width: 200px;
        }
        .voice-play-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: var(--accent);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            flex-shrink: 0;
            transition: transform 0.2s;
        }
        .voice-play-btn:hover { transform: scale(1.1); }
        .voice-progress {
            flex: 1;
            height: 4px;
            background: rgba(0,0,0,0.1);
            border-radius: 2px;
            cursor: pointer;
            position: relative;
        }
        .voice-progress-fill {
            height: 100%;
            background: var(--accent);
            border-radius: 2px;
            width: 0%;
            transition: width 0.1s linear;
        }

        /* Приватность и безопасность */
        .encrypted-badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            font-size: 9px;
            color: #22c55e;
            background: rgba(34, 197, 94, 0.1);
            padding: 2px 8px;
            border-radius: 10px;
            margin-left: 8px;
        }
        
        /* Таймер автоудаления */
        .destruct-timer {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            font-size: 10px;
            color: #ef4444;
            margin-left: 6px;
            font-weight: 500;
            font-variant-numeric: tabular-nums;
        }
        .destruct-timer i {
            font-size: 9px;
            animation: pulse-fire 1s infinite;
        }
        @keyframes pulse-fire {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        /* Анимация удаления как в Telegram */
        @keyframes telegram-destruct {
            0% { 
                opacity: 1; 
                transform: scale(1) translateY(0);
                filter: blur(0);
            }
            30% {
                transform: scale(1.02) translateY(-5px);
            }
            100% { 
                opacity: 0; 
                transform: scale(0.3) translateY(-50px);
                filter: blur(10px);
            }
        }
        .message-destructing {
            animation: telegram-destruct 0.6s ease-out forwards;
            pointer-events: none;
        }
        
        /* Частицы при удалении */
        .destruct-particles {
            position: absolute;
            inset: 0;
            pointer-events: none;
            overflow: visible;
        }
        .destruct-particle {
            position: absolute;
            width: 6px;
            height: 6px;
            background: var(--accent);
            border-radius: 50%;
            animation: particle-fly 0.6s ease-out forwards;
        }
        @keyframes particle-fly {
            0% { 
                opacity: 1;
                transform: translate(0, 0) scale(1);
            }
            100% { 
                opacity: 0;
                transform: translate(var(--tx), var(--ty)) scale(0);
            }
        }
        
        .anonymous-avatar {
            background: linear-gradient(135deg, #374151, #1f2937) !important;
        }
        .privacy-toggle {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 16px;
            background: var(--bg-app);
            border-radius: 12px;
            margin-bottom: 8px;
        }
        .privacy-toggle label {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 14px;
            cursor: pointer;
        }
        .toggle-switch {
            position: relative;
            width: 44px;
            height: 24px;
            background: #cbd5e1;
            border-radius: 12px;
            cursor: pointer;
            transition: background 0.3s;
        }
        .toggle-switch.active {
            background: var(--accent);
        }
        .toggle-switch::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 20px;
            height: 20px;
            background: white;
            border-radius: 50%;
            transition: transform 0.3s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        .toggle-switch.active::after {
            transform: translateX(20px);
        }
        
        /* Стили для рамок аватара */
        .frame-btn.active, .chat-style-btn.active {
            border-color: #6366f1 !important;
            background: rgba(99, 102, 241, 0.1) !important;
        }
        .avatar-frame-rainbow {
            box-shadow: 0 0 0 3px transparent, 0 0 0 5px #f59e0b, 0 0 0 7px #ef4444, 0 0 0 9px #ec4899 !important;
            animation: rainbow-rotate 3s linear infinite !important;
            overflow: visible !important;
        }
        .avatar-frame-gold {
            box-shadow: 0 0 0 3px #fbbf24, 0 0 15px #fbbf24 !important;
            overflow: visible !important;
        }
        .avatar-frame-neon {
            box-shadow: 0 0 0 3px #22d3ee, 0 0 15px #22d3ee, 0 0 30px #22d3ee !important;
            animation: neon-pulse 2s ease-in-out infinite !important;
            overflow: visible !important;
        }
        .avatar-frame-fire {
            box-shadow: 0 0 0 3px #f97316, 0 0 15px #ef4444, 0 0 25px #f97316 !important;
            animation: fire-flicker 0.5s ease-in-out infinite alternate !important;
            overflow: visible !important;
        }
        .avatar-frame-purple {
            box-shadow: 0 0 0 3px #a855f7, 0 0 15px #a855f7 !important;
            overflow: visible !important;
        }
        .avatar-frame-emerald {
            box-shadow: 0 0 0 3px #10b981, 0 0 15px #10b981 !important;
            overflow: visible !important;
        }
        .avatar-frame-diamond {
            box-shadow: 0 0 0 2px #fff, 0 0 0 4px #60a5fa, 0 0 20px #60a5fa !important;
            animation: diamond-shine 2s ease-in-out infinite !important;
            overflow: visible !important;
        }
        @keyframes rainbow-rotate {
            0% { filter: hue-rotate(0deg); }
            100% { filter: hue-rotate(360deg); }
        }
        @keyframes neon-pulse {
            0%, 100% { box-shadow: 0 0 0 3px #22d3ee, 0 0 15px #22d3ee, 0 0 30px #22d3ee !important; }
            50% { box-shadow: 0 0 0 3px #22d3ee, 0 0 25px #22d3ee, 0 0 50px #22d3ee !important; }
        }
        @keyframes fire-flicker {
            0% { box-shadow: 0 0 0 3px #f97316, 0 0 15px #ef4444, 0 0 25px #f97316 !important; }
            100% { box-shadow: 0 0 0 3px #ef4444, 0 0 20px #f97316, 0 0 35px #ef4444 !important; }
        }
        @keyframes diamond-shine {
            0%, 100% { box-shadow: 0 0 0 2px #fff, 0 0 0 4px #60a5fa, 0 0 20px #60a5fa !important; }
            50% { box-shadow: 0 0 0 2px #fff, 0 0 0 4px #93c5fd, 0 0 30px #60a5fa, 0 0 50px #93c5fd !important; }
        }
        
        /* Стили сообщений */
        .msg-style-gradient .message-bubble.sent {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%) !important;
            color: white !important;
        }
        .msg-style-neon .message-bubble.sent {
            background: #0f172a !important;
            color: #22d3ee !important;
            box-shadow: 0 0 10px #22d3ee, inset 0 0 10px rgba(34, 211, 238, 0.1) !important;
            border: 1px solid #22d3ee !important;
        }
        .msg-style-glass .message-bubble.sent {
            background: rgba(99, 102, 241, 0.3) !important;
            backdrop-filter: blur(10px) !important;
            border: 1px solid rgba(255,255,255,0.3) !important;
        }
        
        /* Стиль сообщения-подарка */
        .gift-message {
            background: linear-gradient(135deg, #ef4444, #ec4899, #f59e0b) !important;
            padding: 0 !important;
            overflow: visible;
            animation: gift-shine 2s ease-in-out infinite;
            min-width: 200px;
            max-width: 280px;
            border-radius: 20px !important;
        }
        .gift-message-content {
            padding: 20px;
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .gift-icon {
            width: 80px;
            height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 12px;
            animation: gift-bounce 1s ease-in-out infinite;
        }
        .gift-icon svg {
            width: 100%;
            height: 100%;
            display: block;
            filter: drop-shadow(0 4px 12px rgba(0,0,0,0.4));
        }
        .gift-amount {
            font-size: 24px;
            font-weight: 900;
            margin: 8px 0;
        }
        .gift-text {
            font-size: 12px;
            opacity: 0.9;
        }
        @keyframes gift-shine {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.1); }
        }
        @keyframes gift-bounce {
            0%, 100% { transform: scale(1) rotate(0deg); }
            25% { transform: scale(1.1) rotate(-5deg); }
            75% { transform: scale(1.1) rotate(5deg); }
        }
        
        /* Анимация получения подарка */
        .gift-received-overlay {
            position: fixed;
            inset: 0;
            z-index: 9999;
            background: rgba(0,0,0,0.8);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            animation: gift-overlay-in 0.3s ease-out;
        }
        @keyframes gift-overlay-in {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        .gift-received-icon {
            font-size: 120px;
            animation: gift-received-bounce 0.8s ease-out;
        }
        .gift-received-icon svg {
            width: 150px;
            height: 150px;
            filter: drop-shadow(0 0 30px rgba(255,255,255,0.5));
        }
        @keyframes gift-received-bounce {
            0% { transform: scale(0) rotate(-180deg); opacity: 0; }
            50% { transform: scale(1.3) rotate(10deg); }
            70% { transform: scale(0.9) rotate(-5deg); }
            100% { transform: scale(1) rotate(0deg); opacity: 1; }
        }
        .gift-received-text {
            color: white;
            font-size: 24px;
            font-weight: 900;
            margin-top: 20px;
            animation: gift-text-in 0.5s ease-out 0.3s both;
        }
        @keyframes gift-text-in {
            from { transform: translateY(20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        .gift-received-from {
            color: rgba(255,255,255,0.7);
            font-size: 16px;
            margin-top: 8px;
            animation: gift-text-in 0.5s ease-out 0.5s both;
        }
        .gift-received-message {
            color: white;
            font-size: 18px;
            font-style: italic;
            margin-top: 16px;
            padding: 12px 24px;
            background: rgba(255,255,255,0.1);
            border-radius: 20px;
            animation: gift-text-in 0.5s ease-out 0.7s both;
        }
        .gift-sparkles {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: hidden;
        }
        .gift-sparkle {
            position: absolute;
            width: 10px;
            height: 10px;
            background: white;
            border-radius: 50%;
            animation: sparkle-fly 1.5s ease-out forwards;
        }
        @keyframes sparkle-fly {
            0% { transform: translate(0, 0) scale(1); opacity: 1; }
            100% { transform: translate(var(--tx), var(--ty)) scale(0); opacity: 0; }
        }
        .gift-confetti {
            position: absolute;
            width: 8px;
            height: 8px;
            animation: confetti-fall 2s ease-out forwards;
        }
        @keyframes confetti-fall {
            0% { transform: translateY(-100px) rotate(0deg); opacity: 1; }
            100% { transform: translateY(100vh) rotate(720deg); opacity: 0; }
        }
        
        /* Выбор подарка */
        .gift-option.selected {
            box-shadow: 0 0 0 2px #ec4899;
            background: rgba(236, 72, 153, 0.2) !important;
            transform: scale(1.05);
        }
        .gift-option {
            transition: all 0.2s ease;
        }
        
        /* Витрина подарков в профиле */
        .gifts-showcase {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            padding: 12px;
            background: linear-gradient(135deg, rgba(236,72,153,0.1), rgba(239,68,68,0.1));
            border-radius: 16px;
            min-height: 60px;
        }
        .showcase-gift {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 8px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            min-width: 60px;
        }
        .dark .showcase-gift {
            background: #334155;
        }
        .showcase-gift-icon {
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .showcase-gift-icon svg {
            width: 100%;
            height: 100%;
        }
        .showcase-gift-count {
            font-size: 11px;
            font-weight: bold;
            color: #ec4899;
            margin-top: 4px;
        }
        
        .secret-chat-indicator {
            background: linear-gradient(135deg, #059669, #10b981);
            color: white;
            padding: 2px 8px;
            border-radius: 8px;
            font-size: 10px;
            font-weight: bold;
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }
        @keyframes msg-fade-out {
            from { opacity: 1; transform: scale(1); }
            to { opacity: 0; transform: scale(0.8); }
        }
        @keyframes highlight-msg {
            0%, 100% { box-shadow: none; }
            50% { box-shadow: 0 0 0 3px var(--accent), 0 0 20px rgba(99, 102, 241, 0.4); }
        }
        /* Пересланное сообщение */
        .forwarded-label {
            font-size: 10px;
            color: var(--accent);
            margin-bottom: 4px;
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .sent .forwarded-label {
            color: rgba(255,255,255,0.7);
        }
        
        /* Крестики-нолики */
        .ttt-game {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 16px;
            min-width: 220px;
        }
        .ttt-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
        }
        .ttt-title {
            font-size: 12px;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .ttt-status {
            font-size: 11px;
            padding: 4px 8px;
            border-radius: 8px;
            background: rgba(99, 102, 241, 0.1);
            color: var(--accent);
        }
        .ttt-board {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 6px;
            margin-bottom: 12px;
        }
        .ttt-cell {
            aspect-ratio: 1;
            background: var(--bg-app);
            border: 2px solid var(--border);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.15s;
        }
        .ttt-cell:hover:not(.taken) {
            background: rgba(99, 102, 241, 0.1);
            border-color: var(--accent);
        }
        .ttt-cell.taken {
            cursor: default;
        }
        .ttt-cell.x { color: #ef4444; }
        .ttt-cell.o { color: #3b82f6; }
        .ttt-cell.win {
            background: rgba(34, 197, 94, 0.2);
            border-color: #22c55e;
        }
        .ttt-actions {
            display: flex;
            gap: 8px;
        }
        .ttt-btn {
            flex: 1;
            padding: 8px;
            border-radius: 8px;
            font-size: 11px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.15s;
            border: none;
        }
        .ttt-btn-accept {
            background: #22c55e;
            color: white;
        }
        .ttt-btn-decline {
            background: #ef4444;
            color: white;
        }
        .ttt-btn:hover {
            opacity: 0.9;
            transform: scale(1.02);
        }
        .ttt-invite {
            text-align: center;
            padding: 20px;
        }
        .ttt-invite-icon {
            font-size: 40px;
            margin-bottom: 10px;
        }
        .ttt-invite-text {
            font-size: 13px;
            margin-bottom: 12px;
        }
        
        /* Статусы/Истории */
        .stories-container {
            display: flex;
            gap: 12px;
            padding: 12px 16px;
            overflow-x: auto;
            border-bottom: 1px solid var(--border);
        }
        .stories-container::-webkit-scrollbar { height: 0; }
        .story-item {
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            cursor: pointer;
        }
        .story-avatar {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            padding: 3px;
            background: linear-gradient(135deg, #f59e0b, #ef4444, #ec4899, #8b5cf6);
        }
        .story-avatar.no-story {
            background: var(--border);
        }
        .story-avatar.viewed {
            background: #9ca3af;
        }
        .story-avatar-inner {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: var(--bg-card);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 18px;
            overflow: hidden;
            border: 3px solid var(--bg-card);
        }
        .story-avatar-inner img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        .story-add {
            position: absolute;
            bottom: 0;
            right: 0;
            width: 22px;
            height: 22px;
            background: var(--accent);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 12px;
            border: 2px solid var(--bg-card);
        }
        .story-name {
            font-size: 10px;
            max-width: 60px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            text-align: center;
        }
        .story-viewer {
            position: fixed;
            inset: 0;
            z-index: 300;
            background: #000;
            display: flex;
            flex-direction: column;
        }
        .story-viewer-header {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding: 16px;
            background: linear-gradient(to bottom, rgba(0,0,0,0.7), transparent);
            z-index: 10;
        }
        .story-progress {
            display: flex;
            gap: 4px;
            margin-bottom: 12px;
        }
        .story-progress-bar {
            flex: 1;
            height: 3px;
            background: rgba(255,255,255,0.3);
            border-radius: 2px;
            overflow: hidden;
        }
        .story-progress-fill {
            height: 100%;
            background: white;
            width: 0%;
        }
        .story-content {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .story-content img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }
        
        /* Улучшенные голосовые сообщения */
        .voice-waveform-visual {
            display: flex;
            align-items: center;
            gap: 2px;
            height: 32px;
            padding: 0 8px;
        }
        .voice-waveform-visual .bar {
            width: 3px;
            background: var(--accent);
            border-radius: 2px;
            transition: height 0.1s;
        }
        .sent .voice-waveform-visual .bar {
            background: rgba(255,255,255,0.7);
        }
        .voice-message-enhanced {
            display: flex;
            align-items: center;
            gap: 10px;
            min-width: 200px;
            padding: 8px;
            background: rgba(0,0,0,0.05);
            border-radius: 12px;
        }
        .sent .voice-message-enhanced {
            background: rgba(255,255,255,0.1);
        }
        
        /* Стикеры и GIF */
        .sticker-panel {
            display: none;
            position: absolute;
            bottom: 60px;
            left: 0;
            width: 350px;
            max-height: 400px;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 1.5rem;
            box-shadow: 0 20px 50px rgba(0,0,0,0.15);
            z-index: 100;
            animation: panel-pop 0.2s ease-out;
            overflow: hidden;
            flex-direction: column;
        }
        .sticker-panel.active { display: flex; }
        .sticker-tabs {
            display: flex;
            border-bottom: 1px solid var(--border);
        }
        .sticker-tab {
            flex: 1;
            padding: 12px;
            text-align: center;
            cursor: pointer;
            font-size: 13px;
            font-weight: bold;
            transition: all 0.2s;
            border-bottom: 2px solid transparent;
        }
        .sticker-tab.active {
            color: var(--accent);
            border-bottom-color: var(--accent);
        }
        .sticker-search {
            padding: 10px;
            border-bottom: 1px solid var(--border);
        }
        .sticker-search input {
            width: 100%;
            padding: 10px 14px;
            border-radius: 10px;
            border: 1px solid var(--border);
            background: var(--bg-app);
            outline: none;
            font-size: 13px;
        }
        .sticker-content {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
        }
        .sticker-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
        }
        .sticker-item, .gif-item {
            aspect-ratio: 1;
            border-radius: 10px;
            cursor: pointer;
            overflow: hidden;
            transition: transform 0.15s;
            background: var(--bg-app);
        }
        .sticker-item:hover, .gif-item:hover {
            transform: scale(1.1);
        }
        .sticker-item img, .gif-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        .gif-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }
        .gif-item {
            aspect-ratio: auto;
            height: 100px;
        }
        
        .lang-btn.active {
            border-color: var(--accent) !important;
            background: rgba(79, 70, 229, 0.1);
        }
        .auth-lang-btn.active {
            background: rgba(255, 255, 255, 0.25);
            color: white;
        }
        
        /* Контекстное меню сообщений */
        .msg-context-menu {
            position: fixed;
            z-index: 300;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            padding: 6px;
            min-width: 160px;
            animation: context-pop 0.15s ease-out;
        }
        @keyframes context-pop {
            from { opacity: 0; transform: scale(0.9); }
            to { opacity: 1; transform: scale(1); }
        }
        .msg-context-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 14px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 13px;
            transition: background 0.15s;
        }
        .msg-context-item:hover {
            background: rgba(79, 70, 229, 0.1);
        }
        .msg-context-item.danger {
            color: #ef4444;
        }
        .msg-context-item.danger:hover {
            background: rgba(239, 68, 68, 0.1);
        }
        .msg-context-divider {
            height: 1px;
            background: var(--border);
            margin: 4px 0;
        }
        
        /* Модальное окно редактирования */
        .edit-modal {
            position: fixed;
            inset: 0;
            z-index: 250;
            background: rgba(0,0,0,0.5);
            backdrop-filter: blur(4px);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            animation: modal-fade 0.2s ease;
        }
        @keyframes modal-fade {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        .edit-modal-content {
            background: var(--bg-card);
            border-radius: 20px;
            padding: 24px;
            width: 100%;
            max-width: 400px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            animation: modal-pop 0.2s ease;
        }
        @keyframes modal-pop {
            from { transform: scale(0.9) translateY(20px); }
            to { transform: scale(1) translateY(0); }
        }
        
        /* Индикатор редактирования */
        .edited-badge {
            font-size: 9px;
            opacity: 0.5;
            font-style: italic;
            margin-left: 6px;
        }
        
        /* AI панель */
        .ai-panel {
            position: absolute;
            bottom: 90px;
            left: 20px;
            width: 320px;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 1.5rem;
            box-shadow: 0 20px 50px rgba(0,0,0,0.15);
            z-index: 100;
            animation: panel-pop 0.2s ease-out;
            overflow: hidden;
        }
        .ai-panel.hidden { display: none; }
        .ai-btn-option {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 14px 18px;
            cursor: pointer;
            transition: background 0.15s;
            font-size: 14px;
        }
        .ai-btn-option:hover {
            background: rgba(79, 70, 229, 0.1);
        }
        .ai-btn-option i {
            width: 20px;
            text-align: center;
            color: var(--accent);
        }
        .ai-loading {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 20px;
            color: var(--accent);
        }
        .ai-loading i {
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        .ai-result {
            padding: 16px;
            max-height: 200px;
            overflow-y: auto;
            font-size: 13px;
            line-height: 1.6;
            border-top: 1px solid var(--border);
        }
        .ai-result-actions {
            display: flex;
            gap: 8px;
            padding: 12px 16px;
            border-top: 1px solid var(--border);
        }
        .ai-result-btn {
            flex: 1;
            padding: 10px;
            border-radius: 10px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.15s;
        }
        
        /* Анимация убегающего сообщения */
        .message-running-away {
            position: relative;
            animation: runAway 1.5s ease-in forwards;
        }
        
        .message-running-away::after {
            content: '';
            position: absolute;
            bottom: -8px;
            left: 50%;
            transform: translateX(-50%);
            width: 20px;
            height: 12px;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 12'%3E%3Cpath d='M3 0 L3 8 L0 12 L3 10 L3 8' fill='%23666' class='leg-left'/%3E%3Cpath d='M17 0 L17 8 L20 12 L17 10 L17 8' fill='%23666' class='leg-right'/%3E%3C/svg%3E");
            animation: runLegs 0.15s steps(2) infinite;
        }
        
        @keyframes runAway {
            0% {
                transform: translateX(0) rotate(0deg);
                opacity: 1;
            }
            10% {
                transform: translateX(10px) rotate(5deg);
            }
            20% {
                transform: translateX(0px) rotate(-3deg);
            }
            30% {
                transform: translateX(-30px) rotate(-5deg);
            }
            50% {
                transform: translateX(-100px) rotate(-10deg);
                opacity: 1;
            }
            100% {
                transform: translateX(-500px) rotate(-15deg);
                opacity: 0;
            }
        }
        
        @keyframes runLegs {
            0% { transform: translateX(-50%) scaleX(1); }
            50% { transform: translateX(-50%) scaleX(-1); }
        }
        
        .message-legs {
            position: absolute;
            bottom: -16px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 8px;
            font-size: 14px;
        }
        
        .leg {
            animation: legMove 0.1s steps(2) infinite;
            display: inline-block;
        }
        
        .leg:nth-child(2) {
            animation-delay: 0.05s;
        }
        
        @keyframes legMove {
            0%, 100% { transform: rotate(-20deg); }
            50% { transform: rotate(20deg); }
        }
        
        /* Новогоднее оформление - Гирлянда */
        .new-year-logo {
            position: relative;
            display: inline-block;
            padding: 8px 0;
        }
        
        .garland {
            position: absolute;
            top: -5px;
            left: -10px;
            right: -10px;
            height: 30px;
            pointer-events: none;
            overflow: visible;
        }
        
        .garland-wire {
            position: absolute;
            top: 12px;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, 
                transparent 0%, 
                #166534 10%, 
                #166534 90%, 
                transparent 100%
            );
            border-radius: 2px;
        }
        
        .garland-light {
            position: absolute;
            top: 8px;
            width: 8px;
            height: 12px;
            border-radius: 50% 50% 50% 50% / 30% 30% 70% 70%;
            animation: glow 1s ease-in-out infinite alternate;
            box-shadow: 0 0 8px currentColor, 0 0 12px currentColor;
        }
        
        .garland-light:nth-child(2) { left: 5%; background: #ef4444; color: #ef4444; animation-delay: 0s; }
        .garland-light:nth-child(3) { left: 18%; background: #eab308; color: #eab308; animation-delay: 0.2s; }
        .garland-light:nth-child(4) { left: 31%; background: #22c55e; color: #22c55e; animation-delay: 0.4s; }
        .garland-light:nth-child(5) { left: 44%; background: #3b82f6; color: #3b82f6; animation-delay: 0.6s; }
        .garland-light:nth-child(6) { left: 57%; background: #ef4444; color: #ef4444; animation-delay: 0.8s; }
        .garland-light:nth-child(7) { left: 70%; background: #eab308; color: #eab308; animation-delay: 1s; }
        .garland-light:nth-child(8) { left: 83%; background: #22c55e; color: #22c55e; animation-delay: 1.2s; }
        
        @keyframes glow {
            0% { opacity: 0.4; transform: scale(0.9); }
            100% { opacity: 1; transform: scale(1.1); }
        }
        
        /* Локальные снежинки вокруг логотипа */
        .logo-snowflakes {
            position: absolute;
            top: -20px;
            left: -20px;
            right: -20px;
            bottom: -30px;
            pointer-events: none;
            overflow: hidden;
            border-radius: 20px;
        }
        
        .logo-snowflake {
            position: absolute;
            top: -10px;
            color: rgba(255,255,255,0.8);
            font-size: 10px;
            animation: logoSnowfall linear infinite;
            text-shadow: 0 0 3px rgba(100,150,255,0.5);
        }
        
        @keyframes logoSnowfall {
            0% {
                transform: translateY(0) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: translateY(60px) rotate(180deg);
                opacity: 0;
            }
        }
        
        .new-year-hidden .garland,
        .new-year-hidden .logo-snowflakes {
            display: none !important;
        }
        
        /* ========== Быстрые ответы ========== */
        .quick-replies-panel {
            display: none;
            position: absolute;
            bottom: 60px;
            left: 0;
            right: 0;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 1rem;
            box-shadow: 0 10px 30px rgba(0,0,0,0.15);
            z-index: 90;
            max-height: 200px;
            overflow-y: auto;
            animation: panel-pop 0.2s ease-out;
        }
        .quick-replies-panel.active { display: block; }
        .quick-reply-item {
            padding: 12px 16px;
            cursor: pointer;
            font-size: 13px;
            border-bottom: 1px solid var(--border);
            transition: background 0.15s;
        }
        .quick-reply-item:last-child { border-bottom: none; }
        .quick-reply-item:hover {
            background: rgba(79, 70, 229, 0.1);
        }
        .quick-reply-item .emoji {
            margin-right: 8px;
        }
        
        /* ========== Фича 3: Закладки сообщений ========== */
        .bookmarks-panel {
            position: fixed;
            top: 0;
            bottom: 0;
            right: 0;
            width: 350px;
            max-width: 100%;
            background: var(--bg-card);
            border-left: 1px solid var(--border);
            box-shadow: -10px 0 30px rgba(0,0,0,0.1);
            z-index: 200;
            transform: translateX(100%);
            transition: transform 0.3s ease;
            display: flex;
            flex-direction: column;
        }
        .bookmarks-panel.active {
            transform: translateX(0);
        }
        .bookmark-item {
            padding: 12px 16px;
            border-bottom: 1px solid var(--border);
            cursor: pointer;
            transition: background 0.15s;
        }
        .bookmark-item:hover {
            background: rgba(79, 70, 229, 0.05);
        }
        .bookmark-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }
        .bookmark-item-author {
            font-size: 12px;
            font-weight: bold;
            color: var(--accent);
        }
        .bookmark-item-time {
            font-size: 10px;
            opacity: 0.5;
        }
        .bookmark-item-text {
            font-size: 13px;
            opacity: 0.8;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }
        .bookmark-remove {
            opacity: 0;
            transition: opacity 0.15s;
        }
        .bookmark-item:hover .bookmark-remove {
            opacity: 1;
        }
        
        /* Подсветка сообщения при переходе из закладок */
        .highlight-msg {
            animation: highlight-pulse 2s ease-out;
        }
        @keyframes highlight-pulse {
            0%, 100% { box-shadow: none; }
            50% { box-shadow: 0 0 0 4px var(--accent), 0 0 20px var(--accent); }
        }
        
        /* ========== Заметки (Notes) ========== */
        .notes-panel {
            position: fixed;
            top: 0;
            bottom: 0;
            right: 0;
            width: 380px;
            max-width: 100%;
            background: var(--bg-card);
            border-left: 1px solid var(--border);
            box-shadow: -10px 0 30px rgba(0,0,0,0.1);
            z-index: 200;
            transform: translateX(100%);
            transition: transform 0.3s ease;
            display: flex;
            flex-direction: column;
        }
        .notes-panel.active {
            transform: translateX(0);
        }
        .note-item {
            padding: 14px 16px;
            border-bottom: 1px solid var(--border);
            cursor: pointer;
            transition: background 0.15s;
        }
        .note-item:hover {
            background: rgba(79, 70, 229, 0.05);
        }
        .note-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        .note-item-title {
            font-size: 14px;
            font-weight: 600;
            color: var(--text);
        }
        .note-item-date {
            font-size: 10px;
            opacity: 0.5;
        }
        .note-item-preview {
            font-size: 13px;
            opacity: 0.6;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }
        .note-editor {
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        .note-editor textarea {
            flex: 1;
            width: 100%;
            padding: 16px;
            border: none;
            background: transparent;
            resize: none;
            outline: none;
            font-size: 14px;
            line-height: 1.6;
        }
        .note-color-picker {
            display: flex;
            gap: 8px;
            padding: 12px 16px;
            border-top: 1px solid var(--border);
        }
        .note-color {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.2s;
            border: 2px solid transparent;
        }
        .note-color:hover { transform: scale(1.2); }
        .note-color.active { border-color: var(--text); }
        
        /* ========== Прочитано (Read receipts) ========== */
        .read-receipt {
            display: inline-flex;
            align-items: center;
            gap: 3px;
            font-size: 9px;
            opacity: 0.5;
            margin-left: 6px;
        }
        .read-receipt i {
            font-size: 10px;
        }
        .read-receipt.read {
            color: #3b82f6;
            opacity: 1;
        }
        .read-receipt-time {
            font-size: 8px;
            opacity: 0.7;
        }
        
        /* ========== Расширенный поиск ========== */
        .search-panel {
            position: fixed;
            top: 0;
            bottom: 0;
            right: 0;
            width: 400px;
            max-width: 100%;
            background: var(--bg-card);
            border-left: 1px solid var(--border);
            box-shadow: -10px 0 30px rgba(0,0,0,0.1);
            z-index: 200;
            transform: translateX(100%);
            transition: transform 0.3s ease;
            display: flex;
            flex-direction: column;
        }
        .search-panel.active {
            transform: translateX(0);
        }
        .search-filters {
            padding: 12px 16px;
            border-bottom: 1px solid var(--border);
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }
        .search-filter-btn {
            padding: 6px 12px;
            border-radius: 20px;
            border: 1px solid var(--border);
            background: transparent;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .search-filter-btn:hover {
            border-color: var(--accent);
            color: var(--accent);
        }
        .search-filter-btn.active {
            background: var(--accent);
            color: white;
            border-color: var(--accent);
        }
        .search-date-range {
            display: flex;
            gap: 8px;
            padding: 12px 16px;
            border-bottom: 1px solid var(--border);
        }
        .search-date-range input {
            flex: 1;
            padding: 8px 12px;
            border: 1px solid var(--border);
            border-radius: 10px;
            background: var(--bg-app);
            font-size: 12px;
            outline: none;
        }
        .search-date-range input:focus {
            border-color: var(--accent);
        }
        .search-results {
            flex: 1;
            overflow-y: auto;
        }
        .search-result-item {
            padding: 12px 16px;
            border-bottom: 1px solid var(--border);
            cursor: pointer;
            transition: background 0.15s;
        }
        .search-result-item:hover {
            background: rgba(79, 70, 229, 0.05);
        }
        .search-result-type {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            font-size: 10px;
            padding: 2px 8px;
            border-radius: 10px;
            background: rgba(99, 102, 241, 0.1);
            color: var(--accent);
            margin-bottom: 6px;
        }
        .search-result-text {
            font-size: 13px;
        }
        .search-result-text mark {
            background: rgba(234, 179, 8, 0.3);
            color: inherit;
            padding: 0 2px;
            border-radius: 2px;
        }
        .search-result-meta {
            font-size: 10px;
            opacity: 0.5;
            margin-top: 4px;
        }
        
        /* Модальное окно профиля */
        .profile-modal {
            position: fixed;
            inset: 0;
            z-index: 300;
            background: rgba(0,0,0,0.6);
            backdrop-filter: blur(8px);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            animation: modal-fade 0.2s ease;
        }
        .profile-modal-content {
            background: var(--bg-card);
            border-radius: 24px;
            width: 100%;
            max-width: 360px;
            box-shadow: 0 25px 80px rgba(0,0,0,0.4);
            animation: modal-pop 0.25s ease;
            overflow: hidden;
        }
        .profile-header {
            background: linear-gradient(135deg, var(--accent), #8b5cf6);
            padding: 30px 20px;
            text-align: center;
            color: white;
        }
        .profile-avatar {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background: white;
            margin: 0 auto 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 40px;
            font-weight: bold;
            color: var(--accent);
            overflow: hidden;
            border: 4px solid rgba(255,255,255,0.3);
        }
        .profile-avatar img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        .profile-name {
            font-size: 20px;
            font-weight: bold;
        }
        .profile-status {
            font-size: 12px;
            opacity: 0.8;
            margin-top: 4px;
        }
        .profile-body {
            padding: 20px;
        }
        .profile-info-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 0;
            border-bottom: 1px solid var(--border);
        }
        .profile-info-item:last-child {
            border-bottom: none;
        }
        .profile-info-icon {
            width: 36px;
            height: 36px;
            border-radius: 10px;
            background: rgba(99, 102, 241, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--accent);
        }
        .profile-info-label {
            font-size: 11px;
            opacity: 0.5;
            text-transform: uppercase;
        }
        .profile-info-value {
            font-size: 14px;
            font-weight: 500;
        }
        .profile-hidden {
            text-align: center;
            padding: 40px 20px;
            opacity: 0.5;
        }
        
        /* Голосование (Poll) */
        .poll-container {
            background: rgba(99, 102, 241, 0.05);
            border-radius: 16px;
            padding: 16px;
            min-width: 250px;
        }
        .poll-question {
            font-weight: 600;
            font-size: 15px;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .poll-question i {
            color: var(--accent);
        }
        .poll-option {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 10px 14px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
            overflow: hidden;
        }
        .poll-option:hover:not(.voted):not(.poll-ended) {
            border-color: var(--accent);
            background: rgba(99, 102, 241, 0.1);
        }
        .poll-option.selected {
            border-color: var(--accent);
            background: rgba(99, 102, 241, 0.15);
        }
        .poll-option .poll-progress {
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            background: rgba(99, 102, 241, 0.15);
            border-radius: 12px;
            transition: width 0.5s ease;
        }
        .poll-option-content {
            position: relative;
            z-index: 1;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .poll-option-text {
            font-size: 14px;
        }
        .poll-option-percent {
            font-size: 12px;
            font-weight: 600;
            color: var(--accent);
            opacity: 0;
            transition: opacity 0.3s;
        }
        .poll-option.voted .poll-option-percent,
        .poll-option.poll-ended .poll-option-percent {
            opacity: 1;
        }
        .poll-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 10px;
            font-size: 11px;
            opacity: 0.6;
        }
        .poll-votes-count {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        /* Модалка создания голосования */
        .poll-modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.6);
            backdrop-filter: blur(8px);
            z-index: 400;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            animation: modal-fade 0.2s ease;
        }
        .poll-modal {
            background: var(--bg-card);
            border-radius: 24px;
            width: 100%;
            max-width: 420px;
            box-shadow: 0 25px 80px rgba(0,0,0,0.4);
            animation: modal-pop 0.25s ease;
            overflow: hidden;
        }
        .poll-modal-header {
            padding: 20px;
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        .poll-modal-header h3 {
            font-weight: 700;
            font-size: 18px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .poll-modal-body {
            padding: 20px;
            max-height: 60vh;
            overflow-y: auto;
        }
        .poll-input-group {
            margin-bottom: 16px;
        }
        .poll-input-group label {
            display: block;
            font-size: 12px;
            font-weight: 600;
            margin-bottom: 6px;
            opacity: 0.7;
        }
        .poll-input {
            width: 100%;
            padding: 12px 14px;
            border: 1px solid var(--border);
            border-radius: 12px;
            background: var(--bg-app);
            font-size: 14px;
            outline: none;
            transition: border-color 0.2s;
        }
        .poll-input:focus {
            border-color: var(--accent);
        }
        .poll-options-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .poll-option-input {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .poll-option-input input {
            flex: 1;
            padding: 10px 12px;
            border: 1px solid var(--border);
            border-radius: 10px;
            background: var(--bg-app);
            font-size: 13px;
            outline: none;
        }
        .poll-option-input input:focus {
            border-color: var(--accent);
        }
        .poll-remove-option {
            width: 32px;
            height: 32px;
            border-radius: 8px;
            border: none;
            background: rgba(239, 68, 68, 0.1);
            color: #ef4444;
            cursor: pointer;
            transition: all 0.2s;
        }
        .poll-remove-option:hover {
            background: #ef4444;
            color: white;
        }
        .poll-add-option {
            padding: 10px;
            border: 2px dashed var(--border);
            border-radius: 10px;
            background: transparent;
            color: var(--accent);
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }
        .poll-add-option:hover {
            border-color: var(--accent);
            background: rgba(99, 102, 241, 0.05);
        }
        .poll-modal-footer {
            padding: 16px 20px;
            border-top: 1px solid var(--border);
            display: flex;
            gap: 10px;
        }
        .poll-modal-footer button {
            flex: 1;
            padding: 12px;
            border-radius: 12px;
            font-weight: 600;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
            border: none;
        }
        .poll-btn-cancel {
            background: var(--bg-app);
            color: var(--text);
        }
        .poll-btn-cancel:hover {
            background: rgba(239, 68, 68, 0.1);
            color: #ef4444;
        }
        .poll-btn-create {
            background: var(--accent);
            color: white;
        }
        .poll-btn-create:hover {
            filter: brightness(1.1);
        }
        .poll-btn-create:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        /* ========== РУБИНЫ ========== */
        .rubies-display {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 8px 14px;
            background: linear-gradient(135deg, #dc2626, #ef4444);
            border-radius: 20px;
            color: white;
            font-weight: bold;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 4px 15px rgba(220, 38, 38, 0.3);
        }
        .rubies-display:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(220, 38, 38, 0.4);
        }
        .rubies-display i {
            font-size: 16px;
            animation: ruby-shine 2s infinite;
        }
        @keyframes ruby-shine {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.3); }
        }
        .ruby-earned {
            position: fixed;
            z-index: 1000;
            color: #ef4444;
            font-weight: bold;
            font-size: 16px;
            pointer-events: none;
            animation: ruby-float 1.5s ease-out forwards;
        }
        @keyframes ruby-float {
            0% { opacity: 1; transform: translateY(0) scale(1); }
            100% { opacity: 0; transform: translateY(-50px) scale(1.5); }
        }
        
        /* Магазин рубинов */
        .ruby-shop-modal {
            position: fixed;
            inset: 0;
            z-index: 400;
            background: rgba(0,0,0,0.7);
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            animation: modal-fade 0.2s ease;
        }
        .ruby-shop-content {
            background: var(--bg-card);
            border-radius: 24px;
            width: 100%;
            max-width: 500px;
            max-height: 85vh;
            overflow: hidden;
            box-shadow: 0 25px 80px rgba(0,0,0,0.5);
            animation: modal-pop 0.25s ease;
        }
        .ruby-shop-header {
            background: linear-gradient(135deg, #dc2626, #b91c1c);
            padding: 24px;
            color: white;
            text-align: center;
        }
        .ruby-shop-header h3 {
            font-size: 24px;
            font-weight: 800;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }
        .ruby-shop-balance {
            font-size: 32px;
            font-weight: 800;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        .ruby-shop-balance i {
            animation: ruby-shine 2s infinite;
        }
        .ruby-shop-body {
            padding: 20px;
            max-height: 50vh;
            overflow-y: auto;
        }
        .ruby-shop-category {
            margin-bottom: 20px;
        }
        .ruby-shop-category-title {
            font-size: 12px;
            font-weight: 700;
            text-transform: uppercase;
            color: var(--accent);
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .ruby-shop-item {
            display: flex;
            align-items: center;
            gap: 14px;
            padding: 14px;
            background: var(--bg-app);
            border-radius: 16px;
            margin-bottom: 10px;
            transition: all 0.2s;
            border: 2px solid transparent;
        }
        .ruby-shop-item:hover {
            border-color: var(--accent);
            transform: translateX(5px);
        }
        .ruby-shop-item.owned {
            opacity: 0.6;
            border-color: #22c55e;
        }
        .ruby-shop-item-icon {
            width: 50px;
            height: 50px;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            flex-shrink: 0;
        }
        .ruby-shop-item-info {
            flex: 1;
        }
        .ruby-shop-item-name {
            font-weight: 600;
            font-size: 14px;
            margin-bottom: 2px;
        }
        .ruby-shop-item-desc {
            font-size: 11px;
            opacity: 0.6;
        }
        .ruby-shop-item-price {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 8px 14px;
            background: linear-gradient(135deg, #dc2626, #ef4444);
            color: white;
            border-radius: 20px;
            font-weight: bold;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .ruby-shop-item-price:hover {
            transform: scale(1.05);
        }
        .ruby-shop-item-price.owned {
            background: #22c55e;
            cursor: default;
        }
        .ruby-shop-item-price.owned:hover {
            transform: none;
        }
        
        /* Анимированные аватарки */
        .animated-avatar {
            position: relative;
        }
        .animated-avatar::before {
            content: '';
            position: absolute;
            inset: -3px;
            border-radius: 50%;
            background: linear-gradient(45deg, #f59e0b, #ef4444, #ec4899, #8b5cf6, #3b82f6);
            background-size: 300% 300%;
            animation: avatar-glow 3s ease infinite;
            z-index: -1;
        }
        @keyframes avatar-glow {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }
        
        /* Уникальное оформление чата */
        .premium-chat-bg {
            background: linear-gradient(135deg, rgba(99, 102, 241, 0.05), rgba(139, 92, 246, 0.05)) !important;
        }
        .premium-messages .sent {
            background: linear-gradient(135deg, #6366f1, #8b5cf6) !important;
        }
        .premium-messages .received {
            background: linear-gradient(135deg, var(--bg-card), rgba(99, 102, 241, 0.1)) !important;
        }
        
        /* Админ панель создателя */
        .creator-panel {
            background: linear-gradient(135deg, #fbbf24, #f59e0b) !important;
        }
        .creator-panel h3 {
            color: #78350f !important;
        }
    </style>
</head>
<body class="theme-light h-screen flex flex-col overflow-hidden">

<!-- Контейнер для тостов -->
<div id="toast-container"></div>

<!-- Модальное окно профиля -->
<div id="profile-modal" class="profile-modal" style="display: none;" onclick="if(event.target === this) closeProfileModal()">
    <div class="profile-modal-content">
        <div class="profile-header">
            <div class="profile-avatar" id="profile-modal-avatar">?</div>
            <div class="profile-name" id="profile-modal-name">@username</div>
            <div class="profile-status" id="profile-modal-status">Офлайн</div>
        </div>
        <div class="profile-body" id="profile-modal-body">
            <!-- Заполняется динамически -->
        </div>
        <div class="p-4 border-t border-[var(--border)]">
            <button onclick="closeProfileModal()" class="w-full py-3 bg-slate-100 dark:bg-slate-800 rounded-xl font-bold text-sm hover:bg-slate-200 dark:hover:bg-slate-700 transition-colors">
                Закрыть
            </button>
        </div>
    </div>
</div>

<!-- Модальное окно создания голосования -->
<div id="poll-modal" class="poll-modal-overlay" style="display: none;" onclick="if(event.target === this) closePollModal()">
    <div class="poll-modal" onclick="event.stopPropagation()">
        <div class="poll-modal-header">
            <h3><i class="fas fa-poll text-purple-500"></i> Создать голосование</h3>
            <button onclick="closePollModal()" class="w-10 h-10 rounded-full hover:bg-slate-100 dark:hover:bg-slate-800 flex items-center justify-center">
                <i class="fas fa-times"></i>
            </button>
        </div>
        <div class="poll-modal-body">
            <div class="poll-input-group">
                <label>Вопрос</label>
                <input type="text" id="poll-question" class="poll-input" placeholder="Введите вопрос..." maxlength="200">
            </div>
            <div class="poll-input-group">
                <label>Варианты ответа (минимум 2)</label>
                <div id="poll-options-container" class="poll-options-list">
                    <div class="poll-option-input">
                        <input type="text" placeholder="Вариант 1" maxlength="100">
                        <button class="poll-remove-option" onclick="removePollOption(this)" style="visibility: hidden;">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                    <div class="poll-option-input">
                        <input type="text" placeholder="Вариант 2" maxlength="100">
                        <button class="poll-remove-option" onclick="removePollOption(this)" style="visibility: hidden;">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                </div>
                <button class="poll-add-option" onclick="addPollOption()">
                    <i class="fas fa-plus"></i> Добавить вариант
                </button>
            </div>
            <div class="poll-input-group">
                <label class="flex items-center gap-2 cursor-pointer">
                    <input type="checkbox" id="poll-anonymous" class="w-4 h-4 accent-indigo-500">
                    <span class="text-sm">Анонимное голосование</span>
                </label>
            </div>
            <div class="poll-input-group">
                <label class="flex items-center gap-2 cursor-pointer">
                    <input type="checkbox" id="poll-multiple" class="w-4 h-4 accent-indigo-500">
                    <span class="text-sm">Можно выбрать несколько вариантов</span>
                </label>
            </div>
        </div>
        <div class="poll-modal-footer">
            <button class="poll-btn-cancel" onclick="closePollModal()">Отмена</button>
            <button class="poll-btn-create" onclick="createPoll()">Создать</button>
        </div>
    </div>
</div>

<!-- Панель закладок -->
<div id="bookmarks-panel" class="bookmarks-panel">
    <div class="p-4 border-b border-[var(--border)] flex items-center justify-between">
        <div class="flex items-center gap-3">
            <i class="fas fa-bookmark text-yellow-500 text-xl"></i>
            <div>
                <p class="font-bold" data-i18n="bookmarks">Закладки</p>
                <p class="text-xs opacity-50" data-i18n="savedMessages">Сохранённые сообщения</p>
            </div>
        </div>
        <button onclick="toggleBookmarks()" class="w-10 h-10 rounded-full hover:bg-slate-100 dark:hover:bg-slate-800 flex items-center justify-center">
            <i class="fas fa-times"></i>
        </button>
    </div>
    <div id="bookmarks-list" class="flex-1 overflow-y-auto">
        <div class="p-8 text-center opacity-50">
            <i class="fas fa-bookmark text-4xl mb-3"></i>
            <p class="text-sm" data-i18n="noBookmarks">Нет закладок</p>
        </div>
    </div>
</div>

<!-- Панель заметок -->
<div id="notes-panel" class="notes-panel">
    <div class="p-4 border-b border-[var(--border)] flex items-center justify-between">
        <div class="flex items-center gap-3">
            <i class="fas fa-sticky-note text-orange-500 text-xl"></i>
            <div>
                <p class="font-bold">Заметки</p>
                <p class="text-xs opacity-50">Личные записи</p>
            </div>
        </div>
        <div class="flex gap-2">
            <button onclick="createNewNote()" class="w-10 h-10 rounded-full hover:bg-green-50 hover:text-green-500 flex items-center justify-center transition-all" title="Новая заметка">
                <i class="fas fa-plus"></i>
            </button>
            <button onclick="toggleNotes()" class="w-10 h-10 rounded-full hover:bg-slate-100 dark:hover:bg-slate-800 flex items-center justify-center">
                <i class="fas fa-times"></i>
            </button>
        </div>
    </div>
    <div id="notes-list" class="flex-1 overflow-y-auto">
        <div class="p-8 text-center opacity-50">
            <i class="fas fa-sticky-note text-4xl mb-3"></i>
            <p class="text-sm">Нет заметок</p>
            <p class="text-xs mt-2">Нажмите + чтобы создать</p>
        </div>
    </div>
</div>

<!-- Редактор заметки -->
<div id="note-editor-panel" class="notes-panel">
    <div class="p-4 border-b border-[var(--border)] flex items-center justify-between">
        <button onclick="closeNoteEditor()" class="w-10 h-10 rounded-full hover:bg-slate-100 dark:hover:bg-slate-800 flex items-center justify-center">
            <i class="fas fa-arrow-left"></i>
        </button>
        <input type="text" id="note-title-input" placeholder="Название заметки..." class="flex-1 mx-3 bg-transparent border-none outline-none font-bold text-lg">
        <button onclick="saveCurrentNote()" class="w-10 h-10 rounded-full hover:bg-green-50 text-green-500 flex items-center justify-center" title="Сохранить">
            <i class="fas fa-check"></i>
        </button>
        <button onclick="deleteCurrentNote()" class="w-10 h-10 rounded-full hover:bg-red-50 text-red-500 flex items-center justify-center" title="Удалить">
            <i class="fas fa-trash"></i>
        </button>
    </div>
    <div class="note-editor">
        <textarea id="note-content-input" placeholder="Напишите что-нибудь..."></textarea>
    </div>
    <div class="note-color-picker">
        <div class="note-color active" style="background: #f1f5f9;" data-color="#f1f5f9" onclick="setNoteColor(this)"></div>
        <div class="note-color" style="background: #fef3c7;" data-color="#fef3c7" onclick="setNoteColor(this)"></div>
        <div class="note-color" style="background: #dcfce7;" data-color="#dcfce7" onclick="setNoteColor(this)"></div>
        <div class="note-color" style="background: #dbeafe;" data-color="#dbeafe" onclick="setNoteColor(this)"></div>
        <div class="note-color" style="background: #fce7f3;" data-color="#fce7f3" onclick="setNoteColor(this)"></div>
        <div class="note-color" style="background: #f3e8ff;" data-color="#f3e8ff" onclick="setNoteColor(this)"></div>
    </div>
</div>

<!-- Панель расширенного поиска -->
<div id="search-panel" class="search-panel">
    <div class="p-4 border-b border-[var(--border)] flex items-center justify-between">
        <div class="flex items-center gap-3">
            <i class="fas fa-search text-blue-500 text-xl"></i>
            <div>
                <p class="font-bold">Расширенный поиск</p>
                <p class="text-xs opacity-50">Поиск по чату</p>
            </div>
        </div>
        <button onclick="toggleSearchPanel()" class="w-10 h-10 rounded-full hover:bg-slate-100 dark:hover:bg-slate-800 flex items-center justify-center">
            <i class="fas fa-times"></i>
        </button>
    </div>
    <div class="p-3 border-b border-[var(--border)]">
        <input type="text" id="advanced-search-input" placeholder="Поиск..." class="w-full p-3 bg-slate-100 dark:bg-slate-800 rounded-xl outline-none focus:ring-2 focus:ring-blue-500" oninput="performAdvancedSearch()">
    </div>
    <div class="search-filters">
        <button class="search-filter-btn active" data-filter="all" onclick="setSearchFilter('all')">
            <i class="fas fa-globe"></i> Всё
        </button>
        <button class="search-filter-btn" data-filter="text" onclick="setSearchFilter('text')">
            <i class="fas fa-font"></i> Текст
        </button>
        <button class="search-filter-btn" data-filter="images" onclick="setSearchFilter('images')">
            <i class="fas fa-image"></i> Фото
        </button>
        <button class="search-filter-btn" data-filter="files" onclick="setSearchFilter('files')">
            <i class="fas fa-file"></i> Файлы
        </button>
        <button class="search-filter-btn" data-filter="links" onclick="setSearchFilter('links')">
            <i class="fas fa-link"></i> Ссылки
        </button>
    </div>
    <div class="search-date-range">
        <input type="date" id="search-date-from" placeholder="От" onchange="performAdvancedSearch()">
        <input type="date" id="search-date-to" placeholder="До" onchange="performAdvancedSearch()">
    </div>
    <div id="search-results" class="search-results">
        <div class="p-8 text-center opacity-50">
            <i class="fas fa-search text-4xl mb-3"></i>
            <p class="text-sm">Введите запрос для поиска</p>
        </div>
    </div>
</div>

<!-- Просмотр медиа на весь экран (фото и видео) -->
<div id="media-viewer" class="fixed inset-0 z-[9999] bg-black/95 hidden flex items-center justify-center backdrop-blur-sm" onclick="closeMediaViewer(event)">
    <button onclick="closeMediaViewer()" class="absolute top-4 right-4 w-10 h-10 rounded-full bg-white/10 hover:bg-white/20 text-white flex items-center justify-center transition-all z-10">
        <i class="fas fa-times text-xl"></i>
    </button>
    <button id="media-viewer-prev" onclick="navigateMedia(-1); event.stopPropagation();" class="absolute left-4 top-1/2 -translate-y-1/2 w-12 h-12 rounded-full bg-white/10 hover:bg-white/20 text-white flex items-center justify-center transition-all z-10">
        <i class="fas fa-chevron-left text-xl"></i>
    </button>
    <button id="media-viewer-next" onclick="navigateMedia(1); event.stopPropagation();" class="absolute right-4 top-1/2 -translate-y-1/2 w-12 h-12 rounded-full bg-white/10 hover:bg-white/20 text-white flex items-center justify-center transition-all z-10">
        <i class="fas fa-chevron-right text-xl"></i>
    </button>
    
    <!-- Контейнер для медиа -->
    <div id="media-viewer-content" class="max-w-[90vw] max-h-[90vh] flex items-center justify-center" onclick="event.stopPropagation()">
        <img id="media-viewer-img" src="" class="max-w-[90vw] max-h-[90vh] object-contain rounded-lg shadow-2xl hidden">
        <video id="media-viewer-video" src="" class="max-w-[90vw] max-h-[90vh] object-contain rounded-lg shadow-2xl hidden" controls playsinline></video>
    </div>
    
    <!-- Счётчик и кнопки -->
    <div class="absolute bottom-4 left-1/2 -translate-x-1/2 flex flex-col items-center gap-2">
        <span id="media-viewer-counter" class="text-white/70 text-sm"></span>
        <div class="flex gap-2">
            <a id="media-viewer-download" href="" download class="px-4 py-2 rounded-full bg-white/10 hover:bg-white/20 text-white text-sm flex items-center gap-2 transition-all">
                <i class="fas fa-download"></i>
                <span>Скачать</span>
            </a>
        </div>
    </div>
    
    <!-- Миниатюры -->
    <div id="media-viewer-thumbnails" class="absolute bottom-20 left-1/2 -translate-x-1/2 flex gap-2 max-w-[80vw] overflow-x-auto p-2 bg-black/50 rounded-xl hidden"></div>
</div>

<!-- Старый просмотрщик для совместимости -->
<div id="image-viewer" class="fixed inset-0 z-[9999] bg-black/95 hidden flex items-center justify-center backdrop-blur-sm" onclick="closeImageViewer(event)">
    <button onclick="closeImageViewer()" class="absolute top-4 right-4 w-10 h-10 rounded-full bg-white/10 hover:bg-white/20 text-white flex items-center justify-center transition-all">
        <i class="fas fa-times text-xl"></i>
    </button>
    <button id="image-viewer-prev" onclick="navigateImage(-1); event.stopPropagation();" class="absolute left-4 top-1/2 -translate-y-1/2 w-12 h-12 rounded-full bg-white/10 hover:bg-white/20 text-white flex items-center justify-center transition-all">
        <i class="fas fa-chevron-left text-xl"></i>
    </button>
    <button id="image-viewer-next" onclick="navigateImage(1); event.stopPropagation();" class="absolute right-4 top-1/2 -translate-y-1/2 w-12 h-12 rounded-full bg-white/10 hover:bg-white/20 text-white flex items-center justify-center transition-all">
        <i class="fas fa-chevron-right text-xl"></i>
    </button>
    <img id="image-viewer-img" src="" class="max-w-[90vw] max-h-[90vh] object-contain rounded-lg shadow-2xl" onclick="event.stopPropagation()">
    <div class="absolute bottom-4 left-1/2 -translate-x-1/2 flex gap-2">
        <a id="image-viewer-download" href="" download class="px-4 py-2 rounded-full bg-white/10 hover:bg-white/20 text-white text-sm flex items-center gap-2 transition-all">
            <i class="fas fa-download"></i>
            <span data-i18n="downloadFile">Скачать</span>
        </a>
    </div>
</div>

<!-- Модальное окно создания группы -->
<div id="create-group-modal" class="fixed inset-0 z-[9998] bg-black/50 hidden flex items-center justify-center backdrop-blur-sm" onclick="closeCreateGroup(event)">
    <div class="bg-[var(--bg-primary)] rounded-2xl shadow-2xl w-full max-w-md mx-4 overflow-hidden" onclick="event.stopPropagation()">
        <div class="p-4 border-b border-[var(--border)] flex items-center justify-between">
            <h3 class="font-bold text-lg" data-i18n="createGroup">Создать группу</h3>
            <button onclick="closeCreateGroup()" class="w-8 h-8 rounded-lg hover:bg-slate-100 dark:hover:bg-slate-800 flex items-center justify-center">
                <i class="fas fa-times"></i>
            </button>
        </div>
        <div class="p-4">
            <input type="text" id="group-name-input" data-i18n-placeholder="groupName" placeholder="Название группы..." class="w-full p-3 bg-slate-100 dark:bg-slate-800 rounded-xl outline-none text-sm border border-transparent focus:border-indigo-500 transition-all mb-4">
            
            <p class="text-xs text-slate-500 mb-2"><span data-i18n="selectedMembers">Выбрано участников</span>: <span id="selected-count">0</span>/12</p>
            
            <div id="selected-members" class="flex flex-wrap gap-2 mb-4 min-h-[40px] p-2 bg-slate-50 dark:bg-slate-800/50 rounded-xl"></div>
            
            <div class="relative mb-4">
                <i class="fas fa-search absolute left-3 top-1/2 -translate-y-1/2 text-slate-400"></i>
                <input type="text" id="group-search-input" data-i18n-placeholder="searchUsers" placeholder="Поиск пользователей..." class="w-full p-3 pl-10 bg-slate-100 dark:bg-slate-800 rounded-xl outline-none text-sm border border-transparent focus:border-indigo-500 transition-all">
            </div>
            
            <div id="group-search-results" class="max-h-48 overflow-y-auto space-y-2 mb-4"></div>
            
            <button onclick="createGroup()" id="create-group-btn" class="w-full p-3 bg-indigo-500 hover:bg-indigo-600 disabled:bg-slate-300 disabled:cursor-not-allowed text-white rounded-xl font-bold transition-colors" disabled>
                <i class="fas fa-users mr-2"></i>
                <span data-i18n="createGroupBtn">Создать группу</span>
            </button>
        </div>
    </div>
</div>

<!-- Экран входящего звонка -->
<div id="incoming-call-screen" class="call-screen hidden">
    <div class="absolute inset-0 overflow-hidden">
        <div class="absolute w-96 h-96 bg-indigo-500/20 rounded-full blur-3xl -top-20 -left-20 animate-pulse"></div>
        <div class="absolute w-96 h-96 bg-purple-500/20 rounded-full blur-3xl -bottom-20 -right-20 animate-pulse" style="animation-delay: 1s"></div>
    </div>
    <div class="relative z-10 flex flex-col items-center">
        <div class="relative">
            <div class="call-avatar overflow-hidden" id="caller-avatar">?</div>
            <div class="absolute inset-0 rounded-full border-4 border-green-400 animate-ping opacity-50"></div>
        </div>
        <p class="text-white text-2xl font-bold mt-6" id="caller-name" data-i18n="incomingCall">Входящий звонок</p>
        <p class="text-white/60 text-sm mt-2 flex items-center gap-2">
            <i class="fas fa-phone-alt text-green-400 animate-bounce"></i>
            <span id="call-type-label" data-i18n="audioCallType">Аудио звонок</span>
        </p>
        <p class="text-white/40 text-xs mt-4" data-i18n="flickersCall">Flickers звонок</p>
        <div class="flex gap-6 mt-10">
            <div class="flex flex-col items-center">
                <button class="call-btn call-btn-decline shadow-lg shadow-red-500/30" onclick="declineCall()">
                    <i class="fas fa-phone-slash"></i>
                </button>
                <span class="text-white/60 text-xs mt-2" data-i18n="decline">Отклонить</span>
            </div>
            <div class="flex flex-col items-center">
                <button class="call-btn call-btn-accept shadow-lg shadow-green-500/30 animate-pulse" onclick="acceptCall()">
                    <i class="fas fa-phone-alt"></i>
                </button>
                <span class="text-white/60 text-xs mt-2" data-i18n="accept">Принять</span>
            </div>
        </div>
    </div>
</div>

<!-- Экран исходящего звонка -->
<div id="outgoing-call-screen" class="call-screen hidden">
    <div class="absolute inset-0 overflow-hidden">
        <div class="absolute w-96 h-96 bg-indigo-500/20 rounded-full blur-3xl -top-20 -right-20 animate-pulse"></div>
        <div class="absolute w-96 h-96 bg-blue-500/20 rounded-full blur-3xl -bottom-20 -left-20 animate-pulse" style="animation-delay: 0.5s"></div>
    </div>
    <div class="relative z-10 flex flex-col items-center">
        <div class="relative">
            <div class="call-avatar overflow-hidden" id="callee-avatar">?</div>
            <div class="absolute -inset-2 rounded-full border-2 border-white/20 animate-spin" style="animation-duration: 3s"></div>
            <div class="absolute -inset-4 rounded-full border border-white/10 animate-spin" style="animation-duration: 5s; animation-direction: reverse"></div>
        </div>
        <p class="text-white text-2xl font-bold mt-6" id="callee-name" data-i18n="calling">Звоним...</p>
        <div class="flex items-center gap-1 mt-2">
            <span class="w-2 h-2 bg-white/60 rounded-full animate-bounce" style="animation-delay: 0s"></span>
            <span class="w-2 h-2 bg-white/60 rounded-full animate-bounce" style="animation-delay: 0.2s"></span>
            <span class="w-2 h-2 bg-white/60 rounded-full animate-bounce" style="animation-delay: 0.4s"></span>
        </div>
        <p class="text-white/40 text-xs mt-4" id="outgoing-call-status" data-i18n="waitingAnswer">Ожидание ответа...</p>
        <div class="flex gap-6 mt-10">
            <div class="flex flex-col items-center">
                <button class="call-btn call-btn-decline shadow-lg shadow-red-500/30" onclick="cancelCall()">
                    <i class="fas fa-phone-slash"></i>
                </button>
                <span class="text-white/60 text-xs mt-2" data-i18n="cancelCall">Отмена</span>
            </div>
        </div>
    </div>
</div>

<!-- Экран активного звонка -->
<div id="active-call-screen" class="video-container hidden">
    <!-- Кнопка сворачивания -->
    <button class="minimize-call-btn" onclick="minimizeCall()" title="Свернуть звонок">
        <i class="fas fa-compress-alt"></i>
    </button>
    
    <video id="remote-video" class="remote-video" autoplay playsinline></video>
    <video id="local-video" class="local-video" autoplay playsinline muted></video>
    
    <!-- Контейнер для участников группового звонка -->
    <div id="group-call-participants" class="absolute inset-0 hidden">
        <div id="group-videos-grid" class="w-full h-full grid gap-2 p-2"></div>
    </div>
    
    <!-- Оверлей для аудио звонка -->
    <div id="audio-call-overlay" class="absolute inset-0 bg-gradient-to-br from-slate-900 via-indigo-900 to-slate-900 flex flex-col items-center justify-center">
        <div class="absolute inset-0 overflow-hidden">
            <div class="absolute w-[500px] h-[500px] bg-indigo-500/10 rounded-full blur-3xl top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 animate-pulse"></div>
        </div>
        <!-- Контейнер для аватаров участников группового аудио звонка -->
        <div id="group-audio-participants" class="hidden flex-wrap justify-center gap-4 max-w-md"></div>
        <div class="relative z-10 flex flex-col items-center" id="single-call-avatar-container">
            <div class="w-32 h-32 rounded-full bg-indigo-500/30 flex items-center justify-center text-5xl font-bold text-white border-4 border-indigo-400/50 overflow-hidden" id="active-call-avatar">?</div>
            <p class="text-white text-xl font-bold mt-6" id="active-call-name-audio">Звонок</p>
            <div class="flex items-center gap-2 mt-2 text-green-400">
                <span class="w-2 h-2 bg-green-400 rounded-full animate-pulse"></span>
                <span class="text-sm" id="call-timer-audio">00:00</span>
            </div>
            <div class="flex items-center gap-1 mt-4" id="audio-visualizer">
                <span class="w-1 h-4 bg-indigo-400 rounded-full animate-pulse"></span>
                <span class="w-1 h-6 bg-indigo-400 rounded-full animate-pulse" style="animation-delay: 0.1s"></span>
                <span class="w-1 h-8 bg-indigo-400 rounded-full animate-pulse" style="animation-delay: 0.2s"></span>
                <span class="w-1 h-6 bg-indigo-400 rounded-full animate-pulse" style="animation-delay: 0.3s"></span>
                <span class="w-1 h-4 bg-indigo-400 rounded-full animate-pulse" style="animation-delay: 0.4s"></span>
            </div>
        </div>
    </div>
    
    <div class="video-controls">
        <button class="call-btn call-btn-mute" id="mute-btn" onclick="toggleMute()" title="Микрофон">
            <i class="fas fa-microphone"></i>
        </button>
        <button class="call-btn call-btn-mute" id="video-btn" onclick="toggleVideo()" title="Камера">
            <i class="fas fa-video"></i>
        </button>
        <button class="call-btn call-btn-mute" id="screen-share-btn" onclick="toggleScreenShare()" title="Демонстрация экрана">
            <i class="fas fa-desktop"></i>
        </button>
        <button class="call-btn call-btn-mute" id="speaker-btn" onclick="toggleSpeaker()" title="Динамик">
            <i class="fas fa-volume-up"></i>
        </button>
        <button class="call-btn call-btn-decline" onclick="endCall()" title="Завершить">
            <i class="fas fa-phone-slash"></i>
        </button>
    </div>
    
    <div class="absolute top-6 left-1/2 -translate-x-1/2 text-white text-center bg-black/30 px-4 py-2 rounded-full backdrop-blur-sm">
        <p class="font-bold text-sm" id="active-call-name">Звонок</p>
        <p class="text-xs opacity-60" id="call-timer">00:00</p>
        <div id="screen-share-indicator" class="hidden text-xs text-blue-300 mt-1">
            <i class="fas fa-desktop"></i> <span id="screen-share-user">Кто-то</span> демонстрирует экран
            <button id="watch-screen-btn" class="ml-2 px-2 py-1 bg-blue-500 hover:bg-blue-600 text-white rounded text-xs transition-colors" onclick="toggleScreenWatch()">
                Смотреть
            </button>
        </div>
    </div>
</div>

<!-- Свёрнутый звонок (мини-плеер) -->
<div id="minimized-call" class="call-minimized" style="display: none;">
    <div class="call-minimized-header" onclick="expandCall()">
        <div class="call-minimized-avatar" id="mini-call-avatar">?</div>
        <div class="call-minimized-info">
            <div class="call-minimized-name" id="mini-call-name">Звонок</div>
            <div class="call-minimized-status">
                <span class="pulse-dot"></span>
                <span id="mini-call-timer">00:00</span>
            </div>
        </div>
    </div>
    <div class="call-minimized-actions">
        <button class="call-mini-btn call-mini-btn-expand" onclick="expandCall()">
            <i class="fas fa-expand-alt"></i> Развернуть
        </button>
        <button class="call-mini-btn call-mini-btn-end" onclick="endCall()">
            <i class="fas fa-phone-slash"></i>
        </button>
    </div>
</div>

<!-- Загрузочный экран -->
<div id="loading-overlay" class="fixed inset-0 z-[100] bg-slate-900 flex flex-col items-center justify-center transition-opacity duration-500">
    <div class="relative">
        <div class="w-20 h-20 border-4 border-indigo-500/20 border-t-indigo-500 rounded-full animate-spin"></div>
        <div class="absolute inset-0 flex items-center justify-center">
            <i class="fas fa-bolt text-indigo-500 animate-pulse"></i>
        </div>
    </div>
    <div class="mt-6 text-2xl font-black text-white tracking-[0.3em] animate-pulse">FLICKERS</div>
</div>

<!-- Экран авторизации -->
<div id="auth-screen" class="fixed inset-0 z-50 flex items-center justify-center hidden p-4 transition-colors duration-300">
    <!-- Переключатель языка и темы -->
    <div class="absolute top-4 right-4 flex gap-2">
        <button onclick="cycleAuthTheme()" id="auth-theme-btn" class="auth-lang-btn px-3 py-2 rounded-xl text-white/80 hover:text-white hover:bg-white/20 transition-all text-sm font-medium" title="Сменить тему">
            ☀️
        </button>
        <button onclick="setLanguage('ru')" class="auth-lang-btn px-3 py-2 rounded-xl text-white/80 hover:text-white hover:bg-white/20 transition-all text-sm font-medium" data-lang="ru">RU</button>
        <button onclick="setLanguage('en')" class="auth-lang-btn px-3 py-2 rounded-xl text-white/80 hover:text-white hover:bg-white/20 transition-all text-sm font-medium" data-lang="en">EN</button>
    </div>
    
    <div id="auth-card" class="bg-white p-10 rounded-[2.5rem] shadow-2xl w-full max-w-md text-center transform transition-all">
        <div class="w-20 h-20 bg-indigo-100 text-indigo-600 rounded-[2rem] flex items-center justify-center mx-auto text-4xl mb-2 animate-bounce">
            <i class="fas fa-bolt"></i>
        </div>
        <h1 id="auth-title" class="text-3xl font-black text-slate-800 mb-1 new-year-logo">
            FLICKERS
            <div class="garland">
                <div class="garland-wire"></div>
                <div class="garland-light"></div>
                <div class="garland-light"></div>
                <div class="garland-light"></div>
                <div class="garland-light"></div>
                <div class="garland-light"></div>
                <div class="garland-light"></div>
                <div class="garland-light"></div>
            </div>
            <div class="logo-snowflakes" id="auth-snowflakes"></div>
        </h1>
        <p class="text-indigo-500 text-sm font-medium mb-4" data-i18n="aiTagline">Умный мессенджер с нейросетями ✨</p>
        
        <!-- Вкладки Вход/Регистрация -->
        <div class="flex mb-6 bg-slate-100 rounded-2xl p-1">
            <button id="tab-login" onclick="switchAuthTab('login')" class="flex-1 py-3 rounded-xl font-bold text-sm transition-all bg-white shadow text-indigo-600">
                <i class="fas fa-sign-in-alt mr-2"></i><span data-i18n="loginTab">Вход</span>
            </button>
            <button id="tab-register" onclick="switchAuthTab('register')" class="flex-1 py-3 rounded-xl font-bold text-sm transition-all text-slate-500">
                <i class="fas fa-user-plus mr-2"></i><span data-i18n="registerTab">Регистрация</span>
            </button>
        </div>
            
        <!-- Форма входа -->
        <div id="login-form">
            <h2 class="text-2xl font-black text-slate-800 mb-2" data-i18n="welcomeBack">С возвращением!</h2>
            <p class="text-slate-500 mb-6 text-sm" data-i18n="enterCredentials">Введите данные для входа</p>
            
            <input type="text" id="login-username" data-i18n-placeholder="username" placeholder="Имя пользователя" class="w-full p-4 bg-slate-100 rounded-2xl outline-none mb-3 focus:ring-2 focus:ring-indigo-500 transition-all">
            <input type="password" id="login-password" data-i18n-placeholder="password" placeholder="Пароль" class="w-full p-4 bg-slate-100 rounded-2xl outline-none mb-4 focus:ring-2 focus:ring-indigo-500 transition-all">
            
            <p id="login-error" class="text-red-500 text-sm mb-4 hidden"></p>
            
            <button onclick="handleLogin()" class="w-full bg-indigo-600 text-white font-bold py-4 rounded-2xl hover:bg-indigo-700 transition-all shadow-lg active:scale-95">
                <span data-i18n="loginBtn">Войти</span>
            </button>
        </div>
        
        <!-- Форма регистрации -->
        <div id="register-form" class="hidden">
            <h2 class="text-2xl font-black text-slate-800 mb-2" data-i18n="createAccount">Создать аккаунт</h2>
            <p class="text-slate-500 mb-6 text-sm" data-i18n="fillToRegister">Заполните данные для регистрации</p>
            
            <input type="text" id="register-username" data-i18n-placeholder="username" placeholder="Имя пользователя" class="w-full p-4 bg-slate-100 rounded-2xl outline-none mb-3 focus:ring-2 focus:ring-indigo-500 transition-all">
            <input type="password" id="register-password" data-i18n-placeholder="password" placeholder="Пароль" class="w-full p-4 bg-slate-100 rounded-2xl outline-none mb-3 focus:ring-2 focus:ring-indigo-500 transition-all">
            <input type="password" id="register-password-confirm" data-i18n-placeholder="confirmPassword" placeholder="Подтвердите пароль" class="w-full p-4 bg-slate-100 rounded-2xl outline-none mb-4 focus:ring-2 focus:ring-indigo-500 transition-all">
            
            <p id="register-error" class="text-red-500 text-sm mb-4 hidden"></p>
            
            <button onclick="handleRegister()" class="w-full bg-indigo-600 text-white font-bold py-4 rounded-2xl hover:bg-indigo-700 transition-all shadow-lg active:scale-95">
                <span data-i18n="registerBtn">Зарегистрироваться</span>
            </button>
        </div>
    </div>
</div>

<!-- Основное приложение -->
<div id="main-app" class="hidden h-full flex flex-col md:flex-row overflow-hidden">
    <!-- Боковая панель -->
    <aside class="w-full md:w-80 glass-panel flex flex-col h-full z-20 border-r border-[var(--border)]">
        <div class="p-6 flex justify-between items-center border-b border-[var(--border)]">
            <span class="text-2xl font-black text-indigo-500 italic tracking-tighter new-year-logo" id="sidebar-logo">
                FLICKERS
                <div class="garland">
                    <div class="garland-wire"></div>
                    <div class="garland-light"></div>
                    <div class="garland-light"></div>
                    <div class="garland-light"></div>
                    <div class="garland-light"></div>
                    <div class="garland-light"></div>
                    <div class="garland-light"></div>
                    <div class="garland-light"></div>
                </div>
                <div class="logo-snowflakes" id="sidebar-snowflakes"></div>
            </span>
            <button onclick="toggleSettings()" class="w-10 h-10 flex items-center justify-center rounded-xl hover:bg-slate-100 dark:hover:bg-slate-800 transition-colors">
                <i class="fas fa-cog text-xl"></i>
            </button>
        </div>
        <div class="p-4 relative">
            <div class="relative group">
                <i class="fas fa-search absolute left-4 top-1/2 -translate-y-1/2 text-slate-400 group-focus-within:text-indigo-500 transition-colors"></i>
                <input type="text" id="search-input" data-i18n-placeholder="searchNickname" placeholder="Поиск ника..." class="w-full p-3 pl-10 bg-slate-100 dark:bg-slate-800 rounded-xl outline-none text-sm border border-transparent focus:border-indigo-500 transition-all" oninput="doNicknameSearch(this.value)">
            </div>
            <div id="nickname-search-results" class="absolute left-4 right-4 mt-2 glass-panel rounded-xl shadow-2xl z-50 hidden max-h-60 overflow-y-auto animate-panel-pop"></div>
        </div>
        
        <!-- Истории/Статусы -->
        <div id="stories-container" class="stories-container">
            <div class="story-item" onclick="addMyStory()">
                <div class="story-avatar no-story relative">
                    <div class="story-avatar-inner" id="my-story-avatar">
                        <i class="fas fa-plus text-slate-400"></i>
                    </div>
                    <div class="story-add"><i class="fas fa-plus"></i></div>
                </div>
                <span class="story-name" data-i18n="myStory">Моя история</span>
            </div>
        </div>
        
        <div class="flex-1 overflow-y-auto relative">
            <div id="chats-list" class="p-4 space-y-3 pb-16"></div>
            <button onclick="openCreateGroup()" class="absolute bottom-4 right-4 w-12 h-12 rounded-full bg-indigo-500 hover:bg-indigo-600 text-white shadow-lg shadow-indigo-500/30 flex items-center justify-center transition-all hover:scale-110" title="Создать группу">
                <i class="fas fa-plus text-lg"></i>
            </button>
        </div>
        <div class="p-4 border-t border-[var(--border)] flex items-center space-x-3 bg-slate-50/50 dark:bg-slate-900/50">
            <div class="p-1">
                <div id="my-avatar" class="w-12 h-12 rounded-2xl bg-indigo-500 text-white flex items-center justify-center font-bold text-xl shadow-lg shadow-indigo-500/20">?</div>
            </div>
            <div class="flex-1 min-w-0">
                <p class="font-bold text-sm truncate" id="my-name">Загрузка...</p>
                <p class="text-[10px] text-green-500 font-bold uppercase tracking-wider" data-i18n="online">В сети</p>
            </div>
            <div class="rubies-display" onclick="openRubyShop()" title="Магазин рубинов">
                <i class="fas fa-gem"></i>
                <span id="rubies-count">0.00</span>
            </div>
        </div>
    </aside>

    <!-- Окно чата -->
    <main class="flex-1 flex flex-col overflow-hidden relative">
        <div id="chat-placeholder" class="flex-1 flex flex-col items-center justify-center text-slate-400 opacity-20 animate-pulse">
            <i class="fas fa-bolt text-9xl mb-4"></i>
            <p class="font-black uppercase tracking-[0.4em]" data-i18n="selectContact">Выберите контакт</p>
        </div>

        <div id="active-chat" class="hidden flex-1 flex flex-col h-full">
            <header class="p-4 border-b border-[var(--border)] glass-panel flex items-center justify-between z-10">
                <div class="flex items-center space-x-3">
                    <!-- Кнопка назад для мобильных -->
                    <button onclick="mobileGoBack()" class="mobile-back-btn hidden w-10 h-10 rounded-xl hover:bg-slate-100 dark:hover:bg-slate-800 transition-colors items-center justify-center -ml-2">
                        <i class="fas fa-arrow-left"></i>
                    </button>
                    <div class="relative cursor-pointer" oncontextmenu="event.preventDefault(); openPartnerProfile();" onclick="openPartnerProfile();">
                        <div id="target-avatar" class="w-10 h-10 rounded-xl bg-indigo-100 text-indigo-500 flex items-center justify-center font-bold">?</div>
                        <div id="online-indicator" class="absolute -bottom-0.5 -right-0.5 w-3 h-3 bg-gray-400 rounded-full border-2 border-white dark:border-slate-900 hidden"></div>
                    </div>
                    <div>
                        <p id="target-name" class="font-bold">Чат</p>
                        <p id="online-status" class="text-[10px] text-slate-400"></p>
                    </div>
                </div>
                <div class="flex space-x-2">
                    <button onclick="openGiftRubies()" class="w-10 h-10 rounded-xl hover:bg-slate-100 dark:hover:bg-slate-800 transition-colors text-red-500" title="Подарить рубины"><i class="fas fa-gem"></i></button>
                    <button onclick="startCall(false)" class="w-10 h-10 rounded-xl hover:bg-slate-100 dark:hover:bg-slate-800 transition-colors" title="Аудио звонок"><i class="fas fa-phone-alt"></i></button>
                    <button onclick="startCall(true)" class="w-10 h-10 rounded-xl hover:bg-slate-100 dark:hover:bg-slate-800 transition-colors" title="Видео звонок"><i class="fas fa-video"></i></button>
                    <div class="relative">
                        <button onclick="toggleChatMenu()" class="w-10 h-10 rounded-xl hover:bg-slate-100 dark:hover:bg-slate-800 transition-colors"><i class="fas fa-ellipsis-v"></i></button>
                        <div id="chat-menu" class="hidden absolute right-0 top-12 w-56 bg-[var(--bg-primary)] border border-[var(--border)] rounded-2xl shadow-xl overflow-hidden z-50">
                            <button onclick="searchInChat()" class="w-full px-4 py-3 flex items-center gap-3 hover:bg-[var(--bg-secondary)] transition-colors text-left">
                                <i class="fas fa-search text-indigo-500 w-5"></i>
                                <span data-i18n="searchInChat">Поиск в чате</span>
                            </button>
                            <button onclick="showChatMedia()" class="w-full px-4 py-3 flex items-center gap-3 hover:bg-[var(--bg-secondary)] transition-colors text-left">
                                <i class="fas fa-images text-indigo-500 w-5"></i>
                                <span data-i18n="mediaFiles">Медиафайлы</span>
                            </button>
                            <button onclick="toggleBookmarks()" class="w-full px-4 py-3 flex items-center gap-3 hover:bg-[var(--bg-secondary)] transition-colors text-left">
                                <i class="fas fa-bookmark text-yellow-500 w-5"></i>
                                <span data-i18n="bookmarks">Закладки</span>
                            </button>
                            <button onclick="toggleNotes()" class="w-full px-4 py-3 flex items-center gap-3 hover:bg-[var(--bg-secondary)] transition-colors text-left">
                                <i class="fas fa-sticky-note text-orange-500 w-5"></i>
                                <span>Заметки</span>
                            </button>
                            <button onclick="toggleSearchPanel()" class="w-full px-4 py-3 flex items-center gap-3 hover:bg-[var(--bg-secondary)] transition-colors text-left">
                                <i class="fas fa-search-plus text-blue-500 w-5"></i>
                                <span>Расширенный поиск</span>
                            </button>
                            <button onclick="muteChat()" class="w-full px-4 py-3 flex items-center gap-3 hover:bg-[var(--bg-secondary)] transition-colors text-left">
                                <i class="fas fa-bell-slash text-indigo-500 w-5" id="mute-chat-icon"></i>
                                <span data-i18n="muteNotifications" id="mute-chat-text">Отключить уведомления</span>
                            </button>
                            <button onclick="clearChatHistory()" class="w-full px-4 py-3 flex items-center gap-3 hover:bg-[var(--bg-secondary)] transition-colors text-left">
                                <i class="fas fa-broom text-orange-500 w-5"></i>
                                <span data-i18n="clearHistory">Очистить историю</span>
                            </button>
                            <button onclick="blockUser()" class="w-full px-4 py-3 flex items-center gap-3 hover:bg-red-50 dark:hover:bg-red-900/20 transition-colors text-left text-red-500" id="block-user-btn">
                                <i class="fas fa-ban w-5" id="block-user-icon"></i>
                                <span data-i18n="blockUser" id="block-user-text">Заблокировать</span>
                            </button>
                        </div>
                    </div>
                </div>
            </header>

            <!-- Закреплённое сообщение -->
            <div id="pinned-message-bar" class="pinned-message-bar hidden" onclick="scrollToPinnedMessage()">
                <i class="fas fa-thumbtack"></i>
                <div class="pinned-message-content">
                    <div class="pinned-message-label">Закреплённое сообщение</div>
                    <div id="pinned-message-text" class="pinned-message-text"></div>
                </div>
                <button onclick="event.stopPropagation(); unpinMessage()" class="w-8 h-8 rounded-full hover:bg-white/20 flex items-center justify-center transition-colors">
                    <i class="fas fa-times text-sm"></i>
                </button>
            </div>

            <div id="messages-container" class="flex-1 overflow-y-auto p-6 flex flex-col gap-4 bg-[url('https://www.transparenttextures.com/patterns/cubes.png')]"></div>

            <!-- Запрос на общение -->
            <div id="chat-request-banner" class="hidden p-4 bg-gradient-to-r from-indigo-500/10 to-purple-500/10 border-t border-indigo-500/20">
                <div class="flex items-center justify-between max-w-2xl mx-auto">
                    <div class="flex items-center gap-3">
                        <i class="fas fa-user-plus text-indigo-500 text-xl"></i>
                        <div>
                            <p class="font-bold text-sm" data-i18n="chatRequest">Запрос на общение</p>
                            <p class="text-xs opacity-60" data-i18n="chatRequestDesc">Этот пользователь хочет начать с вами чат</p>
                        </div>
                    </div>
                    <div class="flex gap-2">
                        <button onclick="declineChatRequest()" class="px-4 py-2 rounded-xl bg-red-500/10 hover:bg-red-500/20 text-red-500 text-sm font-bold transition-colors">
                            <i class="fas fa-times mr-1"></i>
                            <span data-i18n="declineRequest">Отклонить</span>
                        </button>
                        <button onclick="acceptChatRequest()" class="px-4 py-2 rounded-xl bg-indigo-500 hover:bg-indigo-600 text-white text-sm font-bold transition-colors">
                            <i class="fas fa-check mr-1"></i>
                            <span data-i18n="acceptRequest">Принять</span>
                        </button>
                    </div>
                </div>
            </div>

            <!-- Ожидание принятия запроса -->
            <div id="chat-pending-banner" class="hidden p-4 bg-gradient-to-r from-orange-500/10 to-yellow-500/10 border-t border-orange-500/20">
                <div class="flex items-center justify-center gap-3">
                    <i class="fas fa-clock text-orange-500 animate-pulse"></i>
                    <p class="text-sm" data-i18n="waitingAccept">Ожидание принятия запроса...</p>
                </div>
            </div>

            <footer class="p-4 border-t border-[var(--border)] glass-panel relative z-10">
                <div id="emoji-panel" class="emoji-panel glass-panel">
                    <div class="emoji-tabs" id="emoji-tabs"></div>
                    <div class="emoji-search">
                        <input type="text" id="emoji-search-input" data-i18n-placeholder="searchEmoji" placeholder="Поиск эмодзи...">
                    </div>
                    <div class="emoji-content" id="emoji-content"></div>
                </div>

                <div id="upload-status" class="hidden px-4 py-3 bg-indigo-500/10 rounded-xl mb-4">
                    <div class="flex justify-between items-center mb-1">
                        <span class="text-xs font-bold text-indigo-500 italic">Подготовка файла (250MB макс)...</span>
                        <span id="p-percent" class="text-[10px] font-bold text-indigo-500">0%</span>
                    </div>
                    <div class="progress-bar"><div class="progress-fill" id="p-fill"></div></div>
                </div>

                <!-- Панель ответа на сообщение -->
                <div id="reply-panel" class="reply-panel hidden max-w-5xl mx-auto mb-2 rounded-xl">
                    <i class="fas fa-reply text-indigo-500"></i>
                    <div class="reply-panel-content">
                        <div id="reply-panel-author" class="reply-panel-author"></div>
                        <div id="reply-panel-text" class="reply-panel-text"></div>
                    </div>
                    <button onclick="cancelReply()" class="w-8 h-8 rounded-full hover:bg-slate-200 dark:hover:bg-slate-700 flex items-center justify-center transition-colors">
                        <i class="fas fa-times text-slate-400"></i>
                    </button>
                </div>

                <div class="max-w-5xl mx-auto flex items-center space-x-2">
                    <!-- Плюс-меню -->
                    <div class="plus-menu-container">
                        <button class="plus-menu-btn" id="plus-menu-btn" onclick="togglePlusMenu()">
                            <i class="fas fa-plus"></i>
                        </button>
                        <div class="plus-menu" id="plus-menu">
                            <div class="plus-menu-item file-item" onclick="triggerFile(); togglePlusMenu();">
                                <i class="fas fa-paperclip"></i>
                                <span>Файл</span>
                            </div>
                            <div class="plus-menu-item poll-item" onclick="openPollModal(); togglePlusMenu();">
                                <i class="fas fa-poll"></i>
                                <span>Голосование</span>
                            </div>
                            <div class="plus-menu-item game-item" onclick="inviteToGame(); togglePlusMenu();">
                                <i class="fas fa-gamepad"></i>
                                <span>Крестики-нолики</span>
                            </div>
                            <div class="plus-menu-item ai-item" onclick="toggleAI(); togglePlusMenu();">
                                <i class="fas fa-robot"></i>
                                <span>AI Ассистент</span>
                            </div>
                        </div>
                    </div>
                    <input type="file" id="file-input" class="hidden" onchange="handleFile(this)">

                    <button onclick="toggleEmoji()" class="w-10 h-10 flex items-center justify-center text-slate-400 hover:text-indigo-500 hover:bg-indigo-50 rounded-xl transition-all">
                        <i class="far fa-smile text-lg"></i>
                    </button>
                    
                    <button onclick="toggleStickers()" class="w-10 h-10 flex items-center justify-center text-slate-400 hover:text-pink-500 hover:bg-pink-50 rounded-xl transition-all" title="Стикеры и GIF">
                        <i class="fas fa-sticky-note text-lg"></i>
                    </button>

                    <div class="flex-1 relative" id="input-container">
                        <input type="text" id="msg-input" data-i18n-placeholder="writeMessage" placeholder="Напишите сообщение..." class="w-full bg-slate-100 dark:bg-slate-800 p-4 rounded-2xl outline-none focus:ring-2 focus:ring-indigo-500 transition-all border border-transparent" oninput="if(typeof onTyping==='function')onTyping()">
                        
                        <!-- Панель быстрых ответов -->
                        <div id="quick-replies-panel" class="quick-replies-panel">
                            <div class="quick-reply-item" onclick="useQuickReply('👋 Привет!')">
                                <span class="emoji">👋</span> Привет!
                            </div>
                            <div class="quick-reply-item" onclick="useQuickReply('👍 Хорошо, договорились!')">
                                <span class="emoji">👍</span> Хорошо, договорились!
                            </div>
                            <div class="quick-reply-item" onclick="useQuickReply('⏰ Минутку, скоро отвечу')">
                                <span class="emoji">⏰</span> Минутку, скоро отвечу
                            </div>
                            <div class="quick-reply-item" onclick="useQuickReply('😊 Спасибо!')">
                                <span class="emoji">😊</span> Спасибо!
                            </div>
                            <div class="quick-reply-item" onclick="useQuickReply('🤔 Дай подумать...')">
                                <span class="emoji">🤔</span> Дай подумать...
                            </div>
                            <div class="quick-reply-item" onclick="useQuickReply('👀 Сейчас посмотрю')">
                                <span class="emoji">👀</span> Сейчас посмотрю
                            </div>
                            <div class="quick-reply-item" onclick="useQuickReply('❤️ Люблю тебя!')">
                                <span class="emoji">❤️</span> Люблю тебя!
                            </div>
                            <div class="quick-reply-item" onclick="useQuickReply('😂 Ахахах')">
                                <span class="emoji">😂</span> Ахахах
                            </div>
                        </div>
                        
                        <!-- Панель стикеров и GIF -->
                        <div id="sticker-panel" class="sticker-panel glass-panel">
                            <div class="sticker-tabs">
                                <div class="sticker-tab active" onclick="switchStickerTab('stickers')">🎨 Стикеры</div>
                                <div class="sticker-tab" onclick="switchStickerTab('gif')">🎬 GIF</div>
                            </div>
                            <div class="sticker-search">
                                <input type="text" id="sticker-search-input" placeholder="Поиск..." oninput="searchStickersOrGif(this.value)">
                            </div>
                            <div class="sticker-content" id="sticker-content"></div>
                        </div>
                        
                        <!-- AI панель -->
                        <div id="ai-panel" class="ai-panel hidden">
                            <div class="p-4 border-b border-[var(--border)] flex items-center gap-3">
                                <i class="fas fa-robot text-orange-500 text-xl"></i>
                                <div>
                                    <p class="font-bold text-sm">AI Assistant</p>
                                    <p class="text-[10px] opacity-50">Powered by Groq (Llama)</p>
                                </div>
                            </div>
                            <div id="ai-options">
                                <div class="ai-btn-option" onclick="aiGenerateReply()">
                                    <i class="fas fa-reply"></i>
                                    <span data-i18n="aiGenerateReply">Сгенерировать ответ</span>
                                </div>
                                <div class="ai-btn-option" onclick="aiImproveText()">
                                    <i class="fas fa-magic"></i>
                                    <span data-i18n="aiImproveText">Улучшить текст</span>
                                </div>
                                <div class="ai-btn-option" onclick="aiSummarize()">
                                    <i class="fas fa-compress-alt"></i>
                                    <span data-i18n="aiSummarize">Суммировать разговор</span>
                                </div>
                                <div class="ai-btn-option" onclick="aiTranslate()">
                                    <i class="fas fa-language"></i>
                                    <span data-i18n="aiTranslate">Перевести</span>
                                </div>
                            </div>
                            <div id="ai-loading" class="ai-loading hidden">
                                <i class="fas fa-spinner"></i>
                                <span data-i18n="aiThinking">AI думает...</span>
                            </div>
                            <div id="ai-result" class="ai-result hidden"></div>
                            <div id="ai-result-actions" class="ai-result-actions hidden">
                                <button onclick="aiUseResult()" class="ai-result-btn bg-purple-500 text-white hover:bg-purple-600" data-i18n="aiUse">Использовать</button>
                                <button onclick="aiCopyResult()" class="ai-result-btn bg-slate-200 dark:bg-slate-700 hover:bg-slate-300" data-i18n="aiCopy">Копировать</button>
                            </div>
                        </div>
                        
                        <!-- UI записи голосового -->
                        <div id="voice-recording-ui" class="voice-recording-ui hidden absolute inset-0">
                            <div class="recording-indicator"></div>
                            <div class="voice-waveform">
                                <span></span><span></span><span></span><span></span><span></span>
                            </div>
                            <span id="voice-timer" class="text-sm font-mono font-bold">0:00</span>
                            <button onclick="cancelVoice()" class="ml-auto text-red-500 hover:bg-red-50 w-8 h-8 rounded-full flex items-center justify-center">
                                <i class="fas fa-times"></i>
                            </button>
                        </div>
                    </div>

                    <button onclick="openVideoCircle()" class="video-circle-btn w-12 h-12 flex items-center justify-center text-slate-400 hover:text-purple-500 hover:bg-purple-50 rounded-xl transition-all" title="Видео-кружок">
                        <i class="fas fa-circle text-xl"></i>
                    </button>

                    <button id="voice-btn" onmousedown="startVoice()" onmouseup="stopVoice()" ontouchstart="startVoice()" ontouchend="stopVoice()" class="voice-btn w-12 h-12 flex items-center justify-center text-slate-400 hover:text-indigo-500 hover:bg-indigo-50 rounded-xl transition-all">
                        <i class="fas fa-microphone text-xl"></i>
                    </button>

                    <button onclick="sendMsg()" class="w-14 h-14 bg-indigo-600 text-white rounded-2xl flex items-center justify-center hover:bg-indigo-700 shadow-xl active:scale-90 transition-all">
                        <i class="fas fa-paper-plane text-xl"></i>
                    </button>
                </div>
            </footer>
        </div>
    </main>

    <!-- Панель настроек -->
    <div id="settings-panel" class="fixed inset-y-0 right-0 w-85 max-w-full glass-panel shadow-[-20px_0_50px_rgba(0,0,0,0.1)] z-50 p-8 overflow-y-auto">
        <div class="flex justify-between items-center mb-10">
            <h3 class="text-2xl font-black italic" data-i18n="settings">Настройки</h3>
            <button onclick="toggleSettings()" class="w-10 h-10 flex items-center justify-center rounded-full hover:bg-red-50 hover:text-red-500 transition-all"><i class="fas fa-times text-xl"></i></button>
        </div>
        <div class="space-y-6">
            <!-- Профиль и аватарка -->
            <div>
                <p class="text-[10px] font-bold uppercase text-indigo-500 mb-3 tracking-widest" data-i18n="profile">Профиль</p>
                <div class="flex flex-col items-center p-6 bg-slate-100 dark:bg-slate-800 rounded-2xl">
                    <div class="relative group cursor-pointer p-3" onclick="triggerAvatarUpload()">
                        <div id="settings-avatar" class="w-24 h-24 rounded-full bg-indigo-500 text-white flex items-center justify-center font-bold text-3xl shadow-lg overflow-hidden">
                            ?
                        </div>
                        <div class="absolute inset-0 rounded-full bg-black/50 flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity">
                            <i class="fas fa-camera text-white text-xl"></i>
                        </div>
                    </div>
                    <p id="settings-username" class="mt-3 font-bold">@username</p>
                    <p class="text-xs opacity-50 mt-1" data-i18n="clickToChange">Нажмите на аватар для изменения</p>
                    <input type="file" id="avatar-input" class="hidden" accept="image/*" onchange="handleAvatarUpload(this)">
                    
                    <!-- Описание профиля -->
                    <div class="w-full mt-4">
                        <label class="text-xs opacity-50 mb-1 block" data-i18n="bio">О себе</label>
                        <textarea id="settings-bio" 
                            class="w-full p-3 bg-white dark:bg-slate-700 border border-[var(--border)] rounded-xl text-sm resize-none outline-none focus:ring-2 focus:ring-indigo-500" 
                            rows="2" 
                            maxlength="150" 
                            placeholder="Расскажите о себе..."
                            data-i18n-placeholder="bioPlaceholder"
                            onchange="saveBio()"></textarea>
                        <p class="text-[10px] opacity-40 mt-1 text-right"><span id="bio-counter">0</span>/150</p>
                    </div>
                    
                    <!-- Выбор пола -->
                    <div class="w-full mt-4">
                        <label class="text-xs opacity-50 mb-2 block" data-i18n="gender">Пол</label>
                        <div class="flex gap-2">
                            <button onclick="setGender('male')" id="gender-male" class="flex-1 py-2 px-3 rounded-xl border border-[var(--border)] text-sm font-medium transition-all hover:border-indigo-500">
                                👨 <span data-i18n="male">Мужской</span>
                            </button>
                            <button onclick="setGender('female')" id="gender-female" class="flex-1 py-2 px-3 rounded-xl border border-[var(--border)] text-sm font-medium transition-all hover:border-indigo-500">
                                👩 <span data-i18n="female">Женский</span>
                            </button>
                            <button onclick="setGender('other')" id="gender-other" class="flex-1 py-2 px-3 rounded-xl border border-[var(--border)] text-sm font-medium transition-all hover:border-indigo-500">
                                🤷 <span data-i18n="other">Другой</span>
                            </button>
                        </div>
                    </div>
                    
                    <!-- Скрыть профиль -->
                    <div class="w-full mt-4 flex items-center justify-between p-3 bg-white dark:bg-slate-700 rounded-xl border border-[var(--border)]">
                        <div>
                            <p class="text-sm font-medium" data-i18n="hideProfile">Скрыть профиль</p>
                            <p class="text-[10px] opacity-50" data-i18n="hideProfileDesc">Другие не увидят ваш профиль</p>
                        </div>
                        <label class="relative inline-flex items-center cursor-pointer">
                            <input type="checkbox" id="hide-profile-toggle" class="sr-only peer" onchange="toggleHideProfile()">
                            <div class="w-11 h-6 bg-gray-200 peer-focus:outline-none rounded-full peer dark:bg-gray-700 peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all dark:border-gray-600 peer-checked:bg-indigo-500"></div>
                        </label>
                    </div>
                </div>
            </div>

            <!-- Рамки аватара (за рубины) -->
            <div>
                <p class="text-[10px] font-bold uppercase text-indigo-500 mb-3 tracking-widest">💎 Рамка аватара</p>
                <div class="p-4 bg-slate-100 dark:bg-slate-800 rounded-2xl">
                    <div class="flex items-center justify-between mb-3">
                        <span class="text-xs opacity-60">Ваши рубины:</span>
                        <span class="font-bold text-red-500"><i class="fas fa-gem"></i> <span id="settings-rubies">0.00</span></span>
                    </div>
                    <div class="grid grid-cols-4 gap-2" id="avatar-frames-grid">
                        <button onclick="selectAvatarFrame('none')" class="frame-btn aspect-square rounded-xl border-2 border-[var(--border)] hover:border-indigo-500 transition-all flex items-center justify-center bg-white dark:bg-slate-700 relative" data-frame="none">
                            <div class="w-10 h-10 rounded-full bg-indigo-500"></div>
                            <span class="absolute -bottom-1 text-[8px] bg-green-500 text-white px-1 rounded">FREE</span>
                        </button>
                        <button onclick="selectAvatarFrame('rainbow')" class="frame-btn aspect-square rounded-xl border-2 border-[var(--border)] hover:border-indigo-500 transition-all flex items-center justify-center bg-white dark:bg-slate-700 relative" data-frame="rainbow">
                            <div class="w-10 h-10 rounded-full bg-indigo-500" style="box-shadow: 0 0 0 3px transparent, 0 0 0 5px #f59e0b, 0 0 0 7px #ef4444, 0 0 0 9px #ec4899;"></div>
                            <span class="absolute -bottom-1 text-[8px] bg-red-500 text-white px-1 rounded">50💎</span>
                        </button>
                        <button onclick="selectAvatarFrame('gold')" class="frame-btn aspect-square rounded-xl border-2 border-[var(--border)] hover:border-indigo-500 transition-all flex items-center justify-center bg-white dark:bg-slate-700 relative" data-frame="gold">
                            <div class="w-10 h-10 rounded-full bg-indigo-500" style="box-shadow: 0 0 0 3px #fbbf24, 0 0 10px #fbbf24;"></div>
                            <span class="absolute -bottom-1 text-[8px] bg-yellow-500 text-white px-1 rounded">75💎</span>
                        </button>
                        <button onclick="selectAvatarFrame('neon')" class="frame-btn aspect-square rounded-xl border-2 border-[var(--border)] hover:border-indigo-500 transition-all flex items-center justify-center bg-white dark:bg-slate-700 relative" data-frame="neon">
                            <div class="w-10 h-10 rounded-full bg-indigo-500" style="box-shadow: 0 0 0 2px #22d3ee, 0 0 15px #22d3ee, 0 0 30px #22d3ee;"></div>
                            <span class="absolute -bottom-1 text-[8px] bg-cyan-500 text-white px-1 rounded">100💎</span>
                        </button>
                        <button onclick="selectAvatarFrame('fire')" class="frame-btn aspect-square rounded-xl border-2 border-[var(--border)] hover:border-indigo-500 transition-all flex items-center justify-center bg-white dark:bg-slate-700 relative" data-frame="fire">
                            <div class="w-10 h-10 rounded-full bg-indigo-500" style="box-shadow: 0 0 0 3px #f97316, 0 0 15px #ef4444, 0 0 25px #f97316;"></div>
                            <span class="absolute -bottom-1 text-[8px] bg-orange-500 text-white px-1 rounded">100💎</span>
                        </button>
                        <button onclick="selectAvatarFrame('purple')" class="frame-btn aspect-square rounded-xl border-2 border-[var(--border)] hover:border-indigo-500 transition-all flex items-center justify-center bg-white dark:bg-slate-700 relative" data-frame="purple">
                            <div class="w-10 h-10 rounded-full bg-indigo-500" style="box-shadow: 0 0 0 3px #a855f7, 0 0 15px #a855f7;"></div>
                            <span class="absolute -bottom-1 text-[8px] bg-purple-500 text-white px-1 rounded">75💎</span>
                        </button>
                        <button onclick="selectAvatarFrame('emerald')" class="frame-btn aspect-square rounded-xl border-2 border-[var(--border)] hover:border-indigo-500 transition-all flex items-center justify-center bg-white dark:bg-slate-700 relative" data-frame="emerald">
                            <div class="w-10 h-10 rounded-full bg-indigo-500" style="box-shadow: 0 0 0 3px #10b981, 0 0 15px #10b981;"></div>
                            <span class="absolute -bottom-1 text-[8px] bg-emerald-500 text-white px-1 rounded">75💎</span>
                        </button>
                        <button onclick="selectAvatarFrame('diamond')" class="frame-btn aspect-square rounded-xl border-2 border-[var(--border)] hover:border-indigo-500 transition-all flex items-center justify-center bg-white dark:bg-slate-700 relative" data-frame="diamond">
                            <div class="w-10 h-10 rounded-full bg-indigo-500" style="box-shadow: 0 0 0 2px #fff, 0 0 0 4px #60a5fa, 0 0 20px #60a5fa, inset 0 0 10px rgba(96,165,250,0.3);"></div>
                            <span class="absolute -bottom-1 text-[8px] bg-blue-500 text-white px-1 rounded">150💎</span>
                        </button>
                    </div>
                    <p class="text-[10px] opacity-50 mt-2 text-center">Выбранная рамка: <span id="current-frame-name" class="font-bold">Без рамки</span></p>
                </div>
            </div>

            <!-- Оформление чата (за рубины) -->
            <div>
                <p class="text-[10px] font-bold uppercase text-indigo-500 mb-3 tracking-widest">✨ Оформление сообщений</p>
                <div class="p-4 bg-slate-100 dark:bg-slate-800 rounded-2xl">
                    <div class="space-y-2" id="chat-styles-list">
                        <button onclick="selectChatStyle('default')" class="chat-style-btn w-full p-3 rounded-xl border-2 border-[var(--border)] hover:border-indigo-500 transition-all text-left flex items-center justify-between" data-style="default">
                            <div class="flex items-center gap-3">
                                <div class="w-8 h-8 rounded-lg bg-indigo-500 flex items-center justify-center text-white text-xs">💬</div>
                                <div>
                                    <p class="text-sm font-bold">Стандартное</p>
                                    <p class="text-[10px] opacity-50">Обычные сообщения</p>
                                </div>
                            </div>
                            <span class="text-[10px] bg-green-500 text-white px-2 py-1 rounded">FREE</span>
                        </button>
                        <button onclick="selectChatStyle('gradient')" class="chat-style-btn w-full p-3 rounded-xl border-2 border-[var(--border)] hover:border-indigo-500 transition-all text-left flex items-center justify-between" data-style="gradient">
                            <div class="flex items-center gap-3">
                                <div class="w-8 h-8 rounded-lg flex items-center justify-center text-white text-xs" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);">🌈</div>
                                <div>
                                    <p class="text-sm font-bold">Градиент</p>
                                    <p class="text-[10px] opacity-50">Красивый градиент</p>
                                </div>
                            </div>
                            <span class="text-[10px] bg-red-500 text-white px-2 py-1 rounded">100💎</span>
                        </button>
                        <button onclick="selectChatStyle('neon')" class="chat-style-btn w-full p-3 rounded-xl border-2 border-[var(--border)] hover:border-indigo-500 transition-all text-left flex items-center justify-between" data-style="neon">
                            <div class="flex items-center gap-3">
                                <div class="w-8 h-8 rounded-lg bg-slate-900 flex items-center justify-center text-cyan-400 text-xs" style="box-shadow: 0 0 10px #22d3ee;">⚡</div>
                                <div>
                                    <p class="text-sm font-bold">Неон</p>
                                    <p class="text-[10px] opacity-50">Светящиеся сообщения</p>
                                </div>
                            </div>
                            <span class="text-[10px] bg-cyan-500 text-white px-2 py-1 rounded">150💎</span>
                        </button>
                        <button onclick="selectChatStyle('glass')" class="chat-style-btn w-full p-3 rounded-xl border-2 border-[var(--border)] hover:border-indigo-500 transition-all text-left flex items-center justify-between" data-style="glass">
                            <div class="flex items-center gap-3">
                                <div class="w-8 h-8 rounded-lg flex items-center justify-center text-white text-xs" style="background: rgba(255,255,255,0.2); backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.3);">💎</div>
                                <div>
                                    <p class="text-sm font-bold">Стекло</p>
                                    <p class="text-[10px] opacity-50">Прозрачный эффект</p>
                                </div>
                            </div>
                            <span class="text-[10px] bg-blue-500 text-white px-2 py-1 rounded">200💎</span>
                        </button>
                    </div>
                    <p class="text-[10px] opacity-50 mt-2 text-center">Выбрано: <span id="current-style-name" class="font-bold">Стандартное</span></p>
                </div>
            </div>

            <div>
                <p class="text-[10px] font-bold uppercase text-indigo-500 mb-3 tracking-widest" data-i18n="dataTransfer">Передача данных</p>
                <div class="p-4 bg-slate-100 dark:bg-slate-800 rounded-2xl text-xs space-y-2">
                    <div class="flex justify-between"><span data-i18n="fileLimit">Лимит файла:</span> <span class="font-bold text-indigo-500">250 MB</span></div>
                    <div class="opacity-50 leading-relaxed pt-2 border-t border-[var(--border)]" data-i18n="dbNote">Примечание: База данных ограничивает размер одного сообщения до 1МБ.</div>
                </div>
            </div>
            
            <div>
                <p class="text-[10px] font-bold uppercase text-indigo-500 mb-3 tracking-widest" data-i18n="interface">Интерфейс</p>
                <div class="grid grid-cols-1 gap-2">
                    <button onclick="setTheme('light')" class="flex items-center space-x-3 p-4 rounded-2xl border border-[var(--border)] hover:bg-white transition-all">
                        <span class="w-6 h-6 flex items-center justify-center bg-yellow-400 text-white rounded-lg text-xs">☀️</span>
                        <span class="font-medium" data-i18n="lightTheme">Светлая тема</span>
                    </button>
                    <button onclick="setTheme('dark')" class="flex items-center space-x-3 p-4 rounded-2xl border border-[var(--border)] hover:bg-slate-800 transition-all">
                        <span class="w-6 h-6 flex items-center justify-center bg-slate-700 text-white rounded-lg text-xs">🌙</span>
                        <span class="font-medium" data-i18n="darkTheme">Темная тема</span>
                    </button>
                    <button onclick="setTheme('cosmic')" class="flex items-center space-x-3 p-4 rounded-2xl border border-indigo-500 bg-indigo-500/10 hover:bg-indigo-500/20 transition-all">
                        <span class="w-6 h-6 flex items-center justify-center bg-indigo-900 text-white rounded-lg text-xs">🚀</span>
                        <span class="font-medium" data-i18n="cosmicTheme">Космическая</span>
                    </button>
                </div>
            </div>

            <!-- Обои чата -->
            <div>
                <p class="text-[10px] font-bold uppercase text-indigo-500 mb-3 tracking-widest">🎨 <span data-i18n="chatWallpaper">Обои чата</span></p>
                <div class="grid grid-cols-4 gap-2 mb-3" id="wallpaper-grid">
                    <button onclick="setWallpaper('none')" class="wallpaper-btn aspect-square rounded-xl border-2 border-[var(--border)] hover:border-indigo-500 transition-all flex items-center justify-center bg-[var(--bg-secondary)]" data-wallpaper="none">
                        <i class="fas fa-ban text-slate-400"></i>
                    </button>
                    <button onclick="setWallpaper('dots')" class="wallpaper-btn aspect-square rounded-xl border-2 border-[var(--border)] hover:border-indigo-500 transition-all overflow-hidden" data-wallpaper="dots" style="background: radial-gradient(circle, rgba(99,102,241,0.15) 1px, transparent 1px); background-size: 10px 10px;"></button>
                    <button onclick="setWallpaper('grid')" class="wallpaper-btn aspect-square rounded-xl border-2 border-[var(--border)] hover:border-indigo-500 transition-all overflow-hidden" data-wallpaper="grid" style="background-image: linear-gradient(rgba(99,102,241,0.1) 1px, transparent 1px), linear-gradient(90deg, rgba(99,102,241,0.1) 1px, transparent 1px); background-size: 15px 15px;"></button>
                    <button onclick="setWallpaper('diagonal')" class="wallpaper-btn aspect-square rounded-xl border-2 border-[var(--border)] hover:border-indigo-500 transition-all overflow-hidden" data-wallpaper="diagonal" style="background: repeating-linear-gradient(45deg, transparent, transparent 10px, rgba(99,102,241,0.08) 10px, rgba(99,102,241,0.08) 20px);"></button>
                    <button onclick="setWallpaper('waves')" class="wallpaper-btn aspect-square rounded-xl border-2 border-[var(--border)] hover:border-indigo-500 transition-all overflow-hidden" data-wallpaper="waves" style="background: repeating-linear-gradient(90deg, transparent, transparent 20px, rgba(99,102,241,0.05) 20px, rgba(99,102,241,0.1) 40px);"></button>
                    <button onclick="setWallpaper('circles')" class="wallpaper-btn aspect-square rounded-xl border-2 border-[var(--border)] hover:border-indigo-500 transition-all overflow-hidden" data-wallpaper="circles" style="background: radial-gradient(circle at 50% 50%, transparent 20px, rgba(99,102,241,0.05) 21px, rgba(99,102,241,0.05) 22px, transparent 23px); background-size: 50px 50px;"></button>
                    <button onclick="setWallpaper('triangles')" class="wallpaper-btn aspect-square rounded-xl border-2 border-[var(--border)] hover:border-indigo-500 transition-all overflow-hidden" data-wallpaper="triangles" style="background: linear-gradient(135deg, rgba(99,102,241,0.1) 25%, transparent 25%), linear-gradient(225deg, rgba(99,102,241,0.1) 25%, transparent 25%); background-size: 20px 20px;"></button>
                    <button onclick="setWallpaper('custom')" class="wallpaper-btn aspect-square rounded-xl border-2 border-[var(--border)] hover:border-indigo-500 transition-all flex items-center justify-center bg-[var(--bg-secondary)]" data-wallpaper="custom">
                        <i class="fas fa-image text-indigo-500"></i>
                    </button>
                </div>
                <input type="file" id="custom-wallpaper-input" accept="image/*" class="hidden" onchange="handleCustomWallpaper(event)">
            </div>

            <!-- Новогоднее оформление -->
            <div>
                <p class="text-[10px] font-bold uppercase text-indigo-500 mb-3 tracking-widest">🎄 <span data-i18n="newYearDecor">Новогоднее оформление</span></p>
                <div class="privacy-toggle">
                    <label>
                        <i class="fas fa-snowflake text-blue-400"></i>
                        <span data-i18n="showNewYearDecor">Гирлянда и снежинки</span>
                    </label>
                    <div id="toggle-newyear" class="toggle-switch active" onclick="toggleNewYearDecor()"></div>
                </div>
            </div>

            <!-- Язык -->
            <div>
                <p class="text-[10px] font-bold uppercase text-indigo-500 mb-3 tracking-widest">🌐 <span data-i18n="language">Язык</span></p>
                <div class="grid grid-cols-2 gap-2">
                    <button onclick="setLanguage('ru')" class="lang-btn flex items-center justify-center space-x-2 p-4 rounded-2xl border border-[var(--border)] hover:bg-indigo-50 transition-all" data-lang="ru">
                        <span>🇷🇺</span>
                        <span class="font-medium">Русский</span>
                    </button>
                    <button onclick="setLanguage('en')" class="lang-btn flex items-center justify-center space-x-2 p-4 rounded-2xl border border-[var(--border)] hover:bg-indigo-50 transition-all" data-lang="en">
                        <span>🇬🇧</span>
                        <span class="font-medium">English</span>
                    </button>
                </div>
            </div>

            <!-- Приватность и безопасность -->
            <div>
                <p class="text-[10px] font-bold uppercase text-indigo-500 mb-3 tracking-widest">🔒 <span data-i18n="privacy">Приватность</span></p>
                <div class="space-y-2">
                    <div class="privacy-toggle">
                        <label>
                            <i class="fas fa-user-secret text-indigo-500"></i>
                            <span data-i18n="anonymousMode">Анонимный режим</span>
                        </label>
                        <div id="toggle-anonymous" class="toggle-switch" onclick="togglePrivacy('anonymous')"></div>
                    </div>
                    <div class="privacy-toggle">
                        <label>
                            <i class="fas fa-eye-slash text-indigo-500"></i>
                            <span data-i18n="hideOnlineStatus">Скрыть статус онлайн</span>
                        </label>
                        <div id="toggle-hide-online" class="toggle-switch" onclick="togglePrivacy('hideOnline')"></div>
                    </div>
                    <div class="privacy-toggle">
                        <label>
                            <i class="fas fa-lock text-indigo-500"></i>
                            <span data-i18n="e2eEncryption">Шифрование E2E</span>
                        </label>
                        <div id="toggle-encryption" class="toggle-switch active" onclick="togglePrivacy('encryption')"></div>
                    </div>
                    <div class="privacy-toggle">
                        <label>
                            <i class="fas fa-ban text-indigo-500"></i>
                            <span data-i18n="blockScreenshots">Блок. скриншоты</span>
                        </label>
                        <div id="toggle-block-screenshots" class="toggle-switch" onclick="togglePrivacy('blockScreenshots')"></div>
                    </div>
                    <div class="privacy-toggle">
                        <label>
                            <i class="fas fa-bell text-indigo-500"></i>
                            <span data-i18n="enableNotifications">Включить уведомления</span>
                        </label>
                        <div id="toggle-notifications" class="toggle-switch active" onclick="togglePrivacy('notifications')"></div>
                    </div>
                </div>
                <p class="text-[10px] opacity-50 mt-3 leading-relaxed">
                    <i class="fas fa-shield-alt mr-1"></i>
                    <span data-i18n="privacyNote">Все сообщения шифруются локально перед отправкой. Никто, включая сервер, не может прочитать ваши сообщения.</span>
                </p>
            </div>

            <!-- Самоуничтожающиеся сообщения -->
            <div>
                <p class="text-[10px] font-bold uppercase text-indigo-500 mb-3 tracking-widest">⏱️ <span data-i18n="autoDelete">Автоудаление</span></p>
                <div class="grid grid-cols-4 gap-2">
                    <button onclick="setAutoDestruct(0)" id="destruct-off" class="destruct-btn p-3 rounded-xl border border-[var(--border)] text-xs font-bold hover:bg-indigo-50 transition-all active" data-i18n="off">Выкл</button>
                    <button onclick="setAutoDestruct(30)" id="destruct-30" class="destruct-btn p-3 rounded-xl border border-[var(--border)] text-xs font-bold hover:bg-indigo-50 transition-all">30s</button>
                    <button onclick="setAutoDestruct(300)" id="destruct-300" class="destruct-btn p-3 rounded-xl border border-[var(--border)] text-xs font-bold hover:bg-indigo-50 transition-all">5m</button>
                    <button onclick="setAutoDestruct(3600)" id="destruct-3600" class="destruct-btn p-3 rounded-xl border border-[var(--border)] text-xs font-bold hover:bg-indigo-50 transition-all">1h</button>
                </div>
                <p class="text-[10px] opacity-50 mt-2" data-i18n="autoDeleteNote">Сообщения автоматически удалятся после прочтения</p>
            </div>

            <div class="pt-6 space-y-2">
                <button onclick="checkForUpdates()" class="w-full p-4 text-center text-indigo-500 font-bold bg-indigo-50 dark:bg-indigo-500/10 rounded-2xl active:scale-95 transition-all">
                    <i class="fas fa-download mr-2"></i> <span data-i18n="checkUpdates">Проверить обновления</span>
                </button>
                <button onclick="handleLogout()" class="w-full p-4 text-center text-red-500 font-bold bg-red-50 dark:bg-red-500/10 rounded-2xl active:scale-95 transition-all">
                    <i class="fas fa-sign-out-alt mr-2"></i> <span data-i18n="logout">Выйти из аккаунта</span>
                </button>
                <button onclick="openAdminPanel()" class="w-full p-4 text-center text-slate-400 font-bold hover:text-slate-600 rounded-2xl active:scale-95 transition-all text-xs mt-4">
                    <i class="fas fa-shield-alt mr-2"></i> Admin
                </button>
            </div>
        </div>
    </div>

    <!-- Админ-панель -->
    <div id="admin-panel" class="fixed inset-0 z-[100] bg-black/50 backdrop-blur-sm hidden flex items-center justify-center p-4">
        <div class="bg-white dark:bg-slate-800 rounded-3xl shadow-2xl w-full max-w-4xl max-h-[80vh] overflow-hidden flex">
            <!-- Основная часть админки -->
            <div class="flex-1 flex flex-col">
                <!-- Заголовок -->
                <div class="p-6 border-b border-slate-200 dark:border-slate-700 flex justify-between items-center bg-red-500 text-white">
                    <div class="flex items-center gap-3">
                        <i class="fas fa-shield-alt text-2xl"></i>
                        <div>
                            <h3 class="text-xl font-black" data-i18n="adminPanel">Админ панель</h3>
                            <p class="text-xs opacity-80">Мониторинг пользователей</p>
                        </div>
                    </div>
                    <button onclick="closeAdminPanel()" class="w-10 h-10 flex items-center justify-center rounded-full hover:bg-white/20 transition-all">
                        <i class="fas fa-times text-xl"></i>
                    </button>
                </div>
                
                <!-- Форма входа в админку -->
                <div id="admin-login" class="p-8 text-center">
                    <i class="fas fa-lock text-5xl text-slate-300 mb-4"></i>
                    <p class="text-slate-500 mb-6" data-i18n="enterAdminPassword">Введите пароль администратора</p>
                    <div class="relative w-full max-w-xs mx-auto mb-4">
                        <input type="password" id="admin-password" data-i18n-placeholder="password" placeholder="Пароль" class="w-full p-4 bg-slate-100 dark:bg-slate-700 rounded-2xl outline-none focus:ring-2 focus:ring-red-500 transition-all text-center">
                        <div id="admin-code-hint" class="hidden mt-2 p-2 bg-green-100 dark:bg-green-900/30 border border-green-300 dark:border-green-700 rounded-xl">
                            <p class="text-xs text-green-600 dark:text-green-400"><i class="fas fa-key mr-1"></i> Код: <span id="admin-code-value" class="font-bold select-all"></span></p>
                        </div>
                    </div>
                    <p id="admin-error" class="text-red-500 text-sm mb-4 hidden" data-i18n="wrongAdminPassword">Неверный пароль</p>
                    <button onclick="adminLogin()" class="px-8 py-3 bg-red-500 text-white font-bold rounded-2xl hover:bg-red-600 transition-all">
                        <i class="fas fa-unlock mr-2"></i> <span data-i18n="access">Войти</span>
                    </button>
                </div>
                
                <!-- Содержимое админки -->
                <div id="admin-content" class="hidden flex-1 overflow-hidden flex flex-col">
                    <div class="p-4 border-b border-slate-200 dark:border-slate-700">
                        <div class="relative">
                            <i class="fas fa-search absolute left-4 top-1/2 -translate-y-1/2 text-slate-400"></i>
                            <input type="text" id="admin-search" data-i18n-placeholder="searchUsers" placeholder="Поиск пользователей..." class="w-full p-3 pl-10 bg-slate-100 dark:bg-slate-700 rounded-xl outline-none text-sm" oninput="filterAdminUsers()">
                        </div>
                    </div>
                    <div id="admin-users-list" class="flex-1 overflow-y-auto p-4 space-y-2"></div>
                    <div class="p-4 border-t border-slate-200 dark:border-slate-700 text-center text-xs text-slate-400">
                        <span id="admin-users-count">0 онлайн / 0</span> пользователей
                    </div>
                </div>
            </div>
            
            <!-- Боковая панель создателя (скрыта по умолчанию) -->
            <div id="creator-sidebar" class="hidden w-72 border-l border-slate-200 dark:border-slate-700 bg-gradient-to-b from-yellow-50 to-orange-50 dark:from-yellow-900/20 dark:to-orange-900/20 flex-col" style="display: none;">
                <div class="p-4 bg-gradient-to-r from-yellow-400 to-orange-400 text-yellow-900">
                    <div class="flex items-center gap-2 mb-1">
                        <i class="fas fa-crown"></i>
                        <span class="font-black">Панель создателя</span>
                    </div>
                    <p class="text-xs opacity-80">Рубины и управление</p>
                </div>
                
                <div class="p-4 flex-1 overflow-y-auto">
                    <div class="mb-4 relative">
                        <label class="text-xs font-bold text-slate-500 mb-2 block">Выберите пользователя</label>
                        <div class="relative">
                            <i class="fas fa-search absolute left-3 top-1/2 -translate-y-1/2 text-slate-400 text-xs"></i>
                            <input type="text" id="creator-user-search" placeholder="Поиск по нику..." class="w-full p-3 pl-9 bg-white dark:bg-slate-800 border border-slate-200 dark:border-slate-700 rounded-xl outline-none focus:ring-2 focus:ring-yellow-500 text-sm" oninput="searchCreatorUsers(this.value)">
                        </div>
                        <div id="creator-user-results" class="absolute left-0 right-0 mt-1 bg-white dark:bg-slate-800 border border-slate-200 dark:border-slate-700 rounded-xl shadow-lg max-h-40 overflow-y-auto z-10 hidden"></div>
                    </div>
                    
                    <div id="creator-selected-user-container" class="mb-4 hidden">
                        <label class="text-xs font-bold text-slate-500 mb-2 block">Выбран</label>
                        <div id="creator-selected-user" class="p-3 bg-white dark:bg-slate-800 rounded-xl border-2 border-yellow-400 text-sm"></div>
                    </div>
                    
                    <div class="mb-4">
                        <label class="text-xs font-bold text-slate-500 mb-2 block">Текущий баланс</label>
                        <div class="text-2xl font-black text-red-500 flex items-center gap-2">
                            <i class="fas fa-gem"></i>
                            <span id="creator-user-rubies">0.00</span>
                        </div>
                    </div>
                    
                    <div class="mb-4">
                        <label class="text-xs font-bold text-slate-500 mb-2 block">Добавить рубины</label>
                        <input type="number" id="creator-add-amount" placeholder="Количество" class="w-full p-3 bg-white dark:bg-slate-800 border border-slate-200 dark:border-slate-700 rounded-xl outline-none focus:ring-2 focus:ring-yellow-500 text-sm">
                    </div>
                    
                    <button onclick="creatorAddRubiesToUser()" class="w-full p-3 bg-gradient-to-r from-yellow-400 to-orange-400 text-yellow-900 font-bold rounded-xl hover:from-yellow-500 hover:to-orange-500 transition-all text-sm">
                        <i class="fas fa-plus mr-2"></i> Добавить
                    </button>
                    
                    <div class="mt-4">
                        <label class="text-xs font-bold text-slate-500 mb-2 block">Быстрые действия</label>
                        <div class="grid grid-cols-2 gap-2">
                            <button onclick="creatorQuickAdd(10)" class="p-2 bg-white dark:bg-slate-800 border border-slate-200 dark:border-slate-700 rounded-lg text-xs font-bold hover:border-yellow-400 transition-all">+10 💎</button>
                            <button onclick="creatorQuickAdd(50)" class="p-2 bg-white dark:bg-slate-800 border border-slate-200 dark:border-slate-700 rounded-lg text-xs font-bold hover:border-yellow-400 transition-all">+50 💎</button>
                            <button onclick="creatorQuickAdd(100)" class="p-2 bg-white dark:bg-slate-800 border border-slate-200 dark:border-slate-700 rounded-lg text-xs font-bold hover:border-yellow-400 transition-all">+100 💎</button>
                            <button onclick="creatorQuickAdd(1000)" class="p-2 bg-white dark:bg-slate-800 border border-slate-200 dark:border-slate-700 rounded-lg text-xs font-bold hover:border-yellow-400 transition-all">+1000 💎</button>
                        </div>
                    </div>
                    
                    <div class="mt-4 pt-4 border-t border-slate-200 dark:border-slate-700">
                        <label class="text-xs font-bold text-slate-500 mb-2 block">Очистка данных</label>
                        <button onclick="cleanDeletedUsersStories()" class="w-full p-2 bg-red-100 dark:bg-red-900/30 text-red-600 dark:text-red-400 border border-red-200 dark:border-red-800 rounded-lg text-xs font-bold hover:bg-red-200 dark:hover:bg-red-900/50 transition-all">
                            <i class="fas fa-trash-alt mr-1"></i> Удалить статусы удалённых
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Модальное окно подарка -->
<div id="gift-rubies-modal" class="fixed inset-0 z-[200] bg-black/60 backdrop-blur-sm hidden flex items-center justify-center p-4" onclick="if(event.target === this) closeGiftRubies()">
    <div class="bg-white dark:bg-slate-800 rounded-3xl shadow-2xl w-full max-w-md overflow-hidden animate-panel-pop max-h-[90vh] flex flex-col">
        <div class="p-5 bg-gradient-to-r from-pink-500 via-red-500 to-orange-500 text-white text-center flex-shrink-0">
            <div class="w-16 h-16 mx-auto mb-2 bg-white/20 rounded-full flex items-center justify-center">
                <span id="gift-preview-icon" class="text-4xl">🎁</span>
            </div>
            <h3 class="text-lg font-black">Отправить подарок</h3>
            <p class="text-xs opacity-80">для <span id="gift-recipient-name" class="font-bold">@user</span></p>
        </div>
        <div class="p-4 overflow-y-auto flex-1">
            <div class="flex items-center justify-between mb-3 p-2 bg-slate-100 dark:bg-slate-700 rounded-xl text-sm">
                <span class="opacity-60">Баланс:</span>
                <span class="font-bold text-red-500"><i class="fas fa-gem"></i> <span id="gift-my-balance">0.00</span></span>
            </div>
            
            <label class="text-[10px] font-bold text-slate-500 mb-2 block uppercase tracking-wider">Выберите подарок</label>
            <div class="grid grid-cols-4 gap-2 mb-3" id="gifts-grid">
                <!-- Заполняется динамически -->
            </div>
            
            <div class="p-3 bg-pink-50 dark:bg-pink-900/20 rounded-xl mb-3 text-center">
                <p class="text-xs opacity-60 mb-1">Выбрано:</p>
                <div class="flex items-center justify-center gap-2">
                    <span id="gift-selected-icon" class="w-8 h-8"></span>
                    <span class="font-bold"><span id="gift-selected-name">Подарок</span> — <span id="gift-selected-price" class="text-red-500">100💎</span></span>
                </div>
            </div>
            
            <label class="text-[10px] font-bold text-slate-500 mb-1 block uppercase tracking-wider">Сообщение</label>
            <input type="text" id="gift-message" maxlength="100" placeholder="От всего сердца! 💕" class="w-full p-3 bg-slate-100 dark:bg-slate-700 rounded-xl outline-none focus:ring-2 focus:ring-pink-500 text-sm mb-3">
            
            <div class="flex gap-2">
                <button onclick="closeGiftRubies()" class="flex-1 p-3 bg-slate-200 dark:bg-slate-600 rounded-xl font-bold hover:bg-slate-300 dark:hover:bg-slate-500 transition-all text-sm">
                    Отмена
                </button>
                <button onclick="sendGiftRubies()" class="flex-1 p-3 bg-gradient-to-r from-pink-500 to-red-500 text-white rounded-xl font-bold hover:from-pink-600 hover:to-red-600 transition-all text-sm">
                    <i class="fas fa-paper-plane mr-1"></i>Отправить
                </button>
            </div>
        </div>
    </div>
</div>

<!-- Магазин рубинов -->
<div id="ruby-shop-modal" class="ruby-shop-modal" style="display: none;" onclick="if(event.target === this) closeRubyShop()">
    <div class="ruby-shop-content">
        <div class="ruby-shop-header">
            <button onclick="closeRubyShop()" class="absolute top-4 right-4 w-10 h-10 flex items-center justify-center rounded-full hover:bg-white/20 transition-all">
                <i class="fas fa-times text-xl"></i>
            </button>
            <h3><i class="fas fa-gem"></i> Магазин рубинов</h3>
            <p class="text-sm opacity-80 mb-4">Трать рубины на крутые штуки!</p>
            <div class="ruby-shop-balance">
                <i class="fas fa-gem"></i>
                <span id="shop-rubies-count">0.00</span>
            </div>
        </div>
        <div class="ruby-shop-body">
            <!-- Рамки аватара -->
            <div class="ruby-shop-category">
                <div class="ruby-shop-category-title">
                    <i class="fas fa-circle-notch"></i> Рамки аватара
                </div>
                <div id="shop-frames-list">
                    <div class="ruby-shop-item" data-item="frame-rainbow">
                        <div class="ruby-shop-item-icon" style="background: linear-gradient(45deg, #f59e0b, #ef4444, #ec4899, #8b5cf6); border-radius: 50%;">
                            <div style="width: 30px; height: 30px; background: #6366f1; border-radius: 50%; margin: 5px;"></div>
                        </div>
                        <div class="ruby-shop-item-info">
                            <div class="ruby-shop-item-name">🌈 Радужная рамка</div>
                            <div class="ruby-shop-item-desc">Анимированная радужная рамка с переливами</div>
                        </div>
                        <div class="ruby-shop-item-price" onclick="buyFrameFromShop('rainbow', 50)">
                            <i class="fas fa-gem"></i> 50
                        </div>
                    </div>
                    <div class="ruby-shop-item" data-item="frame-gold">
                        <div class="ruby-shop-item-icon" style="background: #fbbf24; box-shadow: 0 0 15px #fbbf24; border-radius: 50%;">
                            <div style="width: 30px; height: 30px; background: #6366f1; border-radius: 50%; margin: 5px;"></div>
                        </div>
                        <div class="ruby-shop-item-info">
                            <div class="ruby-shop-item-name">👑 Золотая рамка</div>
                            <div class="ruby-shop-item-desc">Сияющая золотая рамка для VIP</div>
                        </div>
                        <div class="ruby-shop-item-price" onclick="buyFrameFromShop('gold', 75)">
                            <i class="fas fa-gem"></i> 75
                        </div>
                    </div>
                    <div class="ruby-shop-item" data-item="frame-neon">
                        <div class="ruby-shop-item-icon" style="background: #0f172a; box-shadow: 0 0 15px #22d3ee, 0 0 30px #22d3ee; border-radius: 50%;">
                            <div style="width: 30px; height: 30px; background: #22d3ee; border-radius: 50%; margin: 5px;"></div>
                        </div>
                        <div class="ruby-shop-item-info">
                            <div class="ruby-shop-item-name">⚡ Неоновая рамка</div>
                            <div class="ruby-shop-item-desc">Пульсирующее неоновое свечение</div>
                        </div>
                        <div class="ruby-shop-item-price" onclick="buyFrameFromShop('neon', 100)">
                            <i class="fas fa-gem"></i> 100
                        </div>
                    </div>
                    <div class="ruby-shop-item" data-item="frame-fire">
                        <div class="ruby-shop-item-icon" style="background: linear-gradient(45deg, #f97316, #ef4444); box-shadow: 0 0 15px #ef4444; border-radius: 50%;">
                            <div style="width: 30px; height: 30px; background: #6366f1; border-radius: 50%; margin: 5px;"></div>
                        </div>
                        <div class="ruby-shop-item-info">
                            <div class="ruby-shop-item-name">🔥 Огненная рамка</div>
                            <div class="ruby-shop-item-desc">Мерцающее пламя вокруг аватара</div>
                        </div>
                        <div class="ruby-shop-item-price" onclick="buyFrameFromShop('fire', 100)">
                            <i class="fas fa-gem"></i> 100
                        </div>
                    </div>
                    <div class="ruby-shop-item" data-item="frame-purple">
                        <div class="ruby-shop-item-icon" style="background: #a855f7; box-shadow: 0 0 15px #a855f7; border-radius: 50%;">
                            <div style="width: 30px; height: 30px; background: #6366f1; border-radius: 50%; margin: 5px;"></div>
                        </div>
                        <div class="ruby-shop-item-info">
                            <div class="ruby-shop-item-name">💜 Фиолетовая рамка</div>
                            <div class="ruby-shop-item-desc">Магическое фиолетовое свечение</div>
                        </div>
                        <div class="ruby-shop-item-price" onclick="buyFrameFromShop('purple', 75)">
                            <i class="fas fa-gem"></i> 75
                        </div>
                    </div>
                    <div class="ruby-shop-item" data-item="frame-emerald">
                        <div class="ruby-shop-item-icon" style="background: #10b981; box-shadow: 0 0 15px #10b981; border-radius: 50%;">
                            <div style="width: 30px; height: 30px; background: #6366f1; border-radius: 50%; margin: 5px;"></div>
                        </div>
                        <div class="ruby-shop-item-info">
                            <div class="ruby-shop-item-name">💚 Изумрудная рамка</div>
                            <div class="ruby-shop-item-desc">Благородное изумрудное сияние</div>
                        </div>
                        <div class="ruby-shop-item-price" onclick="buyFrameFromShop('emerald', 75)">
                            <i class="fas fa-gem"></i> 75
                        </div>
                    </div>
                    <div class="ruby-shop-item" data-item="frame-diamond">
                        <div class="ruby-shop-item-icon" style="background: linear-gradient(135deg, #60a5fa, #93c5fd, #fff); box-shadow: 0 0 20px #60a5fa; border-radius: 50%;">
                            <div style="width: 30px; height: 30px; background: #6366f1; border-radius: 50%; margin: 5px;"></div>
                        </div>
                        <div class="ruby-shop-item-info">
                            <div class="ruby-shop-item-name">💎 Бриллиантовая рамка</div>
                            <div class="ruby-shop-item-desc">Роскошная сверкающая рамка</div>
                        </div>
                        <div class="ruby-shop-item-price" onclick="buyFrameFromShop('diamond', 150)">
                            <i class="fas fa-gem"></i> 150
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Стили сообщений -->
            <div class="ruby-shop-category">
                <div class="ruby-shop-category-title">
                    <i class="fas fa-comment-dots"></i> Стили сообщений
                </div>
                <div id="shop-styles-list">
                    <div class="ruby-shop-item" data-item="style-gradient">
                        <div class="ruby-shop-item-icon" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 12px;">🌈</div>
                        <div class="ruby-shop-item-info">
                            <div class="ruby-shop-item-name">Градиент</div>
                            <div class="ruby-shop-item-desc">Красивые градиентные сообщения</div>
                        </div>
                        <div class="ruby-shop-item-price" onclick="buyStyleFromShop('gradient', 100)">
                            <i class="fas fa-gem"></i> 100
                        </div>
                    </div>
                    <div class="ruby-shop-item" data-item="style-neon">
                        <div class="ruby-shop-item-icon" style="background: #0f172a; color: #22d3ee; box-shadow: 0 0 10px #22d3ee; border-radius: 12px; display: flex; align-items: center; justify-content: center;">⚡</div>
                        <div class="ruby-shop-item-info">
                            <div class="ruby-shop-item-name">Неон</div>
                            <div class="ruby-shop-item-desc">Светящиеся неоновые сообщения</div>
                        </div>
                        <div class="ruby-shop-item-price" onclick="buyStyleFromShop('neon', 150)">
                            <i class="fas fa-gem"></i> 150
                        </div>
                    </div>
                    <div class="ruby-shop-item" data-item="style-glass">
                        <div class="ruby-shop-item-icon" style="background: rgba(255,255,255,0.2); backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.3); border-radius: 12px;">💎</div>
                        <div class="ruby-shop-item-info">
                            <div class="ruby-shop-item-name">Стекло</div>
                            <div class="ruby-shop-item-desc">Прозрачный стеклянный эффект</div>
                        </div>
                        <div class="ruby-shop-item-price" onclick="buyStyleFromShop('glass', 200)">
                            <i class="fas fa-gem"></i> 200
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Секретные коды -->
            <div class="ruby-shop-category">
                <div class="ruby-shop-category-title">
                    <i class="fas fa-key"></i> Секретные коды
                </div>
                <div class="ruby-shop-item" data-item="admin-code">
                    <div class="ruby-shop-item-icon" style="background: linear-gradient(135deg, #ef4444, #dc2626);">🔐</div>
                    <div class="ruby-shop-item-info">
                        <div class="ruby-shop-item-name">Код админ-панели</div>
                        <div class="ruby-shop-item-desc">Узнай секретный пароль администратора</div>
                    </div>
                    <div class="ruby-shop-item-price" onclick="buyShopItem('admin-code', 1000)">
                        <i class="fas fa-gem"></i> 1000
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
// Глобальная функция поиска - определяется до модуля
window.doNicknameSearch = function(val) {
    if (window.handleNicknameSearch) {
        window.handleNicknameSearch(val);
    } else {
        console.log('handleNicknameSearch not ready yet');
    }
};
</script>

<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { getFirestore, doc, setDoc, getDoc, getDocs, updateDoc, deleteDoc, collection, query, onSnapshot, addDoc, serverTimestamp, orderBy, limit, where } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
    import { getStorage, ref, uploadBytes, getDownloadURL } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-storage.js";

    const firebaseConfig = {
        apiKey: "AIzaSyDkFjU_6XIp7P4DuaYNfvYPcrXimmvtmgg",
        authDomain: "govno-kakoeto-messanger.firebaseapp.com",
        projectId: "govno-kakoeto-messanger",
        storageBucket: "govno-kakoeto-messanger.firebasestorage.app",
        messagingSenderId: "216784452110",
        appId: "1:216784452110:web:c32cee25d38e49bc449a5f"
    };
    
    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);
    const storage = getStorage(app);
    const appId = typeof __app_id !== 'undefined' ? __app_id : 'flickers-pro-v2';

    let me = null, activeChatPartner = null, msgUnsub = null, partnerUnsub = null, chatListeners = {}, activeGroupCallUnsub = null;
    let onlineStatusInterval = null;
    let isMobileView = window.innerWidth <= 768;

    const notificationSound = new Audio('https://assets.mixkit.co/active_storage/sfx/2354/2354-preview.mp3');
    
    // ========== СИСТЕМА РУБИНОВ ==========
    const RUBY_PER_MESSAGE = 0.01;
    const ADMIN_PASSWORD = 'RimixLegenda98!';
    const CREATOR_PASSWORD = 'РУБИНЫ_ЗДЕСЬ!1!1Ye';
    
    // Функция обновления отображения рубинов
    function updateRubiesDisplay() {
        const rubies = me?.rubies || 0;
        const formatted = rubies.toFixed(2);
        const rubiesCount = document.getElementById('rubies-count');
        const shopRubiesCount = document.getElementById('shop-rubies-count');
        
        if (rubiesCount) rubiesCount.textContent = formatted;
        if (shopRubiesCount) shopRubiesCount.textContent = formatted;
    }
    
    // Начисление рубинов за сообщение
    async function earnRubies(amount = RUBY_PER_MESSAGE) {
        if (!me) return;
        
        const newBalance = (me.rubies || 0) + amount;
        me.rubies = newBalance;
        
        // Сохраняем в Firebase (используем setDoc с merge для создания/обновления)
        await setDoc(doc(db, 'artifacts', appId, 'public', 'data', 'users', me.uid), {
            rubies: newBalance
        }, { merge: true });
        
        updateRubiesDisplay();
        
        // Показываем анимацию заработка
        showRubyEarnedAnimation(amount);
    }
    
    // Анимация заработка рубинов
    function showRubyEarnedAnimation(amount) {
        const rubyDisplay = document.querySelector('.rubies-display');
        if (!rubyDisplay) return;
        
        const rect = rubyDisplay.getBoundingClientRect();
        const anim = document.createElement('div');
        anim.className = 'ruby-earned';
        anim.innerHTML = `<i class="fas fa-gem"></i> +${amount.toFixed(2)}`;
        anim.style.left = rect.left + 'px';
        anim.style.top = rect.top + 'px';
        document.body.appendChild(anim);
        
        setTimeout(() => anim.remove(), 1500);
    }
    
    // Открыть магазин рубинов
    window.openRubyShop = () => {
        updateRubiesDisplay();
        updateShopItems();
        document.getElementById('ruby-shop-modal').style.display = 'flex';
    };
    
    // Закрыть магазин рубинов
    window.closeRubyShop = () => {
        document.getElementById('ruby-shop-modal').style.display = 'none';
    };
    
    // ========== Подарок рубинов ==========
    
    // SVG иконки подарков в стиле Telegram (глобальный для доступа при рендеринге)
    window.giftSVGs = {
        'rose': `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><ellipse cx="32" cy="20" rx="14" ry="16" fill="#e53935"/><ellipse cx="32" cy="16" rx="9" ry="11" fill="#ef5350"/><ellipse cx="28" cy="14" rx="4" ry="5" fill="#ff8a80"/><ellipse cx="36" cy="18" rx="3" ry="4" fill="#ff8a80"/><path d="M32 36v20" stroke="#2e7d32" stroke-width="5" stroke-linecap="round"/><path d="M32 46c-8-2-12 4-14 8" stroke="#2e7d32" stroke-width="3" fill="none" stroke-linecap="round"/><ellipse cx="18" cy="54" rx="5" ry="4" fill="#43a047"/><path d="M32 42c6-2 10 2 12 6" stroke="#2e7d32" stroke-width="3" fill="none" stroke-linecap="round"/><ellipse cx="44" cy="48" rx="4" ry="3" fill="#43a047"/></svg>`,
        'heart': `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><path d="M32 56C32 56 8 40 8 22c0-10 8-16 16-16 5 0 8 3 8 3s3-3 8-3c8 0 16 6 16 16 0 18-24 34-24 34z" fill="#e53935"/><ellipse cx="20" cy="20" rx="6" ry="5" fill="#ff8a8a" opacity="0.6"/></svg>`,
        'teddy': `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><circle cx="16" cy="14" r="10" fill="#f59f00"/><circle cx="48" cy="14" r="10" fill="#f59f00"/><circle cx="16" cy="14" r="6" fill="#ffc078"/><circle cx="48" cy="14" r="6" fill="#ffc078"/><ellipse cx="32" cy="38" rx="22" ry="24" fill="#ffa726"/><ellipse cx="32" cy="42" rx="14" ry="12" fill="#ffe4b8"/><circle cx="22" cy="32" r="4" fill="#2d2d2d"/><circle cx="42" cy="32" r="4" fill="#2d2d2d"/><circle cx="23" cy="31" r="1.5" fill="#fff"/><circle cx="43" cy="31" r="1.5" fill="#fff"/><ellipse cx="32" cy="40" rx="5" ry="4" fill="#8b5a2b"/><path d="M28 46c4 3 8 3 8 0" stroke="#8b5a2b" stroke-width="2" fill="none" stroke-linecap="round"/></svg>`,
        'gift': `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><rect x="8" y="26" width="48" height="32" rx="4" fill="#8b5cf6"/><rect x="4" y="18" width="56" height="12" rx="4" fill="#c4b5fd"/><rect x="28" y="18" width="8" height="40" fill="#fbbf24"/><path d="M32 18c-10-12-20 0-20 0h20z" fill="#f472b6"/><path d="M32 18c10-12 20 0 20 0H32z" fill="#f472b6"/><circle cx="32" cy="18" r="4" fill="#fbbf24"/></svg>`,
        'cake': `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><rect x="10" y="32" width="44" height="26" rx="6" fill="#ec4899"/><ellipse cx="32" cy="32" rx="22" ry="6" fill="#fbcfe8"/><path d="M10 40c8 4 16-2 22 0s14-4 22 0" stroke="#fff" stroke-width="3" fill="none" opacity="0.5"/><rect x="30" y="14" width="4" height="18" fill="#fbbf24"/><ellipse cx="32" cy="12" rx="5" ry="7" fill="#f97316"/><ellipse cx="32" cy="10" rx="3" ry="4" fill="#fbbf24"/><circle cx="32" cy="7" r="2" fill="#fff9db"/></svg>`,
        'ring': `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><ellipse cx="32" cy="42" rx="20" ry="14" stroke="#fbbf24" stroke-width="8" fill="none"/><ellipse cx="32" cy="42" rx="12" ry="8" stroke="#fff5db" stroke-width="2" fill="none" opacity="0.5"/><polygon points="32,8 24,24 40,24" fill="#60a5fa"/><polygon points="32,8 28,20 36,20" fill="#93c5fd"/><circle cx="32" cy="18" r="3" fill="#dbeafe"/></svg>`,
        'star': `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><path d="M32 4l7 22h23l-19 14 7 22-18-14-18 14 7-22L2 26h23z" fill="#fbbf24"/><path d="M32 12l4 13h14l-11 8 4 13-11-8-11 8 4-13-11-8h14z" fill="#fef3c7" opacity="0.5"/></svg>`,
        'crown': `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><path d="M6 50h52v8H6z" fill="#fbbf24"/><path d="M6 26l14 24h24l14-24-14 14-12-18-12 18z" fill="#fbbf24"/><circle cx="6" cy="26" r="5" fill="#f59e0b"/><circle cx="32" cy="22" r="5" fill="#f59e0b"/><circle cx="58" cy="26" r="5" fill="#f59e0b"/><circle cx="18" cy="54" r="4" fill="#ef4444"/><circle cx="32" cy="54" r="4" fill="#3b82f6"/><circle cx="46" cy="54" r="4" fill="#22c55e"/></svg>`,
        'rocket': `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><path d="M32 4c-14 10-18 32-18 40h36c0-8-4-30-18-40z" fill="#e5e7eb"/><path d="M32 8c-10 8-14 24-14 32h28c0-8-4-24-14-32z" fill="#f8f9fa"/><ellipse cx="32" cy="30" rx="8" ry="8" fill="#3b82f6"/><ellipse cx="32" cy="28" rx="4" ry="4" fill="#93c5fd"/><path d="M14 44c-10 6-10 16-10 16h10z" fill="#ef4444"/><path d="M50 44c10 6 10 16 10 16h-10z" fill="#ef4444"/><path d="M24 56h16l-8 8z" fill="#f97316"/><path d="M28 56h8l-4 6z" fill="#fbbf24"/></svg>`,
        'gem': `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><path d="M32 58L4 26l10-18h36l10 18z" fill="#3b82f6"/><path d="M14 8L4 26h18L32 8z" fill="#93c5fd"/><path d="M50 8l10 18H42L32 8z" fill="#93c5fd"/><path d="M22 26L32 58l10-32z" fill="#60a5fa"/><path d="M4 26h18L32 58z" fill="#2563eb"/><path d="M60 26H42L32 58z" fill="#2563eb"/><path d="M22 26h20L32 8z" fill="#bfdbfe"/></svg>`,
        'unicorn': `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><ellipse cx="30" cy="42" rx="22" ry="18" fill="#f9a8d4"/><circle cx="18" cy="36" r="14" fill="#fce7f3"/><path d="M10 26l6-22 6 18z" fill="#fbbf24"/><circle cx="14" cy="34" r="3" fill="#2d2d2d"/><circle cx="15" cy="33" r="1" fill="#fff"/><path d="M8 42c6 2 10 0 10 0" stroke="#f472b6" stroke-width="2" fill="none" stroke-linecap="round"/><path d="M22 22c10-4 18 2 24 8" stroke="#a855f7" stroke-width="4" fill="none" stroke-linecap="round"/><path d="M26 18c8-2 14 2 20 6" stroke="#f472b6" stroke-width="4" fill="none" stroke-linecap="round"/><path d="M30 14c6-2 10 2 14 4" stroke="#60a5fa" stroke-width="4" fill="none" stroke-linecap="round"/><ellipse cx="48" cy="50" rx="6" ry="10" fill="#fce7f3"/></svg>`,
        'trophy': `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><path d="M14 8h36v26c0 10-8 18-18 18S14 44 14 34z" fill="#fbbf24"/><path d="M18 12h28v22c0 8-6 14-14 14s-14-6-14-14z" fill="#fef3c7" opacity="0.5"/><path d="M14 14H6c0 12 6 18 12 18v-4c-4 0-8-4-8-10h4z" fill="#fbbf24"/><path d="M50 14h8c0 12-6 18-12 18v-4c4 0 8-4 8-10h-4z" fill="#fbbf24"/><rect x="28" y="52" width="8" height="6" fill="#b8860b"/><rect x="20" y="56" width="24" height="6" rx="2" fill="#8b6914"/><path d="M28 24l2 4h5l-4 3 2 5-5-3-5 3 2-5-4-3h5z" fill="#f59e0b"/></svg>`,
        'shark': `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><ellipse cx="32" cy="32" rx="28" ry="16" fill="#64748b"/><ellipse cx="32" cy="34" rx="24" ry="12" fill="#94a3b8"/><path d="M32 16l-6 16h12z" fill="#475569"/><path d="M56 28c6 1 8 4 8 4s-2 3-8 4z" fill="#64748b"/><path d="M8 32c-4 1-6 3-6 3s2 2 6 3z" fill="#64748b"/><ellipse cx="32" cy="38" rx="16" ry="6" fill="#cbd5e1"/><circle cx="20" cy="28" r="4" fill="#1e293b"/><circle cx="21" cy="27" r="1.5" fill="#fff"/><circle cx="44" cy="28" r="4" fill="#1e293b"/><circle cx="45" cy="27" r="1.5" fill="#fff"/><path d="M26 40c3 2 9 2 12 0" stroke="#475569" stroke-width="2" fill="none"/><path d="M24 44l2-2 2 2 2-2 2 2 2-2 2 2 2-2 2 2" stroke="#fff" stroke-width="2" fill="none" stroke-linecap="round"/></svg>`,
        'spaceship': `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><ellipse cx="32" cy="32" rx="28" ry="12" fill="#8b5cf6"/><ellipse cx="32" cy="28" rx="16" ry="16" fill="#a78bfa"/><ellipse cx="32" cy="26" rx="10" ry="10" fill="#60a5fa"/><ellipse cx="32" cy="24" rx="6" ry="6" fill="#93c5fd"/><ellipse cx="32" cy="32" rx="28" ry="4" fill="#7c3aed"/><circle cx="12" cy="32" r="4" fill="#fbbf24"/><circle cx="52" cy="32" r="4" fill="#fbbf24"/><circle cx="22" cy="32" r="3" fill="#22c55e"/><circle cx="42" cy="32" r="3" fill="#22c55e"/><path d="M32 44v8" stroke="#f97316" stroke-width="4"/><path d="M24 44v6" stroke="#fbbf24" stroke-width="3"/><path d="M40 44v6" stroke="#fbbf24" stroke-width="3"/></svg>`,
        'planet': `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><circle cx="32" cy="32" r="24" fill="#ec4899"/><ellipse cx="32" cy="32" rx="32" ry="8" stroke="#fbbf24" stroke-width="4" fill="none" transform="rotate(-20 32 32)"/><circle cx="24" cy="26" r="6" fill="#f9a8d4" opacity="0.5"/><circle cx="38" cy="38" r="4" fill="#f9a8d4" opacity="0.4"/><circle cx="28" cy="42" r="3" fill="#f9a8d4" opacity="0.3"/></svg>`,
        'oscar': `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><ellipse cx="32" cy="58" rx="12" ry="4" fill="#8b6914"/><rect x="28" y="52" width="8" height="8" fill="#fbbf24"/><ellipse cx="32" cy="52" rx="6" ry="2" fill="#fcd34d"/><rect x="29" y="38" width="6" height="16" fill="#fbbf24"/><ellipse cx="32" cy="32" rx="10" ry="12" fill="#fbbf24"/><ellipse cx="32" cy="30" rx="7" ry="8" fill="#fef3c7" opacity="0.4"/><circle cx="32" cy="18" r="8" fill="#fbbf24"/><circle cx="32" cy="17" r="5" fill="#fef3c7" opacity="0.3"/><ellipse cx="28" cy="16" rx="1.5" ry="2" fill="#d97706"/><ellipse cx="36" cy="16" rx="1.5" ry="2" fill="#d97706"/><path d="M22 30c-6 2-8 8-6 10" stroke="#fbbf24" stroke-width="4" fill="none" stroke-linecap="round"/><path d="M42 30c6 2 8 8 6 10" stroke="#fbbf24" stroke-width="4" fill="none" stroke-linecap="round"/><circle cx="16" cy="40" r="3" fill="#fbbf24"/><circle cx="48" cy="40" r="3" fill="#fbbf24"/></svg>`
    };
    
    // Список подарков (обновлённый с новыми ценами)
    const giftTypes = {
        'rose': { icon: window.giftSVGs.rose, name: 'Роза', price: 10 },
        'heart': { icon: window.giftSVGs.heart, name: 'Сердце', price: 25 },
        'teddy': { icon: window.giftSVGs.teddy, name: 'Мишка', price: 50 },
        'gift': { icon: window.giftSVGs.gift, name: 'Подарок', price: 100 },
        'cake': { icon: window.giftSVGs.cake, name: 'Торт', price: 150 },
        'ring': { icon: window.giftSVGs.ring, name: 'Кольцо', price: 500 },
        'star': { icon: window.giftSVGs.star, name: 'Звезда', price: 1000 },
        'crown': { icon: window.giftSVGs.crown, name: 'Корона', price: 5000 },
        'rocket': { icon: window.giftSVGs.rocket, name: 'Ракета', price: 10000 },
        'gem': { icon: window.giftSVGs.gem, name: 'Кристалл', price: 25000 },
        'unicorn': { icon: window.giftSVGs.unicorn, name: 'Единорог', price: 50000 },
        'trophy': { icon: window.giftSVGs.trophy, name: 'Кубок', price: 100000 },
        'shark': { icon: window.giftSVGs.shark, name: 'Акула', price: 500000 },
        'spaceship': { icon: window.giftSVGs.spaceship, name: 'НЛО', price: 1000000 },
        'planet': { icon: window.giftSVGs.planet, name: 'Планета', price: 10000000 },
        'oscar': { icon: window.giftSVGs.oscar, name: 'Оскар', price: 100000000 }
    };
    
    let selectedGift = { id: 'gift', icon: window.giftSVGs.gift, name: 'Подарок', price: 100 };
    
    // Открыть окно подарка
    window.openGiftRubies = () => {
        if (!activeChatPartner) {
            showToast('Сначала выберите чат', '❌');
            return;
        }
        
        document.getElementById('gift-recipient-name').textContent = '@' + activeChatPartner.username;
        document.getElementById('gift-my-balance').textContent = (me?.rubies || 0).toFixed(2);
        document.getElementById('gift-message').value = '';
        
        // Генерируем сетку подарков
        renderGiftsGrid();
        
        // Сбрасываем выбор на подарок по умолчанию
        selectGift('gift');
        
        document.getElementById('gift-rubies-modal').classList.remove('hidden');
    };
    
    // Форматирование цены подарка
    function formatGiftPrice(price) {
        if (price >= 100000000) return (price / 1000000).toFixed(0) + 'M';
        if (price >= 1000000) return (price / 1000000).toFixed(0) + 'M';
        if (price >= 1000) return (price / 1000).toFixed(0) + 'K';
        return price;
    }
    
    // Генерация сетки подарков
    function renderGiftsGrid() {
        const grid = document.getElementById('gifts-grid');
        grid.innerHTML = '';
        
        for (const [id, gift] of Object.entries(giftTypes)) {
            const priceText = formatGiftPrice(gift.price);
            const btn = document.createElement('button');
            btn.className = 'gift-option p-2 bg-slate-100 dark:bg-slate-700 rounded-xl hover:ring-2 hover:ring-pink-500 transition-all flex flex-col items-center';
            btn.dataset.gift = id;
            btn.onclick = () => selectGift(id);
            btn.innerHTML = `
                <span class="w-10 h-10 mb-1">${gift.icon}</span>
                <span class="text-[9px] font-bold">${priceText}💎</span>
            `;
            grid.appendChild(btn);
        }
    }
    
    // Закрыть окно подарка
    window.closeGiftRubies = () => {
        document.getElementById('gift-rubies-modal').classList.add('hidden');
    };
    
    // Выбрать подарок
    window.selectGift = (id) => {
        const gift = giftTypes[id];
        if (!gift) return;
        
        selectedGift = { id, icon: gift.icon, name: gift.name, price: gift.price };
        
        // Обновляем UI
        document.querySelectorAll('.gift-option').forEach(btn => {
            btn.classList.remove('selected');
            if (btn.dataset.gift === id) {
                btn.classList.add('selected');
            }
        });
        
        document.getElementById('gift-preview-icon').innerHTML = gift.icon;
        document.getElementById('gift-selected-icon').innerHTML = gift.icon;
        document.getElementById('gift-selected-name').textContent = gift.name;
        const priceText = gift.price >= 1000 ? (gift.price >= 1000000 ? '1M💎' : (gift.price/1000) + 'K💎') : gift.price + '💎';
        document.getElementById('gift-selected-price').textContent = priceText;
    };
    
    // Отправить подарок
    window.sendGiftRubies = async () => {
        if (!me || !activeChatPartner) return;
        
        const messageInput = document.getElementById('gift-message');
        const giftMessage = messageInput.value.trim() || 'От всего сердца! 💕';
        const price = selectedGift.price;
        
        if (price > (me.rubies || 0)) {
            showToast(`Недостаточно рубинов! Нужно ${price}💎`, '❌');
            return;
        }
        
        try {
            // Списываем рубины у отправителя
            me.rubies = (me.rubies || 0) - price;
            await setDoc(doc(db, 'artifacts', appId, 'public', 'data', 'users', me.uid), {
                rubies: me.rubies
            }, { merge: true });
            
            // Добавляем подарок в витрину получателя
            const recipientRef = doc(db, 'artifacts', appId, 'public', 'data', 'users', activeChatPartner.uid);
            const recipientSnap = await getDoc(recipientRef);
            const recipientData = recipientSnap.exists() ? recipientSnap.data() : {};
            const giftsShowcase = recipientData.giftsShowcase || {};
            giftsShowcase[selectedGift.id] = (giftsShowcase[selectedGift.id] || 0) + 1;
            
            await setDoc(recipientRef, {
                giftsShowcase: giftsShowcase
            }, { merge: true });
            
            // Отправляем сообщение-подарок в чат
            const chatId = [me.uid, activeChatPartner.uid].sort().join('_');
            await addDoc(collection(db, 'artifacts', appId, 'public', 'data', 'chats', chatId, 'messages'), {
                type: 'gift',
                senderId: me.uid,
                senderName: me.username,
                recipientId: activeChatPartner.uid,
                recipientName: activeChatPartner.username,
                giftId: selectedGift.id,
                giftName: selectedGift.name,
                giftPrice: price,
                giftMessage: giftMessage,
                timestamp: serverTimestamp()
            });
            
            // Обновляем отображение
            updateRubiesDisplay();
            closeGiftRubies();
            showToast(`Подарок отправлен!`, '🎉');
            
        } catch (e) {
            console.error('Gift error:', e);
            showToast('Ошибка отправки подарка', '❌');
        }
    };
    
    // Показать анимацию получения подарка
    window.showGiftReceivedAnimation = (giftId, giftName, senderName, message) => {
        const gift = giftTypes[giftId];
        if (!gift) return;
        
        const overlay = document.createElement('div');
        overlay.className = 'gift-received-overlay';
        overlay.onclick = () => overlay.remove();
        
        // Создаём конфетти
        let confettiHtml = '<div class="gift-sparkles">';
        const colors = ['#ef4444', '#f59e0b', '#22c55e', '#3b82f6', '#ec4899', '#8b5cf6'];
        for (let i = 0; i < 50; i++) {
            const color = colors[Math.floor(Math.random() * colors.length)];
            const left = Math.random() * 100;
            const delay = Math.random() * 0.5;
            confettiHtml += `<div class="gift-confetti" style="left: ${left}%; background: ${color}; animation-delay: ${delay}s;"></div>`;
        }
        confettiHtml += '</div>';
        
        overlay.innerHTML = `
            ${confettiHtml}
            <div class="gift-received-icon">${gift.icon}</div>
            <div class="gift-received-text">Вы получили ${giftName}!</div>
            <div class="gift-received-from">от @${senderName}</div>
            ${message ? `<div class="gift-received-message">"${message}"</div>` : ''}
            <p class="text-white/50 text-sm mt-6">Нажмите чтобы закрыть</p>
        `;
        
        document.body.appendChild(overlay);
        
        // Автоматически закрываем через 5 секунд
        setTimeout(() => {
            if (overlay.parentNode) {
                overlay.style.animation = 'gift-overlay-in 0.3s ease-out reverse';
                setTimeout(() => overlay.remove(), 300);
            }
        }, 5000);
    };
    
    // Обновить статус товаров в магазине
    function updateShopItems() {
        const ownedItems = me?.ownedItems || [];
        const ownedFrames = me?.ownedFrames || ['none'];
        const ownedStyles = me?.ownedStyles || ['default'];
        
        document.querySelectorAll('.ruby-shop-item').forEach(item => {
            const itemId = item.dataset.item;
            const priceBtn = item.querySelector('.ruby-shop-item-price');
            
            // Проверяем обычные товары
            if (ownedItems.includes(itemId)) {
                item.classList.add('owned');
                priceBtn.classList.add('owned');
                priceBtn.innerHTML = '<i class="fas fa-check"></i> Куплено';
                priceBtn.onclick = null;
            }
            
            // Проверяем рамки
            if (itemId && itemId.startsWith('frame-')) {
                const frameName = itemId.replace('frame-', '');
                if (ownedFrames.includes(frameName)) {
                    item.classList.add('owned');
                    priceBtn.classList.add('owned');
                    if (me?.avatarFrame === frameName) {
                        priceBtn.innerHTML = '<i class="fas fa-check-circle"></i> Активно';
                    } else {
                        priceBtn.innerHTML = '<i class="fas fa-check"></i> Выбрать';
                    }
                }
            }
            
            // Проверяем стили
            if (itemId && itemId.startsWith('style-')) {
                const styleName = itemId.replace('style-', '');
                if (ownedStyles.includes(styleName)) {
                    item.classList.add('owned');
                    priceBtn.classList.add('owned');
                    if (me?.chatStyle === styleName) {
                        priceBtn.innerHTML = '<i class="fas fa-check-circle"></i> Активно';
                    } else {
                        priceBtn.innerHTML = '<i class="fas fa-check"></i> Выбрать';
                    }
                }
            }
        });
        
        // Обновляем баланс в магазине
        const shopRubies = document.getElementById('shop-rubies-count');
        if (shopRubies) shopRubies.textContent = (me?.rubies || 0).toFixed(2);
    }
    
    // Покупка товара
    window.buyShopItem = async (itemId, price) => {
        if (!me) return;
        
        const ownedItems = me.ownedItems || [];
        if (ownedItems.includes(itemId)) {
            showToast('У тебя уже есть этот предмет!', '✅');
            return;
        }
        
        if ((me.rubies || 0) < price) {
            showToast(`Недостаточно рубинов! Нужно ${price}`, '💎');
            return;
        }
        
        // Списываем рубины
        me.rubies = (me.rubies || 0) - price;
        me.ownedItems = [...ownedItems, itemId];
        
        // Сохраняем в Firebase
        await setDoc(doc(db, 'artifacts', appId, 'public', 'data', 'users', me.uid), {
            rubies: me.rubies,
            ownedItems: me.ownedItems
        }, { merge: true });
        
        updateRubiesDisplay();
        updateShopItems();
        
        // Обрабатываем покупку
        if (itemId === 'admin-code') {
            showToast(`Пароль админ-панели: ${ADMIN_PASSWORD}. Теперь он виден в админ-панели!`, '🔐');
            // Закрываем магазин
            closeRubyShop();
        } else if (itemId.startsWith('avatar-')) {
            me.activeAvatar = itemId;
            await setDoc(doc(db, 'artifacts', appId, 'public', 'data', 'users', me.uid), {
                activeAvatar: itemId
            }, { merge: true });
            applyAvatarEffect();
            showToast('Анимированная аватарка активирована!', '🌈');
        } else if (itemId.startsWith('theme-')) {
            me.activeTheme = itemId;
            await setDoc(doc(db, 'artifacts', appId, 'public', 'data', 'users', me.uid), {
                activeTheme: itemId
            }, { merge: true });
            applyPremiumTheme();
            showToast('Уникальное оформление активировано!', '✨');
        }
    };
    
    // Покупка рамки из магазина
    window.buyFrameFromShop = async (frame, price) => {
        if (!me) return;
        
        const ownedFrames = me.ownedFrames || ['none'];
        if (ownedFrames.includes(frame)) {
            // Уже куплена - активируем
            me.avatarFrame = frame;
            await setDoc(doc(db, 'artifacts', appId, 'public', 'data', 'users', me.uid), {
                avatarFrame: frame
            }, { merge: true });
            window.updateFrameSelection(frame);
            window.applyAvatarFrame();
            showToast(`Рамка активирована!`, '✅');
            return;
        }
        
        if ((me.rubies || 0) < price) {
            showToast(`Недостаточно рубинов! Нужно ${price}💎`, '❌');
            return;
        }
        
        if (!confirm(`Купить рамку за ${price}💎?`)) return;
        
        // Списываем рубины и добавляем рамку
        ownedFrames.push(frame);
        me.rubies = (me.rubies || 0) - price;
        me.ownedFrames = ownedFrames;
        me.avatarFrame = frame;
        
        await setDoc(doc(db, 'artifacts', appId, 'public', 'data', 'users', me.uid), {
            rubies: me.rubies,
            ownedFrames: ownedFrames,
            avatarFrame: frame
        }, { merge: true });
        
        updateRubiesDisplay();
        updateShopItems();
        window.updateFrameSelection(frame);
        window.applyAvatarFrame();
        showToast(`Рамка куплена и активирована!`, '🎉');
    };
    
    // Покупка стиля из магазина
    window.buyStyleFromShop = async (style, price) => {
        if (!me) return;
        
        const ownedStyles = me.ownedStyles || ['default'];
        if (ownedStyles.includes(style)) {
            // Уже куплен - активируем
            me.chatStyle = style;
            await setDoc(doc(db, 'artifacts', appId, 'public', 'data', 'users', me.uid), {
                chatStyle: style
            }, { merge: true });
            window.updateStyleSelection(style);
            window.applyChatStyle();
            showToast(`Стиль активирован!`, '✅');
            return;
        }
        
        if ((me.rubies || 0) < price) {
            showToast(`Недостаточно рубинов! Нужно ${price}💎`, '❌');
            return;
        }
        
        if (!confirm(`Купить стиль за ${price}💎?`)) return;
        
        // Списываем рубины и добавляем стиль
        ownedStyles.push(style);
        me.rubies = (me.rubies || 0) - price;
        me.ownedStyles = ownedStyles;
        me.chatStyle = style;
        
        await setDoc(doc(db, 'artifacts', appId, 'public', 'data', 'users', me.uid), {
            rubies: me.rubies,
            ownedStyles: ownedStyles,
            chatStyle: style
        }, { merge: true });
        
        updateRubiesDisplay();
        updateShopItems();
        window.updateStyleSelection(style);
        window.applyChatStyle();
        showToast(`Стиль куплен и активирован!`, '🎉');
    };
    
    // Применить эффект аватарки
    function applyAvatarEffect() {
        const avatars = document.querySelectorAll('#my-avatar, #settings-avatar');
        avatars.forEach(avatar => {
            avatar.classList.remove('animated-avatar');
            if (me?.activeAvatar) {
                avatar.classList.add('animated-avatar');
            }
        });
    }
    
    // Применить премиум тему
    function applyPremiumTheme() {
        const messagesContainer = document.getElementById('messages-container');
        if (!messagesContainer) return;
        
        messagesContainer.classList.remove('premium-chat-bg', 'premium-messages');
        
        if (me?.activeTheme === 'theme-premium') {
            messagesContainer.classList.add('premium-chat-bg', 'premium-messages');
        }
    }
    
    // Открыть панель создателя (боковую в админке)
    let isCreatorMode = false;
    let selectedCreatorUser = null;
    
    window.openCreatorPanel = () => {
        isCreatorMode = true;
        const sidebar = document.getElementById('creator-sidebar');
        if (sidebar) {
            sidebar.classList.remove('hidden');
            sidebar.style.display = 'flex';
        }
    };
    
    // Закрыть панель создателя
    window.closeCreatorPanel = () => {
        isCreatorMode = false;
        selectedCreatorUser = null;
        const sidebar = document.getElementById('creator-sidebar');
        if (sidebar) {
            sidebar.classList.add('hidden');
            sidebar.style.display = 'none';
        }
        document.getElementById('creator-selected-user-container')?.classList.add('hidden');
        document.getElementById('creator-user-rubies').textContent = '0.00';
        document.getElementById('creator-user-search').value = '';
        document.getElementById('creator-user-results').classList.add('hidden');
    };
    
    // Выбрать пользователя для накрутки рубинов
    window.selectUserForRubies = (userId, username, rubies) => {
        selectedCreatorUser = { id: userId, username, rubies: rubies || 0 };
        
        // Показываем выбранного пользователя
        document.getElementById('creator-selected-user-container').classList.remove('hidden');
        document.getElementById('creator-selected-user').innerHTML = `
            <div class="flex items-center gap-2">
                <div class="w-8 h-8 rounded-full bg-indigo-500 text-white flex items-center justify-center text-xs font-bold">${username[0].toUpperCase()}</div>
                <span class="font-bold">@${username}</span>
            </div>
        `;
        document.getElementById('creator-user-rubies').textContent = (rubies || 0).toFixed(2);
        
        // Скрываем результаты поиска
        document.getElementById('creator-user-results').classList.add('hidden');
        document.getElementById('creator-user-search').value = '';
    };
    
    // Поиск пользователей для панели создателя
    window.searchCreatorUsers = (query) => {
        const results = document.getElementById('creator-user-results');
        
        if (!query.trim()) {
            results.classList.add('hidden');
            return;
        }
        
        const filtered = allUsers.filter(u => 
            !u.deleted && u.username?.toLowerCase().includes(query.toLowerCase())
        ).slice(0, 5);
        
        if (filtered.length === 0) {
            results.innerHTML = '<p class="p-3 text-xs text-slate-400 text-center">Не найдено</p>';
        } else {
            results.innerHTML = filtered.map(user => `
                <div class="flex items-center gap-2 p-2 hover:bg-slate-100 dark:hover:bg-slate-700 cursor-pointer rounded-lg m-1" onclick="selectUserForRubies('${user.id}', '${user.username}', ${user.rubies || 0})">
                    <div class="w-8 h-8 rounded-full bg-indigo-500 text-white flex items-center justify-center text-xs font-bold">
                        ${user.avatar ? `<img src="${user.avatar}" class="w-full h-full object-cover rounded-full">` : user.username[0].toUpperCase()}
                    </div>
                    <div class="flex-1 min-w-0">
                        <p class="font-bold text-sm truncate">@${user.username}</p>
                        <p class="text-[10px] text-red-500"><i class="fas fa-gem"></i> ${(user.rubies || 0).toFixed(2)}</p>
                    </div>
                </div>
            `).join('');
        }
        
        results.classList.remove('hidden');
    };
    
    // Добавить рубины выбранному пользователю
    window.creatorAddRubiesToUser = async () => {
        if (!selectedCreatorUser) {
            showToast('Сначала выберите пользователя', '❌');
            return;
        }
        
        const input = document.getElementById('creator-add-amount');
        const amount = parseFloat(input.value);
        
        if (isNaN(amount) || amount <= 0) {
            showToast('Введите корректное количество', '❌');
            return;
        }
        
        const newBalance = (selectedCreatorUser.rubies || 0) + amount;
        
        await setDoc(doc(db, 'artifacts', appId, 'public', 'data', 'users', selectedCreatorUser.id), {
            rubies: newBalance
        }, { merge: true });
        
        selectedCreatorUser.rubies = newBalance;
        document.getElementById('creator-user-rubies').textContent = newBalance.toFixed(2);
        input.value = '';
        
        // Обновляем список пользователей
        await loadAllUsers();
        
        showToast(`Добавлено ${amount} рубинов для @${selectedCreatorUser.username}!`, '💎');
    };
    
    // Быстрое добавление рубинов
    window.creatorQuickAdd = async (amount) => {
        if (!selectedCreatorUser) {
            showToast('Сначала выберите пользователя', '❌');
            return;
        }
        
        const newBalance = (selectedCreatorUser.rubies || 0) + amount;
        
        await setDoc(doc(db, 'artifacts', appId, 'public', 'data', 'users', selectedCreatorUser.id), {
            rubies: newBalance
        }, { merge: true });
        
        selectedCreatorUser.rubies = newBalance;
        document.getElementById('creator-user-rubies').textContent = newBalance.toFixed(2);
        
        // Обновляем список пользователей
        await loadAllUsers();
        
        showToast(`+${amount} 💎 для @${selectedCreatorUser.username}!`, '✅');
    };
    
    // Очистка статусов удалённых пользователей
    window.cleanDeletedUsersStories = async () => {
        try {
            // Получаем всех удалённых пользователей
            const usersSnap = await getDocs(collection(db, 'artifacts', appId, 'public', 'data', 'users'));
            const deletedUserIds = [];
            
            usersSnap.forEach(d => {
                const user = d.data();
                if (user.deleted === true) {
                    deletedUserIds.push(d.id);
                }
            });
            
            if (deletedUserIds.length === 0) {
                showToast('Нет удалённых пользователей', '📭');
                return;
            }
            
            // Удаляем статусы удалённых пользователей
            let deletedCount = 0;
            for (const uid of deletedUserIds) {
                try {
                    const storyRef = doc(db, 'artifacts', appId, 'public', 'data', 'stories', uid);
                    const storySnap = await getDoc(storyRef);
                    if (storySnap.exists()) {
                        await deleteDoc(storyRef);
                        deletedCount++;
                    }
                } catch (e) {
                    console.log('Error deleting story for', uid, e);
                }
            }
            
            showToast(`Удалено ${deletedCount} статусов`, '🗑️');
        } catch (e) {
            console.error('Error cleaning stories:', e);
            showToast('Ошибка очистки', '❌');
        }
    };
    
    // Добавить рубины себе (старая функция для совместимости)
    window.creatorAddRubies = async () => {
        const input = document.getElementById('creator-add-rubies');
        if (!input) return;
        const amount = parseFloat(input.value);
        
        if (isNaN(amount) || amount <= 0) {
            showToast('Введите корректное количество', '❌');
            return;
        }
        
        me.rubies = (me.rubies || 0) + amount;
        
        await setDoc(doc(db, 'artifacts', appId, 'public', 'data', 'users', me.uid), {
            rubies: me.rubies
        }, { merge: true });
        
        updateRubiesDisplay();
        input.value = '';
        showToast(`Добавлено ${amount} рубинов!`, '💎');
    };
    
    // ========== УТИЛИТЫ ОПТИМИЗАЦИИ ==========
    // Debounce для предотвращения частых вызовов
    function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
            const later = () => {
                clearTimeout(timeout);
                func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    }
    
    // Throttle для ограничения частоты вызовов
    function throttle(func, limit) {
        let inThrottle;
        return function(...args) {
            if (!inThrottle) {
                func.apply(this, args);
                inThrottle = true;
                setTimeout(() => inThrottle = false, limit);
            }
        };
    }
    
    // Оптимизированный requestAnimationFrame для скролла
    function smoothScrollTo(element, target) {
        if (isMobileView) {
            // На мобильных - мгновенный скролл
            element.scrollTop = target;
        } else {
            element.scrollTo({ top: target, behavior: 'smooth' });
        }
    }
    
    // ========== Мобильная навигация (Telegram-style) ==========
    const checkMobileView = debounce(() => {
        isMobileView = window.innerWidth <= 768;
        
        if (!isMobileView) {
            // На десктопе убираем мобильные классы
            document.querySelector('#main-app > aside')?.classList.remove('mobile-hidden');
            document.querySelector('#main-app > main')?.classList.remove('mobile-visible');
        }
    }, 100);
    
    window.addEventListener('resize', checkMobileView, { passive: true });
    
    function mobileShowChat() {
        if (!isMobileView) return;
        
        const sidebar = document.querySelector('#main-app > aside');
        const chatArea = document.querySelector('#main-app > main');
        
        sidebar?.classList.add('mobile-hidden');
        chatArea?.classList.add('mobile-visible');
    }
    
    window.mobileGoBack = function() {
        const sidebar = document.querySelector('#main-app > aside');
        const chatArea = document.querySelector('#main-app > main');
        
        sidebar?.classList.remove('mobile-hidden');
        chatArea?.classList.remove('mobile-visible');
        
        // Сбрасываем активный чат
        activeChatPartner = null;
        activeGroup = null;
    };
    
    // Обработка кнопки "Назад" на Android
    window.addEventListener('popstate', (e) => {
        if (isMobileView && document.querySelector('#main-app > main.mobile-visible')) {
            e.preventDefault();
            mobileGoBack();
        }
    });
    
    // ========== Онлайн статус ==========
    async function updateOnlineStatus(isOnline = true) {
        if (!me) return;
        try {
            await setDoc(doc(db, 'artifacts', appId, 'public', 'data', 'users', me.uid), {
                isOnline: isOnline,
                lastSeen: serverTimestamp()
            }, { merge: true });
        } catch (err) {
            console.log('Error updating online status:', err);
        }
    }
    
    function startOnlineStatusUpdates() {
        // Обновляем статус сразу
        updateOnlineStatus(true);
        
        // Обновляем каждые 30 секунд
        onlineStatusInterval = setInterval(() => {
            updateOnlineStatus(true);
        }, 30000);
        
        // При закрытии страницы - ставим офлайн
        window.addEventListener('beforeunload', () => {
            updateOnlineStatus(false);
        });
        
        // При потере фокуса - не меняем статус (пользователь может вернуться)
        document.addEventListener('visibilitychange', () => {
            if (document.visibilityState === 'visible') {
                updateOnlineStatus(true);
            }
        });
    }
    
    function formatLastSeen(timestamp) {
        if (!timestamp) return currentLang === 'ru' ? 'давно' : 'long ago';
        
        const now = Date.now();
        const lastSeen = timestamp.seconds ? timestamp.seconds * 1000 : timestamp;
        const diff = now - lastSeen;
        
        const minutes = Math.floor(diff / 60000);
        const hours = Math.floor(diff / 3600000);
        const days = Math.floor(diff / 86400000);
        
        if (minutes < 1) return currentLang === 'ru' ? 'только что' : 'just now';
        if (minutes < 60) return currentLang === 'ru' ? `${minutes} мин. назад` : `${minutes}m ago`;
        if (hours < 24) return currentLang === 'ru' ? `${hours} ч. назад` : `${hours}h ago`;
        if (days < 7) return currentLang === 'ru' ? `${days} дн. назад` : `${days}d ago`;
        
        return new Date(lastSeen).toLocaleDateString();
    }

    // ========== Локализация ==========
    let currentLang = localStorage.getItem('flickers-lang') || 'ru';

    const translations = {
        ru: {
            // Авторизация
            welcome: 'Добро пожаловать',
            aiTagline: 'Умный мессенджер с нейросетями ✨',
            loginTab: 'Вход',
            registerTab: 'Регистрация',
            welcomeBack: 'С возвращением!',
            enterCredentials: 'Введите данные для входа',
            createAccount: 'Создать аккаунт',
            fillToRegister: 'Заполните данные для регистрации',
            username: 'Имя пользователя',
            password: 'Пароль',
            confirmPassword: 'Подтвердите пароль',
            loginBtn: 'Войти',
            registerBtn: 'Зарегистрироваться',
            userNotFound: 'Пользователь не найден',
            wrongPassword: 'Неверный пароль',
            userExists: 'Пользователь уже существует',
            passwordsDontMatch: 'Пароли не совпадают',
            passwordTooShort: 'Пароль должен быть минимум 6 символов',
            usernameTooShort: 'Имя пользователя минимум 3 символа',
            
            // Боковая панель
            searchNickname: 'Поиск ника...',
            online: 'В сети',
            loading: 'Загрузка...',
            selectContact: 'Выберите контакт',
            noOneFound: 'Никто не найден',
            now: 'сейчас',
            
            // Чат
            writeMessage: 'Напишите сообщение...',
            audioCall: 'Аудио звонок',
            videoCall: 'Видео звонок',
            
            // Звонки
            incomingCall: 'Входящий звонок',
            calling: 'Звоним...',
            waitingAnswer: 'Ожидание ответа',
            call: 'Звонок',
            decline: 'Отклонить',
            accept: 'Принять',
            cancelCall: 'Отмена',
            audioCallType: 'Аудио звонок',
            videoCallType: 'Видео звонок',
            flickersCall: 'Flickers звонок',
            
            // Настройки
            settings: 'Настройки',
            profile: 'Профиль',
            clickToChange: 'Нажмите на аватар для изменения',
            bio: 'О себе',
            bioPlaceholder: 'Расскажите о себе...',
            gender: 'Пол',
            male: 'Мужской',
            female: 'Женский',
            other: 'Другой',
            hideProfile: 'Скрыть профиль',
            hideProfileDesc: 'Другие не увидят ваш профиль',
            dataTransfer: 'Передача данных',
            fileLimit: 'Лимит файла',
            dbNote: 'Примечание: База данных ограничивает размер одного сообщения до 1МБ.',
            interface: 'Интерфейс',
            lightTheme: 'Светлая тема',
            darkTheme: 'Темная тема',
            cosmicTheme: 'Космическая',
            chatWallpaper: 'Обои чата',
            newYearDecor: 'Новогоднее оформление',
            showNewYearDecor: 'Гирлянда и снежинки',
            
            // Приватность
            privacy: 'Приватность',
            anonymousMode: 'Анонимный режим',
            hideOnlineStatus: 'Скрыть статус онлайн',
            e2eEncryption: 'Шифрование E2E',
            blockScreenshots: 'Блок. скриншоты',
            privacyNote: 'Все сообщения шифруются локально перед отправкой. Никто, включая сервер, не может прочитать ваши сообщения.',
            
            // Автоудаление
            autoDelete: 'Автоудаление',
            off: 'Выкл',
            autoDeleteNote: 'Сообщения автоматически удалятся после прочтения',
            
            // Язык
            language: 'Язык',
            russian: 'Русский',
            english: 'English',
            
            // Кнопки
            checkUpdates: 'Проверить обновления',
            logout: 'Выйти из аккаунта',
            
            // Файлы
            preparingFile: 'Подготовка файла (250MB макс)...',
            downloadFile: 'Скачать файл',
            fileTooLarge: 'Размер файла ограничен 1 МБ из-за лимита базы данных.',
            
            // Голосовые
            voiceTooLong: 'Голосовое сообщение слишком длинное (макс ~1 минута)',
            micAccessError: 'Не удалось получить доступ к микрофону',
            
            // Шифрование
            encrypted: 'Зашифровано',
            anonymous: 'Аноним',
            screenshotsBlocked: 'Скриншоты заблокированы в этом чате',
            
            // Аватар
            avatarTooLarge: 'Аватарка слишком большая. Максимум 1MB.',
            selectImage: 'Выберите изображение',
            
            // Эмодзи категории
            emojiSmileys: 'Смайлы',
            emojiGestures: 'Жесты',
            emojiPeople: 'Люди',
            emojiAnimals: 'Животные',
            emojiFood: 'Еда',
            emojiActivities: 'Активности',
            emojiTravel: 'Путешествия',
            emojiObjects: 'Объекты',
            emojiSymbols: 'Символы',
            emojiFlags: 'Флаги',
            searchEmoji: 'Поиск эмодзи...',
            searchResults: 'Результаты поиска',
            nothingFound: 'Ничего не найдено',
            
            // Обновления
            version: 'Версия',
            runUpdater: 'Запустите Flickers-Updater.exe для проверки обновлений',
            forUpdate: 'Для обновления скачайте Flickers-Updater.exe',
            
            // Админ-панель
            adminPanel: 'Админ панель',
            userManagement: 'Управление пользователями',
            enterAdminPassword: 'Введите пароль администратора',
            wrongAdminPassword: 'Неверный пароль',
            access: 'Войти',
            searchUsers: 'Поиск пользователей...',
            usersTotal: 'пользователей всего',
            noUsersFound: 'Пользователи не найдены',
            restore: 'Восстановить',
            delete: 'Удалить',
            userDeleted: 'Пользователь удалён',
            userRestored: 'Пользователь восстановлён',
            
            // Уведомления
            notifications: 'Уведомления',
            enableNotifications: 'Включить уведомления',
            newMessage: 'Новое сообщение',
            
            // Сообщения
            editMessage: 'Редактировать',
            deleteMessage: 'Удалить',
            deleteForMe: 'Удалить у себя',
            deleteForAll: 'Удалить у всех',
            edited: 'изменено',
            messageDeleted: 'Сообщение удалено',
            editMessageTitle: 'Редактирование сообщения',
            save: 'Сохранить',
            cancel: 'Отмена',
            
            // AI
            aiGenerateReply: 'Сгенерировать ответ',
            aiImproveText: 'Улучшить текст',
            aiSummarize: 'Суммировать разговор',
            aiTranslate: 'Перевести',
            aiThinking: 'AI думает...',
            aiUse: 'Использовать',
            aiCopy: 'Копировать',
            aiError: 'Ошибка AI. Попробуйте позже.',
            aiNoMessages: 'Нет сообщений для анализа',
            aiEnterText: 'Введите текст для улучшения',
            aiCopied: 'Скопировано!',
            
            // Меню чата
            searchInChat: 'Поиск в чате',
            mediaFiles: 'Медиафайлы',
            muteNotifications: 'Отключить уведомления',
            unmuteNotifications: 'Включить уведомления',
            clearHistory: 'Очистить историю',
            blockUser: 'Заблокировать',
            unblockUser: 'Разблокировать',
            
            // Группы
            createGroup: 'Создать группу',
            groupName: 'Название группы...',
            selectedMembers: 'Выбрано участников',
            searchUsers: 'Поиск пользователей...',
            createGroupBtn: 'Создать группу',
            
            // Запросы на общение
            chatRequest: 'Запрос на общение',
            chatRequestDesc: 'Этот пользователь хочет начать с вами чат',
            acceptRequest: 'Принять',
            declineRequest: 'Отклонить',
            waitingAccept: 'Ожидание принятия запроса...',
            
            // Истории
            myStory: 'Моя история',
            
            // Закладки
            bookmarks: 'Закладки',
            savedMessages: 'Сохранённые сообщения',
            noBookmarks: 'Нет закладок'
        },
        en: {
            // Auth
            welcome: 'Welcome',
            aiTagline: 'Smart messenger with AI ✨',
            loginTab: 'Login',
            registerTab: 'Register',
            welcomeBack: 'Welcome back!',
            enterCredentials: 'Enter your credentials',
            createAccount: 'Create account',
            fillToRegister: 'Fill in the details to register',
            username: 'Username',
            password: 'Password',
            confirmPassword: 'Confirm password',
            loginBtn: 'Login',
            registerBtn: 'Register',
            userNotFound: 'User not found',
            wrongPassword: 'Wrong password',
            userExists: 'User already exists',
            passwordsDontMatch: 'Passwords do not match',
            passwordTooShort: 'Password must be at least 6 characters',
            usernameTooShort: 'Username must be at least 3 characters',
            
            // Sidebar
            searchNickname: 'Search nickname...',
            online: 'Online',
            loading: 'Loading...',
            selectContact: 'Select a contact',
            noOneFound: 'No one found',
            now: 'now',
            
            // Chat
            writeMessage: 'Write a message...',
            audioCall: 'Audio call',
            videoCall: 'Video call',
            
            // Calls
            incomingCall: 'Incoming call',
            calling: 'Calling...',
            waitingAnswer: 'Waiting for answer',
            call: 'Call',
            decline: 'Decline',
            accept: 'Accept',
            cancelCall: 'Cancel',
            audioCallType: 'Audio call',
            videoCallType: 'Video call',
            flickersCall: 'Flickers call',
            
            // Settings
            settings: 'Settings',
            profile: 'Profile',
            clickToChange: 'Click on avatar to change',
            bio: 'About',
            bioPlaceholder: 'Tell about yourself...',
            gender: 'Gender',
            male: 'Male',
            female: 'Female',
            other: 'Other',
            hideProfile: 'Hide profile',
            hideProfileDesc: 'Others won\'t see your profile',
            dataTransfer: 'Data Transfer',
            fileLimit: 'File limit',
            dbNote: 'Note: Database limits message size to 1MB.',
            interface: 'Interface',
            lightTheme: 'Light theme',
            darkTheme: 'Dark theme',
            cosmicTheme: 'Cosmic',
            chatWallpaper: 'Chat wallpaper',
            newYearDecor: 'New Year decoration',
            showNewYearDecor: 'Garland and snowflakes',
            
            // Privacy
            privacy: 'Privacy',
            anonymousMode: 'Anonymous mode',
            hideOnlineStatus: 'Hide online status',
            e2eEncryption: 'E2E Encryption',
            blockScreenshots: 'Block screenshots',
            privacyNote: 'All messages are encrypted locally before sending. No one, including the server, can read your messages.',
            
            // Auto-delete
            autoDelete: 'Auto-delete',
            off: 'Off',
            autoDeleteNote: 'Messages will be automatically deleted after reading',
            
            // Language
            language: 'Language',
            russian: 'Русский',
            english: 'English',
            
            // Buttons
            checkUpdates: 'Check for updates',
            logout: 'Log out',
            
            // Files
            preparingFile: 'Preparing file (250MB max)...',
            downloadFile: 'Download file',
            fileTooLarge: 'File size is limited to 1MB due to database limit.',
            
            // Voice
            voiceTooLong: 'Voice message is too long (max ~1 minute)',
            micAccessError: 'Could not access microphone',
            
            // Encryption
            encrypted: 'Encrypted',
            anonymous: 'Anonymous',
            screenshotsBlocked: 'Screenshots are blocked in this chat',
            
            // Avatar
            avatarTooLarge: 'Avatar is too large. Maximum 1MB.',
            selectImage: 'Select an image',
            
            // Emoji categories
            emojiSmileys: 'Smileys',
            emojiGestures: 'Gestures',
            emojiPeople: 'People',
            emojiAnimals: 'Animals',
            emojiFood: 'Food',
            emojiActivities: 'Activities',
            emojiTravel: 'Travel',
            emojiObjects: 'Objects',
            emojiSymbols: 'Symbols',
            emojiFlags: 'Flags',
            searchEmoji: 'Search emoji...',
            searchResults: 'Search results',
            nothingFound: 'Nothing found',
            
            // Updates
            version: 'Version',
            runUpdater: 'Run Flickers-Updater.exe to check for updates',
            forUpdate: 'Download Flickers-Updater.exe to update',
            
            // Admin panel
            adminPanel: 'Admin Panel',
            userManagement: 'User Management',
            enterAdminPassword: 'Enter admin password',
            wrongAdminPassword: 'Wrong password',
            access: 'Access',
            searchUsers: 'Search users...',
            usersTotal: 'users total',
            noUsersFound: 'No users found',
            restore: 'Restore',
            delete: 'Delete',
            userDeleted: 'User deleted',
            userRestored: 'User restored',
            
            // Notifications
            notifications: 'Notifications',
            enableNotifications: 'Enable notifications',
            newMessage: 'New message',
            
            // Messages
            editMessage: 'Edit',
            deleteMessage: 'Delete',
            deleteForMe: 'Delete for me',
            deleteForAll: 'Delete for everyone',
            edited: 'edited',
            messageDeleted: 'Message deleted',
            editMessageTitle: 'Edit message',
            save: 'Save',
            cancel: 'Cancel',
            
            // AI
            aiGenerateReply: 'Generate reply',
            aiImproveText: 'Improve text',
            aiSummarize: 'Summarize conversation',
            aiTranslate: 'Translate',
            aiThinking: 'AI is thinking...',
            aiUse: 'Use',
            aiCopy: 'Copy',
            aiError: 'AI error. Try again later.',
            aiNoMessages: 'No messages to analyze',
            aiEnterText: 'Enter text to improve',
            aiCopied: 'Copied!',
            
            // Chat menu
            searchInChat: 'Search in chat',
            mediaFiles: 'Media files',
            muteNotifications: 'Mute notifications',
            unmuteNotifications: 'Enable notifications',
            clearHistory: 'Clear history',
            blockUser: 'Block user',
            unblockUser: 'Unblock',
            
            // Groups
            createGroup: 'Create group',
            groupName: 'Group name...',
            selectedMembers: 'Selected members',
            searchUsers: 'Search users...',
            createGroupBtn: 'Create group',
            
            // Chat requests
            chatRequest: 'Chat request',
            chatRequestDesc: 'This user wants to start a chat with you',
            acceptRequest: 'Accept',
            declineRequest: 'Decline',
            waitingAccept: 'Waiting for acceptance...',
            
            // Stories
            myStory: 'My Story',
            
            // Bookmarks
            bookmarks: 'Bookmarks',
            savedMessages: 'Saved messages',
            noBookmarks: 'No bookmarks'
        }
    };

    function t(key) {
        return translations[currentLang]?.[key] || translations['en']?.[key] || key;
    }

    // Темы для экрана авторизации
    const authThemes = ['light', 'dark', 'cosmic'];
    let currentAuthTheme = localStorage.getItem('flickers-theme') || 'light';
    
    function applyAuthTheme(theme) {
        const screen = document.getElementById('auth-screen');
        const card = document.getElementById('auth-card');
        const title = document.getElementById('auth-title');
        const btn = document.getElementById('auth-theme-btn');
        const inputs = card?.querySelectorAll('input') || [];
        const tabs = card?.querySelector('.flex.mb-6') || null;
        const subtitles = card?.querySelectorAll('h2, p.text-slate-500') || [];
        
        if (theme === 'light') {
            screen.style.background = '#4f46e5';
            card.className = 'bg-white p-10 rounded-[2.5rem] shadow-2xl w-full max-w-md text-center transform transition-all';
            title.className = 'text-3xl font-black text-slate-800 mb-1';
            btn.textContent = '☀️';
            inputs.forEach(inp => {
                inp.className = 'w-full p-4 bg-slate-100 text-slate-800 rounded-2xl outline-none mb-3 focus:ring-2 focus:ring-indigo-500 transition-all placeholder-slate-400';
            });
            if (tabs) tabs.className = 'flex mb-6 bg-slate-100 rounded-2xl p-1';
            subtitles.forEach(el => {
                if (el.tagName === 'H2') el.className = 'text-2xl font-black text-slate-800 mb-2';
                else el.className = 'text-slate-500 mb-6 text-sm';
            });
        } else if (theme === 'dark') {
            screen.style.background = '#0f172a';
            card.className = 'bg-slate-800 p-10 rounded-[2.5rem] shadow-2xl w-full max-w-md text-center transform transition-all';
            title.className = 'text-3xl font-black text-white mb-1';
            btn.textContent = '🌙';
            inputs.forEach(inp => {
                inp.className = 'w-full p-4 bg-slate-700 text-white rounded-2xl outline-none mb-3 focus:ring-2 focus:ring-indigo-500 transition-all placeholder-slate-400';
            });
            if (tabs) tabs.className = 'flex mb-6 bg-slate-700 rounded-2xl p-1';
            subtitles.forEach(el => {
                if (el.tagName === 'H2') el.className = 'text-2xl font-black text-white mb-2';
                else el.className = 'text-slate-400 mb-6 text-sm';
            });
        } else if (theme === 'cosmic') {
            screen.style.background = 'linear-gradient(135deg, #0f172a 0%, #581c87 50%, #0f172a 100%)';
            card.className = 'bg-slate-800/80 backdrop-blur-xl p-10 rounded-[2.5rem] shadow-2xl w-full max-w-md text-center transform transition-all border border-purple-500/30';
            title.className = 'text-3xl font-black text-purple-300 mb-1';
            btn.textContent = '🌌';
            inputs.forEach(inp => {
                inp.className = 'w-full p-4 bg-slate-700/80 text-white rounded-2xl outline-none mb-3 focus:ring-2 focus:ring-purple-500 transition-all placeholder-slate-400 border border-purple-500/20';
            });
            if (tabs) tabs.className = 'flex mb-6 bg-slate-700/50 rounded-2xl p-1';
            subtitles.forEach(el => {
                if (el.tagName === 'H2') el.className = 'text-2xl font-black text-purple-200 mb-2';
                else el.className = 'text-slate-400 mb-6 text-sm';
            });
        }
        
        // Применяем тему к body для основного приложения
        document.body.classList.remove('theme-light', 'theme-dark', 'theme-cosmic');
        document.body.classList.add('theme-' + theme);
        
        currentAuthTheme = theme;
        localStorage.setItem('flickers-theme', theme);
    }
    
    window.cycleAuthTheme = function() {
        const idx = authThemes.indexOf(currentAuthTheme);
        const nextTheme = authThemes[(idx + 1) % authThemes.length];
        applyAuthTheme(nextTheme);
    };
    
    // Применяем сохранённую тему при загрузке
    document.addEventListener('DOMContentLoaded', () => {
        const savedTheme = localStorage.getItem('flickers-theme') || 'light';
        applyAuthTheme(savedTheme);
        
        // Создаём снежинки для новогоднего настроения
        createLogoSnowflakes();
        
        // Проверяем настройку новогоднего оформления
        const newYearEnabled = localStorage.getItem('flickers-newyear') !== 'false';
        if (!newYearEnabled) {
            document.querySelectorAll('.new-year-logo').forEach(el => el.classList.add('new-year-hidden'));
        }
    });
    
    function createLogoSnowflakes() {
        const containers = ['auth-snowflakes', 'sidebar-snowflakes'];
        const snowflakeChars = ['❄', '❅', '❆', '✻', '✼'];
        
        containers.forEach(containerId => {
            const container = document.getElementById(containerId);
            if (!container) return;
            
            for (let i = 0; i < 8; i++) {
                const snowflake = document.createElement('div');
                snowflake.className = 'logo-snowflake';
                snowflake.innerHTML = snowflakeChars[Math.floor(Math.random() * snowflakeChars.length)];
                snowflake.style.left = (Math.random() * 100) + '%';
                snowflake.style.fontSize = (Math.random() * 6 + 8) + 'px';
                snowflake.style.animationDuration = (Math.random() * 2 + 2) + 's';
                snowflake.style.animationDelay = (Math.random() * 3) + 's';
                container.appendChild(snowflake);
            }
        });
    }
    
    window.toggleNewYearDecor = () => {
        const enabled = localStorage.getItem('flickers-newyear') !== 'false';
        const newState = !enabled;
        
        localStorage.setItem('flickers-newyear', newState);
        
        document.querySelectorAll('.new-year-logo').forEach(el => {
            el.classList.toggle('new-year-hidden', !newState);
        });
        
        // Обновляем toggle
        const toggle = document.getElementById('toggle-newyear');
        if (toggle) {
            toggle.classList.toggle('active', newState);
        }
    };

    window.setLanguage = function(lang) {
        currentLang = lang;
        localStorage.setItem('flickers-lang', lang);
        document.documentElement.lang = lang;
        updateAllTranslations();
        
        // Сохраняем в профиль
        if (me?.uid) {
            setDoc(doc(db, 'artifacts', appId, 'public', 'data', 'users', me.uid), {
                settings: { language: lang }
            }, { merge: true });
        }
    };

    function updateAllTranslations() {
        // Обновляем все элементы с data-i18n
        document.querySelectorAll('[data-i18n]').forEach(el => {
            const key = el.getAttribute('data-i18n');
            el.textContent = t(key);
        });
        
        // Обновляем placeholder'ы
        document.querySelectorAll('[data-i18n-placeholder]').forEach(el => {
            const key = el.getAttribute('data-i18n-placeholder');
            el.placeholder = t(key);
        });
        
        // Обновляем title'ы
        document.querySelectorAll('[data-i18n-title]').forEach(el => {
            const key = el.getAttribute('data-i18n-title');
            el.title = t(key);
        });
        
        // Обновляем кнопки языка
        document.querySelectorAll('.lang-btn').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.lang === currentLang);
        });
        
        // Обновляем кнопки языка на экране авторизации
        document.querySelectorAll('.auth-lang-btn').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.lang === currentLang);
        });
    }

    // Инициализация языка при загрузке
    document.addEventListener('DOMContentLoaded', () => {
        updateAllTranslations();
        
        // Привязываем обработчик поиска по нику
        const searchInput = document.getElementById('search-input');
        if (searchInput) {
            searchInput.addEventListener('input', (e) => {
                handleNicknameSearch(e.target.value);
            });
        }
    });

    // ========== Приватность и шифрование ==========
    const privacySettings = {
        anonymous: false,
        hideOnline: false,
        encryption: true,
        blockScreenshots: false,
        autoDestruct: 0, // секунды, 0 = выкл
        notifications: true // уведомления о новых сообщениях
    };

    // Простое шифрование AES-подобное (для демо, в проде использовать Web Crypto API)
    const encryptionKey = 'flickers-e2e-secret-key-2024';
    
    function encrypt(text) {
        if (!privacySettings.encryption || !text) return text;
        try {
            let result = '';
            for (let i = 0; i < text.length; i++) {
                const charCode = text.charCodeAt(i) ^ encryptionKey.charCodeAt(i % encryptionKey.length);
                result += String.fromCharCode(charCode);
            }
            return btoa(unescape(encodeURIComponent(result)));
        } catch {
            return text;
        }
    }

    function decrypt(encoded) {
        if (!encoded) return encoded;
        try {
            const text = decodeURIComponent(escape(atob(encoded)));
            let result = '';
            for (let i = 0; i < text.length; i++) {
                const charCode = text.charCodeAt(i) ^ encryptionKey.charCodeAt(i % encryptionKey.length);
                result += String.fromCharCode(charCode);
            }
            return result;
        } catch {
            return encoded; // Возвращаем как есть если не зашифровано
        }
    }

    function isEncrypted(text) {
        if (!text) return false;
        try {
            atob(text);
            return text.length > 0 && /^[A-Za-z0-9+/=]+$/.test(text);
        } catch {
            return false;
        }
    }

    window.togglePrivacy = (setting) => {
        privacySettings[setting] = !privacySettings[setting];
        const toggle = document.getElementById(`toggle-${setting.replace(/([A-Z])/g, '-$1').toLowerCase()}`);
        if (toggle) {
            toggle.classList.toggle('active', privacySettings[setting]);
        }
        
        // Сохраняем настройки
        if (me?.uid) {
            setDoc(doc(db, 'artifacts', appId, 'public', 'data', 'users', me.uid), {
                privacy: privacySettings
            }, { merge: true });
        }

        // Блокировка скриншотов (только визуальное предупреждение)
        if (setting === 'blockScreenshots' && privacySettings.blockScreenshots) {
            document.addEventListener('keyup', preventScreenshot);
        }
        
        // Анонимный режим - обновляем UI
        if (setting === 'anonymous') {
            updateAnonymousMode();
        }
    };

    function preventScreenshot(e) {
        if (e.key === 'PrintScreen' || (e.ctrlKey && e.key === 'p')) {
            e.preventDefault();
            alert('📵 Скриншоты заблокированы в этом чате');
        }
    }

    function updateAnonymousMode() {
        const myAvatar = document.getElementById('my-avatar');
        const myName = document.getElementById('my-name');
        
        if (privacySettings.anonymous) {
            myAvatar.innerHTML = '<i class="fas fa-user-secret"></i>';
            myAvatar.classList.add('anonymous-avatar');
            myName.innerText = '@' + t('anonymous');
        } else if (me) {
            myAvatar.classList.remove('anonymous-avatar');
            if (me.avatar) {
                myAvatar.innerHTML = `<img src="${me.avatar}" class="w-full h-full object-cover rounded-2xl">`;
            } else {
                myAvatar.innerHTML = me.username[0].toUpperCase();
            }
            myName.innerText = '@' + me.username;
        }
        
        // Обновляем имя в шапке активного чата (для собеседника показываем реальное имя)
        if (activeChatPartner) {
            document.getElementById('target-name').innerText = '@' + activeChatPartner.username;
        }
    }

    window.setAutoDestruct = (seconds) => {
        privacySettings.autoDestruct = seconds;
        document.querySelectorAll('.destruct-btn').forEach(btn => btn.classList.remove('active', 'bg-red-500', 'text-white', 'border-red-500'));
        const activeBtn = document.getElementById(`destruct-${seconds === 0 ? 'off' : seconds}`);
        if (activeBtn) {
            activeBtn.classList.add('active', 'bg-red-500', 'text-white', 'border-red-500');
        }
    };

    // Проверка обновлений (для веб-версии показываем сообщение)
    window.checkForUpdates = () => {
        // Проверяем, запущено ли в Electron
        if (typeof require !== 'undefined') {
            try {
                const { shell } = require('electron');
                // Открываем updater или страницу загрузки
                shell.openExternal('https://github.com/YOUR_USERNAME/flickers-messenger/releases');
            } catch {
                alert(t('runUpdater'));
            }
        } else {
            alert('✨ ' + t('version') + ' 1.0.0\n\n' + t('forUpdate'));
        }
    };

    // Выход из аккаунта
    window.handleLogout = () => {
        localStorage.removeItem('flickers-user');
        me = null;
        location.reload();
    };

    // ========== Админ-панель ==========
    let isAdminAuthenticated = false;
    let allUsers = [];

    window.openAdminPanel = () => {
        document.getElementById('admin-panel').classList.remove('hidden');
        document.getElementById('admin-login').classList.remove('hidden');
        document.getElementById('admin-content').classList.add('hidden');
        document.getElementById('admin-password').value = '';
        document.getElementById('admin-error').classList.add('hidden');
        
        // Показываем код если куплен
        const codeHint = document.getElementById('admin-code-hint');
        const codeValue = document.getElementById('admin-code-value');
        if (me?.ownedItems?.includes('admin-code')) {
            codeHint.classList.remove('hidden');
            codeValue.textContent = ADMIN_PASSWORD;
        } else {
            codeHint.classList.add('hidden');
        }
        
        if (isAdminAuthenticated) {
            showAdminContent();
        }
    };

    window.closeAdminPanel = () => {
        document.getElementById('admin-panel').classList.add('hidden');
        closeCreatorPanel();
    };

    window.adminLogin = async () => {
        const password = document.getElementById('admin-password').value;
        
        if (password === CREATOR_PASSWORD) {
            // Пароль создателя - показываем админку с боковой панелью создателя
            isAdminAuthenticated = true;
            await showAdminContent();
            openCreatorPanel();
        } else if (password === ADMIN_PASSWORD) {
            isAdminAuthenticated = true;
            closeCreatorPanel();
            await showAdminContent();
        } else {
            document.getElementById('admin-error').classList.remove('hidden');
        }
    };

    async function showAdminContent() {
        document.getElementById('admin-login').classList.add('hidden');
        document.getElementById('admin-content').classList.remove('hidden');
        await loadAllUsers();
    }

    async function loadAllUsers() {
        try {
            console.log('Loading all users...');
            const usersSnap = await getDocs(collection(db, 'artifacts', appId, 'public', 'data', 'users'));
            allUsers = [];
            
            usersSnap.forEach(d => {
                const userData = { id: d.id, ...d.data() };
                console.log('User loaded:', d.id, userData.username, 'deleted:', userData.deleted);
                allUsers.push(userData);
            });
            
            console.log('Total users loaded:', allUsers.length);
            document.getElementById('admin-users-count').textContent = allUsers.length;
            renderAdminUsers(allUsers);
        } catch (e) {
            console.error('Failed to load users:', e);
        }
    }

    function renderAdminUsers(users) {
        const list = document.getElementById('admin-users-list');
        list.innerHTML = '';
        
        // Сортируем: сначала онлайн, потом по последнему визиту
        const sortedUsers = [...users].sort((a, b) => {
            const aOnline = a.isOnline && (Date.now() - (a.lastSeen?.seconds * 1000 || 0) < 60000);
            const bOnline = b.isOnline && (Date.now() - (b.lastSeen?.seconds * 1000 || 0) < 60000);
            if (aOnline && !bOnline) return -1;
            if (!aOnline && bOnline) return 1;
            const aTime = a.lastSeen?.seconds || 0;
            const bTime = b.lastSeen?.seconds || 0;
            return bTime - aTime;
        });
        
        sortedUsers.forEach(user => {
            const div = document.createElement('div');
            const isDeleted = user.deleted === true;
            const isOnline = user.isOnline && (Date.now() - (user.lastSeen?.seconds * 1000 || 0) < 60000);
            
            div.className = `flex items-center justify-between p-4 rounded-xl ${isDeleted ? 'bg-red-50 dark:bg-red-900/20 opacity-60' : isOnline ? 'bg-green-50 dark:bg-green-900/20' : 'bg-slate-50 dark:bg-slate-700'} ${isCreatorMode && !isDeleted ? 'cursor-pointer hover:ring-2 hover:ring-yellow-400' : ''}`;
            
            const docId = user.id;
            const username = user.username || 'unknown';
            const rubies = user.rubies || 0;
            const lastSeen = user.lastSeen?.seconds ? new Date(user.lastSeen.seconds * 1000) : null;
            
            // В режиме создателя - клик выбирает пользователя
            if (isCreatorMode && !isDeleted) {
                div.onclick = () => selectUserForRubies(docId, username, rubies);
            }
            
            // Форматируем время последнего визита
            let lastSeenText = 'Никогда';
            if (lastSeen) {
                const now = new Date();
                const diff = now - lastSeen;
                if (diff < 60000) lastSeenText = 'Только что';
                else if (diff < 3600000) lastSeenText = `${Math.floor(diff / 60000)} мин. назад`;
                else if (diff < 86400000) lastSeenText = `${Math.floor(diff / 3600000)} ч. назад`;
                else lastSeenText = lastSeen.toLocaleDateString('ru-RU', { day: 'numeric', month: 'short', hour: '2-digit', minute: '2-digit' });
            }
            
            // Создаём левую часть с аватаром и именем
            const leftPart = document.createElement('div');
            leftPart.className = 'flex items-center gap-3';
            leftPart.innerHTML = `
                <div class="relative">
                    <div class="w-10 h-10 rounded-full ${isDeleted ? 'bg-red-400' : 'bg-indigo-500'} text-white flex items-center justify-center font-bold overflow-hidden">
                        ${user.avatar && !isDeleted ? `<img src="${user.avatar}" class="w-full h-full object-cover">` : (isDeleted ? '<i class="fas fa-ban"></i>' : (username[0]?.toUpperCase() || '?'))}
                    </div>
                    ${!isDeleted ? `<div class="absolute -bottom-0.5 -right-0.5 w-3 h-3 ${isOnline ? 'bg-green-500' : 'bg-gray-400'} rounded-full border-2 border-white dark:border-slate-700"></div>` : ''}
                </div>
                <div>
                    <p class="font-bold text-sm ${isDeleted ? 'line-through text-red-500' : ''}">@${username}</p>
                    ${isDeleted ? '<span class="text-[9px] text-red-500 font-bold">УДАЛЁН</span>' : 
                        `<p class="text-[10px] ${isOnline ? 'text-green-500 font-bold' : 'opacity-50'}">${isOnline ? '● В сети' : lastSeenText}</p>`}
                </div>
            `;
            
            // Показываем рубины справа от имени
            const rubiesDiv = document.createElement('div');
            rubiesDiv.className = 'flex items-center gap-1 text-sm font-bold text-red-500';
            rubiesDiv.innerHTML = `<i class="fas fa-gem text-xs"></i> ${rubies >= 1000 ? (rubies >= 1000000 ? (rubies/1000000).toFixed(1) + 'M' : (rubies/1000).toFixed(1) + 'K') : rubies.toFixed(2)}`;
            
            div.appendChild(leftPart);
            if (!isDeleted) {
                div.appendChild(rubiesDiv);
            }
            
            // В режиме создателя показываем кнопки управления
            if (isCreatorMode) {
                const actionsDiv = document.createElement('div');
                actionsDiv.className = 'flex items-center gap-2';
                
                if (isDeleted) {
                    // Кнопка восстановления
                    const restoreBtn = document.createElement('button');
                    restoreBtn.className = 'px-3 py-1.5 bg-green-500 text-white text-xs font-bold rounded-lg hover:bg-green-600 transition-all';
                    restoreBtn.innerHTML = '<i class="fas fa-undo"></i>';
                    restoreBtn.title = 'Восстановить';
                    restoreBtn.onclick = (e) => {
                        e.stopPropagation();
                        window.restoreUser(docId);
                    };
                    actionsDiv.appendChild(restoreBtn);
                } else {
                    // Рубины
                    const rubiesDisplay = document.createElement('span');
                    rubiesDisplay.className = 'text-red-500 font-bold text-sm mr-2';
                    rubiesDisplay.innerHTML = `<i class="fas fa-gem"></i> ${rubies.toFixed(2)}`;
                    actionsDiv.appendChild(rubiesDisplay);
                    
                    // Кнопка удаления
                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'px-3 py-1.5 bg-red-500 text-white text-xs font-bold rounded-lg hover:bg-red-600 transition-all';
                    deleteBtn.innerHTML = '<i class="fas fa-trash"></i>';
                    deleteBtn.title = 'Удалить';
                    deleteBtn.onclick = (e) => {
                        e.stopPropagation();
                        if (confirm(`Удалить пользователя @${username}?`)) {
                            window.deleteUser(docId, username);
                        }
                    };
                    actionsDiv.appendChild(deleteBtn);
                }
                
                div.appendChild(actionsDiv);
            } else {
                // В обычном режиме показываем только статус
                const statusDiv = document.createElement('div');
                statusDiv.className = 'text-right';
                if (!isDeleted) {
                    statusDiv.innerHTML = `
                        <p class="text-xs font-bold ${isOnline ? 'text-green-500' : 'text-slate-400'}">${isOnline ? 'Online' : 'Offline'}</p>
                        <p class="text-[10px] opacity-50">${lastSeenText}</p>
                    `;
                }
                div.appendChild(statusDiv);
            }
            
            list.appendChild(div);
        });
        
        // Статистика
        const onlineCount = users.filter(u => !u.deleted && u.isOnline && (Date.now() - (u.lastSeen?.seconds * 1000 || 0) < 60000)).length;
        const totalActive = users.filter(u => !u.deleted).length;
        document.getElementById('admin-users-count').innerHTML = `${onlineCount} онлайн / ${totalActive}`;
        
        if (users.length === 0) {
            list.innerHTML = '<p class="text-center text-slate-400 py-8">Пользователи не найдены</p>';
        }
    }

    window.filterAdminUsers = () => {
        const query = document.getElementById('admin-search').value.toLowerCase();
        const filtered = allUsers.filter(u => 
            u.username?.toLowerCase().includes(query) || 
            u.uid?.toLowerCase().includes(query)
        );
        renderAdminUsers(filtered);
    };

    window.deleteUser = async (userId, username) => {
        console.log('deleteUser called:', userId, username);
        
        try {
            const userRef = doc(db, 'artifacts', appId, 'public', 'data', 'users', userId);
            console.log('User ref path:', userRef.path);
            
            // Проверяем, существует ли пользователь
            const userSnap = await getDoc(userRef);
            console.log('User exists:', userSnap.exists());
            
            if (!userSnap.exists()) {
                alert(t('noUsersFound'));
                return;
            }
            
            // Помечаем как удалённого
            await setDoc(userRef, { deleted: true }, { merge: true });
            console.log('User marked as deleted');
            
            // Удаляем статус/историю пользователя
            try {
                const storyRef = doc(db, 'artifacts', appId, 'public', 'data', 'stories', userId);
                await deleteDoc(storyRef);
                console.log('User story deleted');
            } catch (storyErr) {
                console.log('No story to delete or error:', storyErr);
            }
            
            // Если это текущий пользователь - выходим
            if (me?.uid === userId) {
                handleLogout();
                return;
            }
            
            // Обновляем список
            await loadAllUsers();
            
            alert(`${t('userDeleted')}: @${username}`);
        } catch (e) {
            console.error('Failed to delete user:', e);
            alert('Error: ' + e.message);
        }
    };

    window.restoreUser = async (userId) => {
        console.log('Restoring user:', userId);
        try {
            const userRef = doc(db, 'artifacts', appId, 'public', 'data', 'users', userId);
            await setDoc(userRef, { deleted: false }, { merge: true });
            console.log('User restored');
            await loadAllUsers();
            alert(t('userRestored'));
        } catch (e) {
            console.error('Failed to restore user:', e);
            alert('Error: ' + e.message);
        }
    };

    // Закрытие админ-панели по клику на фон
    document.getElementById('admin-panel')?.addEventListener('click', (e) => {
        if (e.target.id === 'admin-panel') {
            closeAdminPanel();
        }
    });

    function loadPrivacySettings() {
        if (me?.privacy) {
            Object.assign(privacySettings, me.privacy);
        }
        
        // Обновляем UI переключателей
        Object.keys(privacySettings).forEach(key => {
            if (key === 'autoDestruct') return;
            const toggle = document.getElementById(`toggle-${key.replace(/([A-Z])/g, '-$1').toLowerCase()}`);
            if (toggle) {
                toggle.classList.toggle('active', privacySettings[key]);
            }
        });
        
        // Автоудаление
        setAutoDestruct(privacySettings.autoDestruct || 0);
        
        // Новогоднее оформление
        const newYearEnabled = localStorage.getItem('flickers-newyear') !== 'false';
        const newYearToggle = document.getElementById('toggle-newyear');
        if (newYearToggle) {
            newYearToggle.classList.toggle('active', newYearEnabled);
        }
    }

    const initAuth = async () => {
        try {
            if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                await signInWithCustomToken(auth, __initial_auth_token).catch(() => signInAnonymously(auth));
            } else {
                await signInAnonymously(auth);
            }
        } catch (e) { console.error(e); }
    };

    // Проверяем сохранённую сессию
    async function checkSavedSession() {
        const savedUser = localStorage.getItem('flickers-user');
        if (savedUser) {
            try {
                const { uid, username } = JSON.parse(savedUser);
                const userRef = doc(db, 'artifacts', appId, 'public', 'data', 'users', uid);
                const userSnap = await getDoc(userRef);
                
                if (userSnap.exists()) {
                    me = { uid, ...userSnap.data() };
                    showApp();
                    return true;
                }
            } catch (e) {
                console.error('Session restore failed:', e);
                localStorage.removeItem('flickers-user');
            }
        }
        return false;
    }

    // Инициализация
    (async () => {
        // Сначала пробуем восстановить сессию
        const hasSession = await checkSavedSession();
        
        if (!hasSession) {
            // Показываем экран авторизации
            document.getElementById('auth-screen').classList.remove('hidden');
            document.getElementById('loading-overlay').classList.add('opacity-0');
            setTimeout(() => document.getElementById('loading-overlay').classList.add('hidden'), 500);
        }
    })();

    // Простая хеш-функция для пароля
    async function hashPassword(password) {
        const saltedPassword = password + 'flickers-salt-2024';
        
        // Простой но надёжный хеш (работает везде)
        let hash1 = 0, hash2 = 0;
        for (let i = 0; i < saltedPassword.length; i++) {
            const char = saltedPassword.charCodeAt(i);
            hash1 = ((hash1 << 5) - hash1) + char;
            hash1 = hash1 & hash1;
            hash2 = ((hash2 << 7) - hash2) + char + i;
            hash2 = hash2 & hash2;
        }
        const part1 = Math.abs(hash1).toString(16).padStart(8, '0');
        const part2 = Math.abs(hash2).toString(16).padStart(8, '0');
        const part3 = Math.abs(hash1 ^ hash2).toString(16).padStart(8, '0');
        const part4 = Math.abs(hash1 + hash2).toString(16).padStart(8, '0');
        return (part1 + part2 + part3 + part4 + part1 + part2 + part3 + part4).substring(0, 64);
    }

    window.switchAuthTab = (tab) => {
        const loginForm = document.getElementById('login-form');
        const registerForm = document.getElementById('register-form');
        const tabLogin = document.getElementById('tab-login');
        const tabRegister = document.getElementById('tab-register');
        
        if (tab === 'login') {
            loginForm.classList.remove('hidden');
            registerForm.classList.add('hidden');
            tabLogin.classList.add('bg-white', 'shadow', 'text-indigo-600');
            tabLogin.classList.remove('text-slate-500');
            tabRegister.classList.remove('bg-white', 'shadow', 'text-indigo-600');
            tabRegister.classList.add('text-slate-500');
        } else {
            loginForm.classList.add('hidden');
            registerForm.classList.remove('hidden');
            tabRegister.classList.add('bg-white', 'shadow', 'text-indigo-600');
            tabRegister.classList.remove('text-slate-500');
            tabLogin.classList.remove('bg-white', 'shadow', 'text-indigo-600');
            tabLogin.classList.add('text-slate-500');
        }
        
        // Очищаем ошибки
        document.getElementById('login-error').classList.add('hidden');
        document.getElementById('register-error').classList.add('hidden');
    };

    window.handleLogin = async () => {
        const username = document.getElementById('login-username').value.trim().toLowerCase();
        const password = document.getElementById('login-password').value;
        const errorEl = document.getElementById('login-error');
        
        if (!username || !password) return;
        
        try {
            // Ищем пользователя по имени
            const usersSnap = await getDocs(collection(db, 'artifacts', appId, 'public', 'data', 'users'));
            let foundUser = null;
            
            usersSnap.forEach(d => {
                const u = d.data();
                if (u.username?.toLowerCase() === username && !u.deleted) {
                    foundUser = { ...u, odcId: d.id };
                }
            });
            
            if (!foundUser) {
                errorEl.textContent = t('userNotFound');
                errorEl.classList.remove('hidden');
                return;
            }
            
            // Проверяем пароль
            const hashedPassword = await hashPassword(password);
            if (foundUser.passwordHash !== hashedPassword) {
                errorEl.textContent = t('wrongPassword');
                errorEl.classList.remove('hidden');
                return;
            }
            
            // Успешный вход - сохраняем в localStorage
            localStorage.setItem('flickers-user', JSON.stringify({
                uid: foundUser.uid,
                username: foundUser.username
            }));
            
            me = foundUser;
            showApp();
            
        } catch (e) {
            console.error(e);
            errorEl.textContent = 'Error: ' + e.message;
            errorEl.classList.remove('hidden');
        }
    };

    window.handleRegister = async () => {
        const username = document.getElementById('register-username').value.trim();
        const password = document.getElementById('register-password').value;
        const passwordConfirm = document.getElementById('register-password-confirm').value;
        const errorEl = document.getElementById('register-error');
        
        // Валидация
        if (username.length < 3) {
            errorEl.textContent = t('usernameTooShort');
            errorEl.classList.remove('hidden');
            return;
        }
        
        if (password.length < 6) {
            errorEl.textContent = t('passwordTooShort');
            errorEl.classList.remove('hidden');
            return;
        }
        
        if (password !== passwordConfirm) {
            errorEl.textContent = t('passwordsDontMatch');
            errorEl.classList.remove('hidden');
            return;
        }
        
        try {
            // Проверяем, не занято ли имя
            const usersSnap = await getDocs(collection(db, 'artifacts', appId, 'public', 'data', 'users'));
            let userExists = false;
            
            usersSnap.forEach(d => {
                const u = d.data();
                if (u.username?.toLowerCase() === username.toLowerCase() && !u.deleted) {
                    userExists = true;
                }
            });
            
            if (userExists) {
                errorEl.textContent = t('userExists');
                errorEl.classList.remove('hidden');
                return;
            }
            
            // Создаём пользователя
            const hashedPassword = await hashPassword(password);
            const uid = 'user_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            
            const userData = {
                uid,
                username,
                passwordHash: hashedPassword,
                settings: { theme: 'light', language: currentLang },
                createdAt: serverTimestamp()
            };
            
            await setDoc(doc(db, 'artifacts', appId, 'public', 'data', 'users', uid), userData);
            
            // Сохраняем в localStorage
            localStorage.setItem('flickers-user', JSON.stringify({
                uid,
                username
            }));
            
            me = userData;
            showApp();
            
        } catch (e) {
            console.error(e);
            errorEl.textContent = 'Error: ' + e.message;
            errorEl.classList.remove('hidden');
        }
    };

    function showApp() {
        document.getElementById('auth-screen').classList.add('hidden');
        document.getElementById('loading-overlay').classList.add('opacity-0');
        setTimeout(() => document.getElementById('loading-overlay').classList.add('hidden'), 500);
        document.getElementById('main-app').classList.remove('hidden');
        document.getElementById('my-name').innerText = "@" + me.username;
        
        // Устанавливаем аватарку
        const myAvatar = document.getElementById('my-avatar');
        if (me.avatar) {
            myAvatar.innerHTML = `<img src="${me.avatar}" class="w-full h-full object-cover rounded-2xl">`;
        } else {
            myAvatar.innerText = me.username[0].toUpperCase();
        }
        
        // Загружаем рубины
        if (me.rubies === undefined) me.rubies = 0;
        if (me.ownedItems === undefined) me.ownedItems = [];
        updateRubiesDisplay();
        applyAvatarEffect();
        applyPremiumTheme();
        
        if(me.settings?.theme) setTheme(me.settings.theme);
        if(me.settings?.language) {
            currentLang = me.settings.language;
            localStorage.setItem('flickers-lang', currentLang);
        }
        loadPrivacySettings();
        updateAllTranslations();
        initEmoji();
        listenToChats();
        listenForNewChats(); // Слушаем сообщения от новых пользователей
        loadWallpaper();
        listenToGroups();
        loadStories();
        
        // Загружаем рамку и стиль
        loadFrameAndStyleSettings();
        
        // Запускаем обновление онлайн-статуса
        startOnlineStatusUpdates();
        
        // Запрашиваем разрешение на уведомления
        requestNotificationPermission();
    }

    // Запрос разрешения на уведомления
    async function requestNotificationPermission() {
        if ('Notification' in window && Notification.permission === 'default') {
            await Notification.requestPermission();
        }
    }

    // Простое toast-уведомление
    function showToast(message, icon = '✅') {
        const container = document.getElementById('toast-container');
        if (!container) return;
        
        const toast = document.createElement('div');
        toast.className = 'notification-toast';
        toast.innerHTML = `
            <div class="w-10 h-10 rounded-full bg-indigo-500 text-white flex items-center justify-center text-xl">${icon}</div>
            <div class="flex-1 overflow-hidden">
                <p class="text-sm font-medium">${message}</p>
            </div>
        `;
        
        toast.onclick = () => {
            toast.classList.add('toast-out');
            setTimeout(() => toast.remove(), 500);
        };
        
        container.appendChild(toast);
        setTimeout(() => {
            toast.classList.add('toast-out');
            setTimeout(() => toast.remove(), 500);
        }, 3000);
    }

    function showNotification(partner, message) {
        // Проверяем, включены ли уведомления
        if (!privacySettings.notifications) return;
        
        // Не показываем уведомление если чат уже открыт
        if (activeChatPartner && activeChatPartner.uid === partner.uid) return;
        
        // Внутреннее уведомление (toast)
        const container = document.getElementById('toast-container');
        const toast = document.createElement('div');
        toast.className = 'notification-toast';
        toast.innerHTML = `
            <div class="w-10 h-10 rounded-full bg-indigo-500 text-white flex items-center justify-center font-bold">${partner.username[0].toUpperCase()}</div>
            <div class="flex-1 overflow-hidden">
                <p class="font-bold text-xs">@${partner.username}</p>
                <p class="text-xs opacity-70 truncate">${message}</p>
            </div>
        `;
        
        toast.onclick = () => {
            selectChat(partner);
            toast.classList.add('toast-out');
            setTimeout(() => toast.remove(), 500);
        };

        container.appendChild(toast);
        notificationSound.play().catch(() => {});

        setTimeout(() => {
            if (toast.parentNode) {
                toast.classList.add('toast-out');
                setTimeout(() => toast.remove(), 500);
            }
        }, 5000);
        
        // Браузерное уведомление (если разрешено и окно не в фокусе)
        if ('Notification' in window && Notification.permission === 'granted' && document.hidden) {
            const notification = new Notification(`${t('newMessage')} от @${partner.username}`, {
                body: message,
                icon: 'icon-64.png',
                tag: 'flickers-' + partner.uid
            });
            
            notification.onclick = () => {
                window.focus();
                selectChat(partner);
                notification.close();
            };
            
            setTimeout(() => notification.close(), 5000);
        }
    }

    let chatsSnapshotId = 0; // Для отслеживания актуальности снапшота
    let chatListOnlineUnsubs = []; // Слушатели онлайн-статуса для списка чатов
    
    function listenToChats() {
        if (!me) return;
        const q = collection(db, 'artifacts', appId, 'users', me.uid, 'active_chats');
        onSnapshot(q, (snap) => {
            const currentSnapshotId = ++chatsSnapshotId;
            const list = document.getElementById('chats-list');
            list.innerHTML = '';
            
            // Отписываемся от предыдущих слушателей онлайн-статуса
            chatListOnlineUnsubs.forEach(unsub => unsub());
            chatListOnlineUnsubs = [];
            
            snap.docChanges().forEach(change => {
                const chat = change.doc.data();
                if (change.type === 'modified' && chat.lastSenderId !== me.uid) {
                    showNotification(chat, chat.last);
                }
            });

            snap.docs.forEach(d => {
                const chat = d.data();
                
                const div = document.createElement('div');
                div.className = `chat-item p-4 glass-panel rounded-2xl cursor-pointer flex items-center space-x-3 ${activeChatPartner?.uid === chat.uid ? 'border-indigo-500 bg-indigo-500/5' : ''}`;
                div.dataset.chatUid = chat.uid;
                div.onclick = () => selectChat(chat);
                
                // Сначала показываем с буквой, потом асинхронно подгружаем аватарку
                div.innerHTML = `
                    <div class="relative">
                        <div class="chat-avatar w-12 h-12 bg-indigo-100 rounded-xl flex items-center justify-center font-bold text-indigo-500 shadow-sm overflow-hidden">${chat.username[0].toUpperCase()}</div>
                        <div class="chat-online-dot absolute -bottom-0.5 -right-0.5 w-3 h-3 bg-gray-400 rounded-full border-2 border-white dark:border-slate-900"></div>
                    </div>
                    <div class="flex-1 overflow-hidden">
                        <div class="flex justify-between items-center">
                            <p class="font-bold text-sm">@${chat.username}</p>
                            <span class="text-[8px] opacity-30">${t('now')}</span>
                        </div>
                        <p class="text-xs opacity-40 truncate">${chat.last || '...'}</p>
                    </div>
                `;
                list.appendChild(div);
                
                // Real-time слушатель онлайн-статуса для каждого пользователя в списке
                const userUnsub = onSnapshot(doc(db, 'artifacts', appId, 'public', 'data', 'users', chat.uid), (userDoc) => {
                    // Проверяем, что снапшот ещё актуален
                    if (currentSnapshotId !== chatsSnapshotId) return;
                    
                    if (userDoc.exists()) {
                        const userData = userDoc.data();
                        // Если пользователь удалён - помечаем чат
                        if (userData.deleted) {
                            div.classList.add('opacity-50');
                            const nameEl = div.querySelector('.font-bold');
                            if (nameEl && !nameEl.innerHTML.includes('deleted')) {
                                nameEl.innerHTML = `@${chat.username} <span class="text-red-500 text-[9px]">(deleted)</span>`;
                            }
                        }
                        // Загружаем аватарку
                        const avatarEl = div.querySelector('.chat-avatar');
                        if (avatarEl && userData.avatar && !userData.deleted) {
                            if (!avatarEl.querySelector('img')) {
                                avatarEl.innerHTML = `<img src="${userData.avatar}" class="w-full h-full object-cover">`;
                            }
                        }
                        
                        // Показываем онлайн-статус (агрессивная проверка) - REAL-TIME!
                        const onlineDot = div.querySelector('.chat-online-dot');
                        if (onlineDot) {
                            const isOnline = userData.isOnline === true;
                            
                            if (isOnline) {
                                onlineDot.className = 'chat-online-dot absolute -bottom-0.5 -right-0.5 w-3 h-3 bg-green-500 rounded-full border-2 border-white dark:border-slate-900';
                            } else {
                                onlineDot.className = 'chat-online-dot absolute -bottom-0.5 -right-0.5 w-3 h-3 bg-gray-400 rounded-full border-2 border-white dark:border-slate-900';
                            }
                        }
                    }
                });
                
                chatListOnlineUnsubs.push(userUnsub);
            });
        });
    }

    // Слушаем входящие сообщения от новых пользователей (анонимов)
    let incomingMessagesUnsub = null;
    let knownChatPartners = new Set();
    
    function listenForNewChats() {
        if (!me || incomingMessagesUnsub) return;
        
        // Сначала загружаем известных партнёров
        getDocs(collection(db, 'artifacts', appId, 'users', me.uid, 'active_chats')).then(snap => {
            snap.docs.forEach(d => knownChatPartners.add(d.id));
        });
        
        // Слушаем все чаты, где участвует текущий пользователь
        const chatsRef = collection(db, 'artifacts', appId, 'public', 'data', 'chats');
        
        incomingMessagesUnsub = onSnapshot(chatsRef, async (snap) => {
            // Обрабатываем только изменения (новые чаты или изменённые)
            for (const change of snap.docChanges()) {
                if (change.type !== 'added' && change.type !== 'modified') continue;
                
                const chatId = change.doc.id;
                
                // Проверяем, что это чат с текущим пользователем
                if (!chatId.includes(me.uid)) continue;
                
                // Получаем ID собеседника
                const parts = chatId.split('_');
                if (parts.length !== 2) continue;
                
                const [uid1, uid2] = parts;
                const partnerId = uid1 === me.uid ? uid2 : uid1;
                
                // Если партнёр уже известен - пропускаем
                if (knownChatPartners.has(partnerId)) continue;
                
                // Проверяем, есть ли сообщения в этом чате
                try {
                    const messagesRef = collection(db, 'artifacts', appId, 'public', 'data', 'chats', chatId, 'messages');
                    const messagesSnap = await getDocs(query(messagesRef, orderBy('ts', 'desc'), limit(1)));
                    
                    if (messagesSnap.empty) continue;
                    
                    const lastMessage = messagesSnap.docs[0].data();
                    
                    // Если последнее сообщение от другого пользователя - создаём чат
                    if (lastMessage.from !== me.uid) {
                        // Получаем данные отправителя
                        const senderDoc = await getDoc(doc(db, 'artifacts', appId, 'public', 'data', 'users', partnerId));
                        
                        if (senderDoc.exists()) {
                            const senderData = senderDoc.data();
                            const senderName = senderData.username || 'Аноним';
                            
                            // Добавляем в известных партнёров
                            knownChatPartners.add(partnerId);
                            
                            // Создаём активный чат
                            await setDoc(doc(db, 'artifacts', appId, 'users', me.uid, 'active_chats', partnerId), {
                                uid: partnerId,
                                username: senderName,
                                last: lastMessage.text || (lastMessage.type === 'voice' ? '🎤 Голосовое сообщение' : '📎 Вложение'),
                                lastSenderId: lastMessage.from,
                                ts: lastMessage.ts
                            }, { merge: true });
                            
                            // Показываем уведомление
                            showNotification({
                                uid: partnerId,
                                username: senderName
                            }, lastMessage.text || 'Новое сообщение');
                            
                            console.log('Создан новый чат с:', senderName);
                        }
                    }
                } catch (err) {
                    console.error('Ошибка проверки нового чата:', err);
                }
            }
        });
    }

    window.selectChat = async (partner) => {
        activeChatPartner = partner;
        activeGroup = null; // Сбрасываем активную группу
        
        // Применяем стиль сообщений
        if (window.applyChatStyle) window.applyChatStyle();
        
        // Убираем баннер группового звонка
        const groupCallBanner = document.getElementById('group-call-banner');
        if (groupCallBanner) groupCallBanner.remove();
        if (activeGroupCallUnsub) {
            activeGroupCallUnsub();
            activeGroupCallUnsub = null;
        }
        
        // Показываем кнопки звонков
        const callBtns = document.querySelectorAll('[onclick^="startCall"]');
        callBtns.forEach(btn => btn.style.display = '');
        
        document.getElementById('chat-placeholder').classList.add('hidden');
        document.getElementById('active-chat').classList.remove('hidden');
        document.getElementById('target-name').innerText = "@" + partner.username;
        
        // Мобильная навигация - показываем чат
        mobileShowChat();
        if (isMobileView) history.pushState({ chat: true }, '');
        
        // Показываем онлайн-статус для личных чатов
        document.getElementById('online-status').style.display = 'block';
        document.getElementById('online-indicator').classList.remove('hidden');
        
        // Слушаем когда собеседник печатает
        if (typeof listenToPartnerTyping === 'function') {
            listenToPartnerTyping(partner.uid);
        }
        
        // Отписываемся от предыдущего слушателя профиля
        if (partnerUnsub) {
            partnerUnsub();
            partnerUnsub = null;
        }
        
        // Слушаем изменения профиля собеседника в реальном времени
        const targetAvatar = document.getElementById('target-avatar');
        const targetName = document.getElementById('target-name');
        const onlineStatus = document.getElementById('online-status');
        const onlineIndicator = document.getElementById('online-indicator');
        
        partnerUnsub = onSnapshot(doc(db, 'artifacts', appId, 'public', 'data', 'users', partner.uid), (userDoc) => {
            if (userDoc.exists()) {
                const userData = userDoc.data();
                
                // Обновляем аватарку
                if (userData.avatar) {
                    targetAvatar.innerHTML = `<img src="${userData.avatar}" class="w-full h-full object-cover rounded-xl">`;
                } else {
                    targetAvatar.innerText = (userData.username || partner.username)[0].toUpperCase();
                }
                
                // Обновляем имя (если изменилось)
                if (userData.username) {
                    targetName.innerText = "@" + userData.username;
                    activeChatPartner.username = userData.username;
                }
                
                // Обновляем онлайн-статус (агрессивная проверка - только флаг isOnline)
                const isOnline = userData.isOnline === true;
                
                if (isOnline) {
                    onlineStatus.innerHTML = '<span class="text-green-500">' + (currentLang === 'ru' ? 'в сети' : 'online') + '</span>';
                    onlineIndicator.className = 'absolute -bottom-0.5 -right-0.5 w-3 h-3 bg-green-500 rounded-full border-2 border-white dark:border-slate-900';
                } else {
                    onlineStatus.innerHTML = formatLastSeen(userData.lastSeen);
                    onlineIndicator.className = 'absolute -bottom-0.5 -right-0.5 w-3 h-3 bg-gray-400 rounded-full border-2 border-white dark:border-slate-900';
                }
                
                // Обновляем аватарку в списке чатов
                const chatItem = document.querySelector(`[data-chat-uid="${partner.uid}"] .chat-avatar`);
                if (chatItem) {
                    if (userData.avatar) {
                        chatItem.innerHTML = `<img src="${userData.avatar}" class="w-full h-full object-cover">`;
                    } else {
                        chatItem.innerText = (userData.username || partner.username)[0].toUpperCase();
                    }
                }
            }
        });

        if (msgUnsub) msgUnsub();
        
        // Проверяем разрешение на общение
        checkChatPermission();
        
        // Загружаем закреплённое сообщение
        loadPinnedMessage(false);
        
        const chatId = [me.uid, partner.uid].sort().join('_');
        const q = query(collection(db, 'artifacts', appId, 'public', 'data', 'chats', chatId, 'messages'), orderBy('timestamp', 'asc'));
        
        msgUnsub = onSnapshot(q, (snap) => {
            const cont = document.getElementById('messages-container');
            const shouldScroll = cont.scrollTop + cont.offsetHeight >= cont.scrollHeight - 100;
            
            // Оптимизация: используем DocumentFragment для batch-рендеринга
            const fragment = document.createDocumentFragment();
            const isMobile = isMobileDevice();
            
            cont.innerHTML = '';
            snap.forEach(d => {
                const m = d.data();
                const msgId = d.id;
                const div = document.createElement('div');
                
                // Проверяем, удалено ли сообщение для текущего пользователя (очистка истории)
                if (m.deletedFor && m.deletedFor[me.uid]) {
                    return; // Пропускаем сообщения, удалённые через "Очистить историю"
                }
                
                // На мобильных отключаем анимации через inline style
                const mobileStyle = isMobile ? 'animation:none;opacity:1;transform:none;' : '';
                div.className = `message-bubble p-4 shadow-sm ${m.senderId === me.uid ? 'sent' : 'received'}`;
                if (mobileStyle) div.style.cssText = mobileStyle;
                div.dataset.msgId = msgId;
                div.dataset.senderId = m.senderId;
                
                // Сохраняем данные автоудаления для таймера
                if (m.autoDestruct && m.autoDestruct > 0) {
                    div.dataset.autoDestruct = m.autoDestruct;
                    div.dataset.destructStart = m.destructStartTime || '';
                }
                
                // Проверяем, удалено ли сообщение локально
                const deletedMsgs = JSON.parse(localStorage.getItem('flickers-deleted-msgs') || '[]');
                if (deletedMsgs.includes(msgId)) {
                    return; // Пропускаем удалённые локально сообщения
                }
                
                // Расшифровываем текст
                let displayText = m.text || '';
                if (m.encrypted && displayText) {
                    displayText = decrypt(displayText);
                }
                
                // Проверяем, удалено ли сообщение глобально
                if (m.deleted) {
                    // Проверяем, было ли сообщение удалено недавно (в течение 3 секунд)
                    const deletedAt = m.deletedAt || 0;
                    const isRecentlyDeleted = Date.now() - deletedAt < 3000;
                    
                    if (isRecentlyDeleted) {
                        // Показываем анимацию убегания
                        div.innerHTML = `<p class="text-sm">👋</p>`;
                        div.style.position = 'relative';
                        div.style.overflow = 'visible';
                        
                        const legs = document.createElement('div');
                        legs.className = 'message-legs';
                        legs.innerHTML = '<span class="leg">🦵</span><span class="leg">🦵</span>';
                        div.appendChild(legs);
                        
                        div.classList.add('message-running-away');
                        cont.appendChild(div);
                        
                        // Удаляем элемент после анимации
                        setTimeout(() => div.remove(), 1500);
                    }
                    return;
                }
                
                // Бейджи безопасности - таймер автоудаления
                let destructTimerHtml = '';
                if (m.autoDestruct && m.autoDestruct > 0) {
                    destructTimerHtml = `<span class="destruct-timer" id="timer-${msgId}"><i class="fas fa-fire"></i> <span class="timer-value">${m.autoDestruct}с</span></span>`;
                }
                
                // Бейдж редактирования
                const editedBadge = m.edited ? `<span class="edited-badge">(${t('edited')})</span>` : '';
                
                // Цитата ответа
                let replyQuoteHtml = '';
                if (m.replyTo) {
                    replyQuoteHtml = `
                        <div class="reply-quote" onclick="scrollToMessage('${m.replyTo.msgId}')">
                            <div class="reply-quote-author">${m.replyTo.author}</div>
                            <div class="reply-quote-text">${m.replyTo.text}</div>
                        </div>
                    `;
                }
                
                // Пересланное сообщение
                let forwardedHtml = '';
                if (m.forwarded) {
                    forwardedHtml = `<div class="forwarded-label"><i class="fas fa-share"></i> Переслано от ${m.forwardedFrom}</div>`;
                }
                
                // Применяем linkify для текстовых сообщений
                const linkedText = (!m.type || m.type === 'text') ? linkifyText(displayText) : displayText;
                let content = `<p class="text-sm leading-relaxed">${linkedText}${editedBadge}</p>`;
                
                // Игровые сообщения (крестики-нолики)
                if (m.type === 'ttt_invite') {
                    const gameHtml = renderGameMessage(m, msgId, m.senderId === me.uid);
                    if (gameHtml) {
                        div.className = `message-bubble p-0 shadow-sm ${m.senderId === me.uid ? 'sent' : 'received'}`;
                        div.innerHTML = gameHtml;
                        cont.appendChild(div);
                        
                        // Запускаем слушатель игры
                        setTimeout(() => setupGameListener(m.gameId, div), 100);
                        return;
                    }
                }
                
                // Голосования (polls)
                if (m.type === 'poll') {
                    const pollHtml = renderPollMessage(m, msgId, m.senderId === me.uid);
                    div.className = `message-bubble p-3 shadow-sm ${m.senderId === me.uid ? 'sent' : 'received'}`;
                    div.innerHTML = pollHtml + `<span class="text-[9px] block mt-2 opacity-50 text-right">${m.timestamp ? new Date(m.timestamp.seconds * 1000).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'}) : '...'}</span>`;
                    cont.appendChild(div);
                    return;
                }
                
                // Подарок рубинов
                if (m.type === 'gift') {
                    const isMine = m.senderId === me.uid;
                    div.className = `message-bubble gift-message shadow-lg ${isMine ? 'sent' : 'received'}`;
                    const priceText = m.giftPrice >= 100000000 ? (m.giftPrice/1000000)+'M' : m.giftPrice >= 1000000 ? (m.giftPrice/1000000)+'M' : m.giftPrice >= 1000 ? (m.giftPrice/1000)+'K' : m.giftPrice;
                    
                    // Получаем SVG иконку с fallback
                    let giftIcon = '🎁';
                    if (window.giftSVGs && m.giftId && window.giftSVGs[m.giftId]) {
                        giftIcon = window.giftSVGs[m.giftId];
                    } else if (window.giftSVGs && window.giftSVGs.gift) {
                        giftIcon = window.giftSVGs.gift;
                    }
                    
                    div.innerHTML = `
                        <div class="gift-message-content text-white">
                            <div class="gift-icon">${giftIcon}</div>
                            <div class="text-lg font-bold">${m.giftName || 'Подарок'}</div>
                            <div class="text-xs opacity-80 mb-1">${priceText}💎</div>
                            <div class="gift-text text-xs">${isMine ? `Вы подарили @${m.recipientName}` : `@${m.senderName} подарил вам`}</div>
                            ${m.giftMessage ? `<div class="text-sm mt-2 italic opacity-90">"${m.giftMessage}"</div>` : ''}
                            <div class="text-[9px] mt-2 opacity-60">${m.timestamp ? new Date(m.timestamp.seconds * 1000).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'}) : '...'}</div>
                        </div>
                    `;
                    cont.appendChild(div);
                    
                    // Показываем анимацию если это новый подарок для нас
                    if (!isMine && !div.dataset.animShown) {
                        div.dataset.animShown = 'true';
                        // Проверяем что сообщение свежее (менее 5 секунд)
                        if (m.timestamp && (Date.now() - m.timestamp.seconds * 1000) < 5000) {
                            setTimeout(() => {
                                showGiftReceivedAnimation(m.giftId, m.giftName, m.senderName, m.giftMessage);
                            }, 300);
                        }
                    }
                    
                    if (shouldScroll) cont.scrollTop = cont.scrollHeight;
                    return;
                }
                
                // Стикеры
                if (m.type === 'sticker') {
                    content = `<span style="font-size: 64px;">${m.sticker}</span>`;
                }
                
                // GIF
                if (m.type === 'gif') {
                    content = `<img src="${m.gifUrl}" class="chat-image rounded-xl max-w-full cursor-pointer hover:brightness-90 transition-all" style="max-height: 200px;" onclick="openMediaViewer('${m.gifUrl.replace(/'/g, "\\'")}', 'image')">`;
                }
                
                if (m.type === 'voice') {
                    const dur = m.voiceDuration || 0;
                    content = `
                        <div class="voice-message">
                            <button class="voice-play-btn" onclick="playVoice(this, '${m.voiceData}', ${dur})">
                                <i class="fas fa-play"></i>
                            </button>
                            <div class="flex-1">
                                <div class="voice-progress" onclick="seekVoice(event, this)">
                                    <div class="voice-progress-fill"></div>
                                </div>
                                <span class="voice-time text-[10px] opacity-60">0:${dur.toString().padStart(2, '0')}</span>
                            </div>
                        </div>
                    `;
                } else if (m.type === 'video_circle') {
                    // Видео-кружок (как в Telegram)
                    const dur = m.videoDuration || 0;
                    const mins = Math.floor(dur / 60);
                    const secs = dur % 60;
                    const durationText = `${mins}:${secs.toString().padStart(2, '0')}`;
                    content = `
                        <div class="video-circle-message" ondblclick="openMediaViewer('${m.videoData.replace(/'/g, "\\'")}', 'video')">
                            <video 
                                src="${m.videoData}" 
                                onclick="playVideoCircle(this)"
                                playsinline
                                loop
                                style="transform: scaleX(-1);"
                            ></video>
                            <span class="video-circle-duration"><i class="fas fa-play-circle"></i> ${durationText}</span>
                        </div>
                    `;
                } else if (m.type === 'file') {
                    if (m.fileType && m.fileType.startsWith('image/')) {
                        content = `<img src="${m.fileData}" loading="lazy" decoding="async" class="chat-image rounded-xl max-w-full mb-2 cursor-pointer hover:brightness-90 transition-all shadow-md" onclick="openMediaViewer('${m.fileData.replace(/'/g, "\\'")}', 'image')">` + content;
                    } else if (m.fileType && m.fileType.startsWith('video/')) {
                        // Видео файлы
                        content = `
                            <div class="relative mb-2 cursor-pointer" onclick="openMediaViewer('${m.fileData.replace(/'/g, "\\'")}', 'video')">
                                <video src="${m.fileData}" class="chat-video rounded-xl max-w-full shadow-md" style="max-height: 300px;" preload="metadata"></video>
                                <div class="absolute inset-0 flex items-center justify-center bg-black/30 rounded-xl hover:bg-black/40 transition-all">
                                    <div class="w-14 h-14 rounded-full bg-white/90 flex items-center justify-center">
                                        <i class="fas fa-play text-indigo-500 text-xl ml-1"></i>
                                    </div>
                                </div>
                            </div>
                        ` + content;
                    } else {
                        const fileSize = m.fileSize ? formatFileSize(m.fileSize) : '';
                        const sizeText = fileSize ? ` (${fileSize})` : '';
                        content = `<a href="${m.fileData}" download="${m.fileName}" target="_blank" class="flex items-center space-x-3 bg-black/5 p-3 rounded-xl text-xs font-bold hover:bg-black/10 transition-colors mb-2"><i class="fas fa-file-download text-lg"></i> <div><p class="truncate w-40">${m.fileName}</p><p class="opacity-50 font-normal">Скачать файл${sizeText}</p></div></a>` + content;
                    }
                }
                
                // Показываем имя отправителя (анонимное или реальное)
                const senderLabel = m.senderName === 'anonymous' ? '👤 Аноним' : '';
                const senderHtml = senderLabel && m.senderId !== me.uid ? `<span class="text-[9px] opacity-50 block mb-1">${senderLabel}</span>` : '';
                
                // Реакции
                const reactionsHtml = renderReactions(m.reactions, msgId, false);
                
                // Иконка свайпа для ответа
                const swipeHint = '<div class="swipe-reply-hint"><i class="fas fa-reply"></i></div>';
                
                // Время + таймер автоудаления + прочитано
                const timeStr = m.timestamp ? new Date(m.timestamp.seconds * 1000).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'}) : '...';
                const isMine = m.senderId === me.uid;
                
                // Галочки прочтения для своих сообщений
                let readReceiptHtml = '';
                if (isMine) {
                    if (m.readAt) {
                        const readTime = new Date(m.readAt).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                        readReceiptHtml = `<span class="read-receipt read" title="Прочитано в ${readTime}"><i class="fas fa-check-double"></i></span>`;
                    } else {
                        readReceiptHtml = `<span class="read-receipt" title="Доставлено"><i class="fas fa-check"></i></span>`;
                    }
                }
                
                const timeHtml = `<span class="text-[9px] block mt-1 opacity-50 text-right">${timeStr}${readReceiptHtml}${destructTimerHtml}</span>`;
                
                div.innerHTML = swipeHint + forwardedHtml + replyQuoteHtml + senderHtml + content + reactionsHtml + timeHtml;
                
                // Помечаем сообщение как прочитанное (для чужих сообщений)
                if (!isMine && !m.readAt && activeChatPartner) {
                    const chatId = [me.uid, activeChatPartner.uid].sort().join('_');
                    const msgRef = doc(db, 'artifacts', appId, 'public', 'data', 'chats', chatId, 'messages', msgId);
                    updateDoc(msgRef, { readAt: Date.now(), readBy: me.uid }).catch(() => {});
                }
                
                // Добавляем контекстное меню по правому клику
                div.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    showMessageContextMenu(e, msgId, m.senderId === me.uid, m.text, m.encrypted, m.type);
                });
                
                // Двойной клик для быстрой реакции ❤️
                div.addEventListener('dblclick', (e) => {
                    e.preventDefault();
                    addReaction(msgId, '❤️', false);
                });
                
                // Свайп вправо для ответа (мобильные)
                setupSwipeToReply(div, msgId, false);
                
                cont.appendChild(div);
                
                // Загружаем предпросмотр ссылок для текстовых сообщений
                if ((!m.type || m.type === 'text') && displayText) {
                    loadLinkPreviewForMessage(div, displayText);
                }
                
                // Автоудаление сообщения после просмотра (только для получателя)
                if (m.autoDestruct && m.autoDestruct > 0 && m.senderId !== me.uid) {
                    const chatId = [me.uid, activeChatPartner.uid].sort().join('_');
                    const msgRef = doc(db, 'artifacts', appId, 'public', 'data', 'chats', chatId, 'messages', msgId);
                    
                    let remaining;
                    
                    if (m.destructStartTime) {
                        // Таймер уже был запущен - вычисляем оставшееся время
                        const elapsed = Math.floor((Date.now() - m.destructStartTime) / 1000);
                        remaining = m.autoDestruct - elapsed;
                        
                        // Если время уже вышло - удаляем сразу
                        if (remaining <= 0) {
                            div.classList.add('message-destructing');
                            updateDoc(msgRef, { deleted: true, deletedAt: Date.now(), text: '' }).catch(() => {});
                            setTimeout(() => div.remove(), 600);
                            return;
                        }
                    } else {
                        // Первый просмотр - запускаем таймер
                        remaining = m.autoDestruct;
                        updateDoc(msgRef, { destructStartTime: Date.now() }).catch(() => {});
                    }
                    
                    // Обновляем отображение таймера
                    const timerEl = document.getElementById(`timer-${msgId}`);
                    if (timerEl) {
                        const timerValue = timerEl.querySelector('.timer-value');
                        if (timerValue) {
                            if (remaining >= 60) {
                                timerValue.textContent = Math.floor(remaining / 60) + 'м ' + (remaining % 60) + 'с';
                            } else {
                                timerValue.textContent = remaining + 'с';
                            }
                        }
                    }
                    
                    // Запускаем обратный отсчёт
                    const countdownTimer = setInterval(() => {
                        remaining--;
                        const timerElNow = document.getElementById(`timer-${msgId}`);
                        if (timerElNow) {
                            const timerValue = timerElNow.querySelector('.timer-value');
                            if (timerValue) {
                                if (remaining >= 60) {
                                    timerValue.textContent = Math.floor(remaining / 60) + 'м ' + (remaining % 60) + 'с';
                                } else {
                                    timerValue.textContent = remaining + 'с';
                                }
                            }
                        }
                        
                        if (remaining <= 0) {
                            clearInterval(countdownTimer);
                        }
                    }, 1000);
                    
                    // Удаление через оставшееся время
                    setTimeout(async () => {
                        clearInterval(countdownTimer);
                        
                        // Создаём частицы для эффекта
                        const particles = document.createElement('div');
                        particles.className = 'destruct-particles';
                        for (let i = 0; i < 8; i++) {
                            const p = document.createElement('div');
                            p.className = 'destruct-particle';
                            p.style.left = Math.random() * 100 + '%';
                            p.style.top = Math.random() * 100 + '%';
                            p.style.setProperty('--tx', (Math.random() - 0.5) * 100 + 'px');
                            p.style.setProperty('--ty', -Math.random() * 80 - 20 + 'px');
                            p.style.background = ['#6366f1', '#8b5cf6', '#ec4899'][Math.floor(Math.random() * 3)];
                            particles.appendChild(p);
                        }
                        div.style.position = 'relative';
                        div.appendChild(particles);
                        
                        // Анимация как в Telegram
                        div.classList.add('message-destructing');
                        
                        // Удаляем из Firebase
                        try {
                            await updateDoc(msgRef, { 
                                deleted: true, 
                                deletedAt: Date.now(),
                                text: ''
                            });
                        } catch(e) {
                            console.log('Auto-destruct error:', e);
                        }
                        
                        setTimeout(() => div.remove(), 600);
                    }, remaining * 1000);
                }
            });
            if(shouldScroll) cont.scrollTop = cont.scrollHeight;
        });
    };

    // ========== Контекстное меню сообщений ==========
    let currentContextMenu = null;
    
    function showMessageContextMenu(e, msgId, isOwn, text, encrypted, type) {
        // Закрываем предыдущее меню
        closeContextMenu();
        
        const menu = document.createElement('div');
        menu.className = 'msg-context-menu';
        menu.id = 'msg-context-menu';
        
        const isGroup = !!activeGroup;
        let menuItems = '';
        
        // Ответить на сообщение
        menuItems += `
            <div class="msg-context-item" onclick="event.stopPropagation(); replyToMessage('${msgId}', ${isGroup})">
                <i class="fas fa-reply"></i> ${currentLang === 'ru' ? 'Ответить' : 'Reply'}
            </div>
        `;
        
        // Переслать сообщение
        menuItems += `
            <div class="msg-context-item" onclick="event.stopPropagation(); forwardMessage('${msgId}', ${isGroup})">
                <i class="fas fa-share"></i> ${currentLang === 'ru' ? 'Переслать' : 'Forward'}
            </div>
        `;
        
        // Закрепить сообщение
        menuItems += `
            <div class="msg-context-item" onclick="event.stopPropagation(); pinMessage('${msgId}', ${isGroup})">
                <i class="fas fa-thumbtack"></i> ${currentLang === 'ru' ? 'Закрепить' : 'Pin'}
            </div>
        `;
        
        // Добавить в закладки
        menuItems += `
            <div class="msg-context-item" onclick="event.stopPropagation(); bookmarkFromContext('${msgId}', ${isGroup})">
                <i class="fas fa-bookmark text-yellow-500"></i> ${currentLang === 'ru' ? 'В закладки' : 'Bookmark'}
            </div>
        `;
        
        menuItems += `<div class="msg-context-divider"></div>`;
        
        // Кнопка реакции для всех сообщений
        menuItems += `
            <div class="msg-context-item" onclick="event.stopPropagation(); openReactionPicker('${msgId}', ${isGroup})">
                <i class="fas fa-smile"></i> ${currentLang === 'ru' ? 'Реакция' : 'React'}
            </div>
        `;
        
        // Для своих сообщений - редактирование и глобальное удаление
        if (isOwn) {
            // Редактирование только для текстовых сообщений
            if (type !== 'voice' && type !== 'file') {
                menuItems += `
                    <div class="msg-context-item" onclick="event.stopPropagation(); editMessage('${msgId}', ${encrypted})">
                        <i class="fas fa-edit"></i> ${t('editMessage')}
                    </div>
                `;
            }
            menuItems += `
                <div class="msg-context-item danger" onclick="event.stopPropagation(); deleteMessageGlobal('${msgId}')">
                    <i class="fas fa-trash"></i> ${t('deleteForAll')}
                </div>
            `;
        }
        
        // Для всех сообщений - локальное удаление
        menuItems += `
            <div class="msg-context-item" onclick="event.stopPropagation(); deleteMessageLocal('${msgId}')">
                <i class="fas fa-eye-slash"></i> ${t('deleteForMe')}
            </div>
        `;
        
        menu.innerHTML = menuItems;
        
        // Позиционируем меню
        document.body.appendChild(menu);
        
        let x = e.clientX;
        let y = e.clientY;
        
        // Проверяем, не выходит ли меню за границы экрана
        const menuRect = menu.getBoundingClientRect();
        if (x + menuRect.width > window.innerWidth) {
            x = window.innerWidth - menuRect.width - 10;
        }
        if (y + menuRect.height > window.innerHeight) {
            y = window.innerHeight - menuRect.height - 10;
        }
        
        menu.style.left = x + 'px';
        menu.style.top = y + 'px';
        
        currentContextMenu = menu;
        
        // Закрываем меню при клике вне его
        setTimeout(() => {
            document.addEventListener('click', closeContextMenu);
            document.addEventListener('contextmenu', closeContextMenu);
        }, 10);
    }
    
    // Открыть панель реакций из контекстного меню
    window.openReactionPicker = (msgId, isGroup) => {
        closeContextMenu();
        const msgEl = document.querySelector(`[data-msg-id="${msgId}"]`);
        if (msgEl) {
            showReactionPicker(msgEl, msgId, isGroup);
        }
    };
    
    // Добавить в закладки из контекстного меню
    window.bookmarkFromContext = (msgId, isGroup) => {
        closeContextMenu();
        const msgEl = document.querySelector(`[data-msg-id="${msgId}"]`);
        if (!msgEl) return;
        
        const textEl = msgEl.querySelector('.msg-text');
        const text = textEl ? textEl.innerText : '';
        const authorEl = msgEl.querySelector('.msg-author');
        const author = authorEl ? authorEl.innerText.replace('@', '') : (msgEl.classList.contains('sent') ? me.username : (activeChatPartner?.username || 'Unknown'));
        
        const chatId = isGroup ? activeGroup?.id : (activeChatPartner ? [me.uid, activeChatPartner.uid].sort().join('_') : '');
        const chatName = isGroup ? activeGroup?.name : ('@' + (activeChatPartner?.username || 'Unknown'));
        
        addBookmark({
            msgId,
            text,
            author,
            chatId,
            chatName
        });
    };
    
    function closeContextMenu() {
        if (currentContextMenu) {
            currentContextMenu.remove();
            currentContextMenu = null;
        }
        document.removeEventListener('click', closeContextMenu);
        document.removeEventListener('contextmenu', closeContextMenu);
    }
    
    // ========== Ответ на сообщение ==========
    let replyingTo = null; // { msgId, text, author, isGroup }
    
    window.replyToMessage = async (msgId, isGroup) => {
        closeContextMenu();
        
        // Получаем данные сообщения
        let msgData = null;
        if (isGroup && activeGroup) {
            const msgDoc = await getDoc(doc(db, 'artifacts', appId, 'public', 'data', 'groups', activeGroup.id, 'messages', msgId));
            msgData = msgDoc.data();
        } else if (activeChatPartner) {
            const chatId = [me.uid, activeChatPartner.uid].sort().join('_');
            const msgDoc = await getDoc(doc(db, 'artifacts', appId, 'public', 'data', 'chats', chatId, 'messages', msgId));
            msgData = msgDoc.data();
        }
        
        if (!msgData) return;
        
        let displayText = msgData.text || '';
        if (msgData.encrypted && displayText) {
            displayText = decrypt(displayText);
        }
        if (msgData.type === 'voice') displayText = '🎤 Голосовое сообщение';
        if (msgData.type === 'file') displayText = '📎 ' + (msgData.fileName || 'Файл');
        
        const authorName = msgData.senderName === 'anonymous' ? 'Аноним' : 
                          (msgData.senderId === me.uid ? 'Вы' : (isGroup ? msgData.senderName : activeChatPartner?.username || 'Пользователь'));
        
        replyingTo = {
            msgId,
            text: displayText,
            author: authorName,
            senderId: msgData.senderId,
            isGroup
        };
        
        // Показываем панель ответа
        document.getElementById('reply-panel').classList.remove('hidden');
        document.getElementById('reply-panel-author').textContent = authorName;
        document.getElementById('reply-panel-text').textContent = displayText.substring(0, 100) + (displayText.length > 100 ? '...' : '');
        
        // Фокус на поле ввода
        document.getElementById('msg-input').focus();
    };
    
    window.cancelReply = () => {
        replyingTo = null;
        document.getElementById('reply-panel').classList.add('hidden');
    };
    
    // ========== Пересылка сообщений ==========
    let forwardingMsgData = null; // Временное хранение данных для пересылки
    
    window.forwardMessage = async (msgId, isGroup) => {
        closeContextMenu();
        
        // Получаем данные сообщения
        let msgData = null;
        if (isGroup && activeGroup) {
            const msgDoc = await getDoc(doc(db, 'artifacts', appId, 'public', 'data', 'groups', activeGroup.id, 'messages', msgId));
            msgData = msgDoc.data();
        } else if (activeChatPartner) {
            const chatId = [me.uid, activeChatPartner.uid].sort().join('_');
            const msgDoc = await getDoc(doc(db, 'artifacts', appId, 'public', 'data', 'chats', chatId, 'messages', msgId));
            msgData = msgDoc.data();
        }
        
        if (!msgData) return;
        
        // Сохраняем данные для пересылки
        forwardingMsgData = msgData;
        
        // Показываем модальное окно выбора чата
        showForwardModal(msgData, isGroup);
    };
    
    function showForwardModal(msgData, fromGroup) {
        const modal = document.createElement('div');
        modal.className = 'edit-modal';
        modal.id = 'forward-modal';
        modal.onclick = (e) => { if (e.target === modal) modal.remove(); };
        
        let displayText = msgData.text || '';
        if (msgData.encrypted && displayText) displayText = decrypt(displayText);
        if (msgData.type === 'voice') displayText = '🎤 Голосовое сообщение';
        if (msgData.type === 'file') displayText = '📎 ' + (msgData.fileName || 'Файл');
        
        modal.innerHTML = `
            <div class="edit-modal-content" style="max-width: 450px; max-height: 80vh; overflow: hidden; display: flex; flex-direction: column;">
                <h3 class="text-lg font-bold mb-4"><i class="fas fa-share mr-2 text-indigo-500"></i>${currentLang === 'ru' ? 'Переслать сообщение' : 'Forward message'}</h3>
                
                <div class="p-3 bg-slate-100 dark:bg-slate-700 rounded-xl mb-4">
                    <p class="text-sm opacity-70 truncate">${displayText.substring(0, 100)}${displayText.length > 100 ? '...' : ''}</p>
                </div>
                
                <p class="text-sm font-bold mb-2">${currentLang === 'ru' ? 'Выберите чат:' : 'Select chat:'}</p>
                <div id="forward-chat-list" class="flex-1 overflow-y-auto space-y-2" style="max-height: 300px;"></div>
                
                <div class="flex gap-3 mt-4">
                    <button onclick="document.getElementById('forward-modal').remove()" class="flex-1 py-3 rounded-xl font-bold bg-slate-200 dark:bg-slate-600 hover:bg-slate-300 dark:hover:bg-slate-500 transition-all">
                        ${currentLang === 'ru' ? 'Отмена' : 'Cancel'}
                    </button>
                </div>
            </div>
        `;
        
        document.body.appendChild(modal);
        
        // Загружаем список чатов
        loadForwardChatList();
    }
    
    async function loadForwardChatList() {
        const listEl = document.getElementById('forward-chat-list');
        if (!listEl) return;
        
        listEl.innerHTML = '<div class="text-center py-4 opacity-50"><i class="fas fa-spinner fa-spin"></i></div>';
        
        const chats = [];
        
        // Загружаем личные чаты
        const chatsSnap = await getDocs(collection(db, 'artifacts', appId, 'users', me.uid, 'active_chats'));
        chatsSnap.forEach(d => {
            const data = d.data();
            chats.push({ type: 'personal', id: d.id, name: data.username, avatar: data.avatar });
        });
        
        // Загружаем группы
        const groupsSnap = await getDocs(collection(db, 'artifacts', appId, 'public', 'data', 'groups'));
        groupsSnap.forEach(d => {
            const data = d.data();
            if (data.members && data.members.includes(me.uid)) {
                chats.push({ type: 'group', id: d.id, name: data.name, avatar: data.avatar });
            }
        });
        
        if (chats.length === 0) {
            listEl.innerHTML = `<p class="text-center py-4 opacity-50">${currentLang === 'ru' ? 'Нет доступных чатов' : 'No chats available'}</p>`;
            return;
        }
        
        listEl.innerHTML = chats.map(chat => `
            <div class="flex items-center gap-3 p-3 rounded-xl hover:bg-slate-100 dark:hover:bg-slate-700 cursor-pointer transition-colors" onclick="executeForward('${chat.type}', '${chat.id}')">
                <div class="w-10 h-10 rounded-xl ${chat.type === 'group' ? 'bg-purple-100 text-purple-500' : 'bg-indigo-100 text-indigo-500'} flex items-center justify-center font-bold">
                    ${chat.avatar ? `<img src="${chat.avatar}" class="w-full h-full rounded-xl object-cover">` : (chat.type === 'group' ? '<i class="fas fa-users"></i>' : chat.name[0].toUpperCase())}
                </div>
                <div class="flex-1">
                    <p class="font-bold text-sm">${chat.name}</p>
                    <p class="text-xs opacity-50">${chat.type === 'group' ? 'Группа' : 'Личный чат'}</p>
                </div>
                <i class="fas fa-chevron-right opacity-30"></i>
            </div>
        `).join('');
    }
    
    window.executeForward = async (type, targetId) => {
        document.getElementById('forward-modal')?.remove();
        
        if (!forwardingMsgData) return;
        const msgData = forwardingMsgData;
        forwardingMsgData = null;
        
        const forwardedMsg = {
            text: msgData.text || '',
            senderId: me.uid,
            senderName: privacySettings.anonymous ? 'anonymous' : me.username,
            timestamp: serverTimestamp(),
            forwarded: true,
            forwardedFrom: msgData.senderName || 'Пользователь'
        };
        
        // Добавляем encrypted только если есть
        if (msgData.encrypted) {
            forwardedMsg.encrypted = msgData.encrypted;
        }
        
        // Добавляем type только если есть
        if (msgData.type) {
            forwardedMsg.type = msgData.type;
        }
        
        // Копируем дополнительные данные для файлов/голосовых
        if (msgData.type === 'file') {
            forwardedMsg.fileName = msgData.fileName;
            forwardedMsg.fileType = msgData.fileType;
            forwardedMsg.fileData = msgData.fileData;
        }
        if (msgData.type === 'voice') {
            forwardedMsg.voiceData = msgData.voiceData;
            forwardedMsg.voiceDuration = msgData.voiceDuration;
        }
        
        try {
            if (type === 'group') {
                await addDoc(collection(db, 'artifacts', appId, 'public', 'data', 'groups', targetId, 'messages'), forwardedMsg);
            } else {
                const chatId = [me.uid, targetId].sort().join('_');
                await addDoc(collection(db, 'artifacts', appId, 'public', 'data', 'chats', chatId, 'messages'), forwardedMsg);
            }
            
            // Показываем уведомление
            showToast(currentLang === 'ru' ? 'Сообщение переслано' : 'Message forwarded', '✅');
        } catch (e) {
            console.error('Forward error:', e);
            alert(currentLang === 'ru' ? 'Ошибка пересылки' : 'Forward error');
        }
    };
    
    // ========== Закреплённые сообщения ==========
    let currentPinnedMessage = null;
    
    window.pinMessage = async (msgId, isGroup) => {
        closeContextMenu();
        
        // Получаем данные сообщения
        let msgData = null;
        let collectionPath = '';
        
        if (isGroup && activeGroup) {
            const msgDoc = await getDoc(doc(db, 'artifacts', appId, 'public', 'data', 'groups', activeGroup.id, 'messages', msgId));
            msgData = msgDoc.data();
            collectionPath = `artifacts/${appId}/public/data/groups/${activeGroup.id}`;
        } else if (activeChatPartner) {
            const chatId = [me.uid, activeChatPartner.uid].sort().join('_');
            const msgDoc = await getDoc(doc(db, 'artifacts', appId, 'public', 'data', 'chats', chatId, 'messages', msgId));
            msgData = msgDoc.data();
            collectionPath = `artifacts/${appId}/public/data/chats/${chatId}`;
        }
        
        if (!msgData) return;
        
        let displayText = msgData.text || '';
        if (msgData.encrypted && displayText) displayText = decrypt(displayText);
        if (msgData.type === 'voice') displayText = '🎤 Голосовое сообщение';
        if (msgData.type === 'file') displayText = '📎 ' + (msgData.fileName || 'Файл');
        
        // Сохраняем закреплённое сообщение
        const pinnedData = {
            msgId,
            text: displayText,
            senderId: msgData.senderId || '',
            senderName: msgData.senderName || 'Пользователь',
            pinnedAt: serverTimestamp(),
            pinnedBy: me.uid
        };
        
        try {
            if (isGroup && activeGroup) {
                await setDoc(doc(db, 'artifacts', appId, 'public', 'data', 'groups', activeGroup.id), { pinnedMessage: pinnedData }, { merge: true });
            } else if (activeChatPartner) {
                const chatId = [me.uid, activeChatPartner.uid].sort().join('_');
                await setDoc(doc(db, 'artifacts', appId, 'public', 'data', 'pinned_messages', chatId), { pinnedMessage: pinnedData }, { merge: true });
            }
            
            showPinnedMessageBar(pinnedData);
            showToast(currentLang === 'ru' ? 'Сообщение закреплено' : 'Message pinned', '📌');
        } catch (e) {
            console.error('Pin error:', e);
        }
    };
    
    window.unpinMessage = async () => {
        const isGroup = !!activeGroup;
        
        try {
            if (isGroup && activeGroup) {
                await setDoc(doc(db, 'artifacts', appId, 'public', 'data', 'groups', activeGroup.id), { pinnedMessage: null }, { merge: true });
            } else if (activeChatPartner) {
                const chatId = [me.uid, activeChatPartner.uid].sort().join('_');
                await setDoc(doc(db, 'artifacts', appId, 'public', 'data', 'pinned_messages', chatId), { pinnedMessage: null }, { merge: true });
            }
            
            hidePinnedMessageBar();
            showToast(currentLang === 'ru' ? 'Сообщение откреплено' : 'Message unpinned', '📌');
        } catch (e) {
            console.error('Unpin error:', e);
        }
    };
    
    function showPinnedMessageBar(pinnedData) {
        currentPinnedMessage = pinnedData;
        const bar = document.getElementById('pinned-message-bar');
        const textEl = document.getElementById('pinned-message-text');
        
        if (bar && textEl) {
            textEl.textContent = pinnedData.text.substring(0, 50) + (pinnedData.text.length > 50 ? '...' : '');
            bar.classList.remove('hidden');
        }
    }
    
    function hidePinnedMessageBar() {
        currentPinnedMessage = null;
        document.getElementById('pinned-message-bar')?.classList.add('hidden');
    }
    
    window.scrollToPinnedMessage = () => {
        if (!currentPinnedMessage) return;
        
        const msgEl = document.querySelector(`[data-msg-id="${currentPinnedMessage.msgId}"]`);
        if (msgEl) {
            msgEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
            msgEl.style.animation = 'none';
            msgEl.offsetHeight; // Trigger reflow
            msgEl.style.animation = 'highlight-msg 1s ease';
        }
    };
    
    // Прокрутка к сообщению (для цитат)
    window.scrollToMessage = (msgId) => {
        const msgEl = document.querySelector(`[data-msg-id="${msgId}"]`);
        if (msgEl) {
            msgEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
            msgEl.style.animation = 'none';
            msgEl.offsetHeight;
            msgEl.style.animation = 'highlight-msg 1s ease';
        }
    };
    
    // Загрузка закреплённого сообщения при открытии чата
    async function loadPinnedMessage(isGroup) {
        hidePinnedMessageBar();
        
        try {
            let pinnedData = null;
            
            if (isGroup && activeGroup) {
                const groupDoc = await getDoc(doc(db, 'artifacts', appId, 'public', 'data', 'groups', activeGroup.id));
                pinnedData = groupDoc.data()?.pinnedMessage;
            } else if (activeChatPartner) {
                const chatId = [me.uid, activeChatPartner.uid].sort().join('_');
                const pinnedDoc = await getDoc(doc(db, 'artifacts', appId, 'public', 'data', 'pinned_messages', chatId));
                pinnedData = pinnedDoc.data()?.pinnedMessage;
            }
            
            if (pinnedData && pinnedData.msgId) {
                showPinnedMessageBar(pinnedData);
            }
        } catch (e) {
            console.error('Load pinned error:', e);
        }
    }
    
    // ========== Свайп для ответа ==========
    function setupSwipeToReply(element, msgId, isGroup) {
        let startX = 0;
        let currentX = 0;
        let isDragging = false;
        
        element.addEventListener('touchstart', (e) => {
            startX = e.touches[0].clientX;
            isDragging = true;
            element.classList.add('swiping');
        }, { passive: true });
        
        element.addEventListener('touchmove', (e) => {
            if (!isDragging) return;
            currentX = e.touches[0].clientX;
            const diff = currentX - startX;
            
            // Только свайп вправо
            if (diff > 0 && diff < 100) {
                element.style.transform = `translateX(${diff}px)`;
            }
        }, { passive: true });
        
        element.addEventListener('touchend', () => {
            if (!isDragging) return;
            isDragging = false;
            element.classList.remove('swiping');
            
            const diff = currentX - startX;
            element.style.transform = '';
            
            // Если свайп больше 60px - активируем ответ
            if (diff > 60) {
                replyToMessage(msgId, isGroup);
            }
            
            startX = 0;
            currentX = 0;
        });
    }
    
    // ========== Крестики-нолики ==========
    let activeGameId = null;
    let gameUnsub = null;
    
    window.inviteToGame = async () => {
        if (!activeChatPartner || activeGroup) {
            showToast(currentLang === 'ru' ? 'Игра доступна только в личных чатах' : 'Game only in personal chats', '🎮');
            return;
        }
        
        const chatId = [me.uid, activeChatPartner.uid].sort().join('_');
        
        // Отправляем приглашение как сообщение
        const gameId = 'game_' + Date.now();
        const gameData = {
            type: 'ttt_invite',
            gameId: gameId,
            senderId: me.uid,
            senderName: me.username,
            timestamp: serverTimestamp(),
            status: 'pending'
        };
        
        try {
            await addDoc(collection(db, 'artifacts', appId, 'public', 'data', 'chats', chatId, 'messages'), gameData);
            
            // Создаём документ игры
            await setDoc(doc(db, 'artifacts', appId, 'public', 'data', 'games', gameId), {
                chatId: chatId,
                player1: me.uid,
                player2: activeChatPartner.uid,
                player1Name: me.username,
                player2Name: activeChatPartner.username,
                board: ['', '', '', '', '', '', '', '', ''],
                currentTurn: me.uid,
                status: 'pending',
                winner: null,
                createdAt: serverTimestamp()
            });
            
            showToast(currentLang === 'ru' ? 'Приглашение отправлено!' : 'Invite sent!', '🎮');
        } catch (e) {
            console.error('Game invite error:', e);
        }
    };
    
    window.acceptGame = async (gameId) => {
        try {
            await setDoc(doc(db, 'artifacts', appId, 'public', 'data', 'games', gameId), {
                status: 'active'
            }, { merge: true });
            
            showToast(currentLang === 'ru' ? 'Игра началась!' : 'Game started!', '🎮');
        } catch (e) {
            console.error('Accept game error:', e);
        }
    };
    
    window.declineGame = async (gameId) => {
        try {
            await setDoc(doc(db, 'artifacts', appId, 'public', 'data', 'games', gameId), {
                status: 'declined'
            }, { merge: true });
        } catch (e) {
            console.error('Decline game error:', e);
        }
    };
    
    window.makeMove = async (gameId, cellIndex) => {
        const gameDoc = await getDoc(doc(db, 'artifacts', appId, 'public', 'data', 'games', gameId));
        if (!gameDoc.exists()) return;
        
        const game = gameDoc.data();
        
        // Проверяем, что это наш ход
        if (game.currentTurn !== me.uid) {
            showToast(currentLang === 'ru' ? 'Не ваш ход!' : 'Not your turn!', '⏳');
            return;
        }
        
        // Проверяем, что клетка свободна
        if (game.board[cellIndex] !== '') return;
        
        // Определяем символ игрока
        const symbol = game.player1 === me.uid ? 'X' : 'O';
        const newBoard = [...game.board];
        newBoard[cellIndex] = symbol;
        
        // Проверяем победу
        const winner = checkWinner(newBoard);
        const isDraw = !winner && newBoard.every(cell => cell !== '');
        
        const nextTurn = game.currentTurn === game.player1 ? game.player2 : game.player1;
        
        try {
            await setDoc(doc(db, 'artifacts', appId, 'public', 'data', 'games', gameId), {
                board: newBoard,
                currentTurn: nextTurn,
                status: winner ? 'finished' : (isDraw ? 'draw' : 'active'),
                winner: winner ? me.uid : null
            }, { merge: true });
        } catch (e) {
            console.error('Move error:', e);
        }
    };
    
    function checkWinner(board) {
        const lines = [
            [0, 1, 2], [3, 4, 5], [6, 7, 8], // горизонтали
            [0, 3, 6], [1, 4, 7], [2, 5, 8], // вертикали
            [0, 4, 8], [2, 4, 6] // диагонали
        ];
        
        for (const [a, b, c] of lines) {
            if (board[a] && board[a] === board[b] && board[a] === board[c]) {
                return board[a];
            }
        }
        return null;
    }
    
    function getWinningLine(board) {
        const lines = [
            [0, 1, 2], [3, 4, 5], [6, 7, 8],
            [0, 3, 6], [1, 4, 7], [2, 5, 8],
            [0, 4, 8], [2, 4, 6]
        ];
        
        for (const line of lines) {
            const [a, b, c] = line;
            if (board[a] && board[a] === board[b] && board[a] === board[c]) {
                return line;
            }
        }
        return [];
    }
    
    function renderGameMessage(m, msgId, isMine) {
        if (m.type === 'ttt_invite') {
            return `
                <div class="ttt-game" data-game-id="${m.gameId}">
                    <div class="ttt-invite">
                        <div class="ttt-invite-icon">🎮</div>
                        <div class="ttt-invite-text">
                            ${isMine 
                                ? (currentLang === 'ru' ? 'Вы пригласили в игру' : 'You invited to play')
                                : (currentLang === 'ru' ? `@${m.senderName} приглашает сыграть в крестики-нолики!` : `@${m.senderName} invites you to play Tic-Tac-Toe!`)
                            }
                        </div>
                        <div id="game-status-${m.gameId}" class="ttt-status">
                            ${currentLang === 'ru' ? 'Ожидание...' : 'Waiting...'}
                        </div>
                        ${!isMine ? `
                            <div class="ttt-actions mt-3" id="game-actions-${m.gameId}">
                                <button class="ttt-btn ttt-btn-accept" onclick="acceptGame('${m.gameId}')">
                                    ${currentLang === 'ru' ? 'Принять' : 'Accept'}
                                </button>
                                <button class="ttt-btn ttt-btn-decline" onclick="declineGame('${m.gameId}')">
                                    ${currentLang === 'ru' ? 'Отклонить' : 'Decline'}
                                </button>
                            </div>
                        ` : ''}
                    </div>
                    <div id="game-board-${m.gameId}" class="hidden"></div>
                </div>
            `;
        }
        return null;
    }
    
    function setupGameListener(gameId, gameEl) {
        const unsub = onSnapshot(doc(db, 'artifacts', appId, 'public', 'data', 'games', gameId), (snap) => {
            if (!snap.exists()) return;
            const game = snap.data();
            
            const statusEl = document.getElementById(`game-status-${gameId}`);
            const actionsEl = document.getElementById(`game-actions-${gameId}`);
            const boardEl = document.getElementById(`game-board-${gameId}`);
            
            if (!statusEl || !boardEl) return;
            
            if (game.status === 'declined') {
                statusEl.textContent = currentLang === 'ru' ? 'Отклонено' : 'Declined';
                statusEl.style.background = 'rgba(239, 68, 68, 0.1)';
                statusEl.style.color = '#ef4444';
                if (actionsEl) actionsEl.classList.add('hidden');
                return;
            }
            
            if (game.status === 'active' || game.status === 'finished' || game.status === 'draw') {
                if (actionsEl) actionsEl.classList.add('hidden');
                boardEl.classList.remove('hidden');
                
                const isMyTurn = game.currentTurn === me.uid;
                const mySymbol = game.player1 === me.uid ? 'X' : 'O';
                const winLine = getWinningLine(game.board);
                
                if (game.status === 'finished') {
                    const winnerName = game.winner === me.uid 
                        ? (currentLang === 'ru' ? 'Вы победили!' : 'You won!')
                        : (currentLang === 'ru' ? 'Вы проиграли' : 'You lost');
                    statusEl.textContent = winnerName;
                    statusEl.style.background = game.winner === me.uid ? 'rgba(34, 197, 94, 0.1)' : 'rgba(239, 68, 68, 0.1)';
                    statusEl.style.color = game.winner === me.uid ? '#22c55e' : '#ef4444';
                } else if (game.status === 'draw') {
                    statusEl.textContent = currentLang === 'ru' ? 'Ничья!' : 'Draw!';
                    statusEl.style.background = 'rgba(234, 179, 8, 0.1)';
                    statusEl.style.color = '#eab308';
                } else {
                    statusEl.textContent = isMyTurn 
                        ? (currentLang === 'ru' ? `Ваш ход (${mySymbol})` : `Your turn (${mySymbol})`)
                        : (currentLang === 'ru' ? 'Ход соперника...' : 'Opponent\'s turn...');
                }
                
                boardEl.innerHTML = `
                    <div class="ttt-board">
                        ${game.board.map((cell, i) => `
                            <div class="ttt-cell ${cell ? 'taken' : ''} ${cell.toLowerCase()} ${winLine.includes(i) ? 'win' : ''}" 
                                 onclick="${!cell && game.status === 'active' && isMyTurn ? `makeMove('${gameId}', ${i})` : ''}">
                                ${cell}
                            </div>
                        `).join('')}
                    </div>
                `;
            }
        });
        
        // Сохраняем unsub для очистки
        if (!gameEl.dataset.listening) {
            gameEl.dataset.listening = 'true';
        }
    }
    
    // ========== Статусы/Истории ==========
    let storiesUnsub = null;
    
    window.addMyStory = () => {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = 'image/*';
        input.onchange = async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            
            if (file.size > 1024 * 1024) {
                showToast(currentLang === 'ru' ? 'Максимум 1MB' : 'Max 1MB', '⚠️');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = async (ev) => {
                try {
                    await setDoc(doc(db, 'artifacts', appId, 'public', 'data', 'stories', me.uid), {
                        uid: me.uid,
                        username: me.username,
                        avatar: me.avatar || null,
                        imageData: ev.target.result,
                        createdAt: serverTimestamp(),
                        expiresAt: Date.now() + 24 * 60 * 60 * 1000, // 24 часа
                        viewedBy: []
                    });
                    showToast(currentLang === 'ru' ? 'История добавлена!' : 'Story added!', '📸');
                    loadStories();
                } catch (err) {
                    console.error('Story error:', err);
                }
            };
            reader.readAsDataURL(file);
        };
        input.click();
    };
    
    async function loadStories() {
        const container = document.getElementById('stories-container');
        if (!container || !me) return;
        
        // Сохраняем кнопку "Моя история"
        const myStoryBtn = container.querySelector('.story-item');
        container.innerHTML = '';
        if (myStoryBtn) container.appendChild(myStoryBtn);
        
        // Обновляем аватар в "Моя история"
        const myStoryAvatar = document.getElementById('my-story-avatar');
        if (myStoryAvatar && me.avatar) {
            myStoryAvatar.innerHTML = `<img src="${me.avatar}">`;
        }
        
        try {
            const storiesSnap = await getDocs(collection(db, 'artifacts', appId, 'public', 'data', 'stories'));
            const usersSnap = await getDocs(collection(db, 'artifacts', appId, 'public', 'data', 'users'));
            
            // Собираем ID удалённых пользователей
            const deletedUserIds = new Set();
            usersSnap.forEach(d => {
                if (d.data().deleted === true) {
                    deletedUserIds.add(d.id);
                }
            });
            
            const now = Date.now();
            
            storiesSnap.forEach(d => {
                const story = d.data();
                if (story.uid === me.uid) return; // Пропускаем свою историю
                if (story.expiresAt && story.expiresAt < now) return; // Истёкшие
                if (deletedUserIds.has(story.uid)) return; // Пропускаем удалённых пользователей
                
                const viewed = story.viewedBy && story.viewedBy.includes(me.uid);
                const storyEl = document.createElement('div');
                storyEl.className = 'story-item';
                storyEl.onclick = () => viewStory(story, d.id);
                storyEl.innerHTML = `
                    <div class="story-avatar ${viewed ? 'viewed' : ''}">
                        <div class="story-avatar-inner">
                            ${story.avatar ? `<img src="${story.avatar}">` : story.username[0].toUpperCase()}
                        </div>
                    </div>
                    <span class="story-name">@${story.username}</span>
                `;
                container.appendChild(storyEl);
            });
        } catch (e) {
            console.error('Load stories error:', e);
        }
    }
    
    window.viewStory = async (story, storyId) => {
        // Создаём просмотрщик
        const viewer = document.createElement('div');
        viewer.className = 'story-viewer';
        viewer.id = 'story-viewer';
        viewer.innerHTML = `
            <div class="story-viewer-header">
                <div class="story-progress">
                    <div class="story-progress-bar"><div class="story-progress-fill" id="story-progress-fill"></div></div>
                </div>
                <div class="flex items-center gap-3">
                    <div class="w-10 h-10 rounded-full bg-white/20 flex items-center justify-center overflow-hidden">
                        ${story.avatar ? `<img src="${story.avatar}" class="w-full h-full object-cover">` : `<span class="font-bold">${story.username[0].toUpperCase()}</span>`}
                    </div>
                    <div class="text-white">
                        <p class="font-bold text-sm">@${story.username}</p>
                        <p class="text-xs opacity-70">${story.createdAt ? new Date(story.createdAt.seconds * 1000).toLocaleTimeString([], {hour: '2-digit', minute: '2-digit'}) : ''}</p>
                    </div>
                    <button onclick="closeStoryViewer()" class="ml-auto w-10 h-10 rounded-full hover:bg-white/20 flex items-center justify-center text-white">
                        <i class="fas fa-times text-xl"></i>
                    </button>
                </div>
            </div>
            <div class="story-content">
                <img src="${story.imageData}" alt="Story">
            </div>
        `;
        
        document.body.appendChild(viewer);
        
        // Анимация прогресса
        const progressFill = document.getElementById('story-progress-fill');
        let progress = 0;
        const duration = 5000; // 5 секунд
        const interval = setInterval(() => {
            progress += 100 / (duration / 50);
            progressFill.style.width = progress + '%';
            if (progress >= 100) {
                clearInterval(interval);
                closeStoryViewer();
            }
        }, 50);
        
        viewer.dataset.interval = interval;
        
        // Отмечаем как просмотренную
        if (!story.viewedBy || !story.viewedBy.includes(me.uid)) {
            try {
                const viewedBy = story.viewedBy || [];
                viewedBy.push(me.uid);
                await setDoc(doc(db, 'artifacts', appId, 'public', 'data', 'stories', storyId), { viewedBy }, { merge: true });
            } catch (e) {}
        }
        
        // Закрытие по клику
        viewer.onclick = (e) => {
            if (e.target === viewer || e.target.closest('.story-content')) {
                closeStoryViewer();
            }
        };
    };
    
    window.closeStoryViewer = () => {
        const viewer = document.getElementById('story-viewer');
        if (viewer) {
            if (viewer.dataset.interval) clearInterval(parseInt(viewer.dataset.interval));
            viewer.remove();
        }
    };
    
    // ========== Стикеры и GIF ==========
    let currentStickerTab = 'stickers';
    // Используем Tenor API (Google) - более надёжный
    const TENOR_API_KEY = 'AIzaSyAyimkuYQYF_FXVALexPuGQctUWRURdCYQ'; // Public Tenor API key
    
    const stickerPacks = [
        { name: 'Смайлы', stickers: ['😀', '😂', '🥰', '😎', '🤔', '😴', '🥳', '😱', '🤯', '😇', '🤪', '😈'] },
        { name: 'Жесты', stickers: ['👍', '👎', '👋', '🤝', '👏', '🙌', '💪', '🤞', '✌️', '🤟', '👌', '🤙'] },
        { name: 'Сердца', stickers: ['❤️', '🧡', '💛', '💚', '💙', '💜', '🖤', '🤍', '💕', '💖', '💗', '💘'] },
        { name: 'Животные', stickers: ['🐶', '🐱', '🐭', '🐹', '🐰', '🦊', '🐻', '🐼', '🐨', '🐯', '🦁', '🐮'] },
        { name: 'Еда', stickers: ['🍕', '🍔', '🍟', '🌭', '🍿', '🧁', '🍩', '🍪', '🎂', '🍫', '🍬', '🍭'] }
    ];
    
    window.toggleStickers = () => {
        const panel = document.getElementById('sticker-panel');
        panel.classList.toggle('active');
        if (panel.classList.contains('active')) {
            loadStickers();
        }
    };
    
    window.switchStickerTab = function(tab) {
        currentStickerTab = tab;
        document.querySelectorAll('.sticker-tab').forEach((t, i) => {
            t.classList.remove('active');
            if ((tab === 'stickers' && i === 0) || (tab === 'gif' && i === 1)) {
                t.classList.add('active');
            }
        });
        
        if (tab === 'stickers') {
            loadStickers();
        } else {
            loadTrendingGifs();
        }
    };
    
    function loadStickers() {
        const content = document.getElementById('sticker-content');
        content.innerHTML = stickerPacks.map(pack => `
            <p class="text-xs font-bold opacity-50 mb-2 mt-3">${pack.name}</p>
            <div class="sticker-grid">
                ${pack.stickers.map(s => `
                    <div class="sticker-item" onclick="sendSticker('${s}')">
                        <span style="font-size: 32px; display: flex; align-items: center; justify-content: center; height: 100%;">${s}</span>
                    </div>
                `).join('')}
            </div>
        `).join('');
    }
    
    async function loadTrendingGifs() {
        const content = document.getElementById('sticker-content');
        content.innerHTML = '<div class="text-center py-8"><i class="fas fa-spinner fa-spin text-2xl opacity-50"></i></div>';
        
        try {
            // Tenor API v2
            const res = await fetch(`https://tenor.googleapis.com/v2/featured?key=${TENOR_API_KEY}&limit=20`);
            const data = await res.json();
            
            if (data.results && data.results.length > 0) {
                content.innerHTML = `<div class="gif-grid">
                    ${data.results.map(gif => {
                        const preview = gif.media_formats.tinygif?.url || gif.media_formats.nanogif?.url || gif.media_formats.gif?.url;
                        const full = gif.media_formats.gif?.url || gif.media_formats.mediumgif?.url || preview;
                        return `
                            <div class="gif-item" onclick="sendGif('${full}')">
                                <img src="${preview}" loading="lazy">
                            </div>
                        `;
                    }).join('')}
                </div>`;
            } else {
                content.innerHTML = '<p class="text-center py-8 opacity-50">GIF не найдены</p>';
            }
        } catch (e) {
            console.error('GIF load error:', e);
            content.innerHTML = '<p class="text-center py-8 opacity-50">Ошибка загрузки GIF</p>';
        }
    }
    
    window.searchStickersOrGif = async (query) => {
        if (!query.trim()) {
            if (currentStickerTab === 'stickers') loadStickers();
            else loadTrendingGifs();
            return;
        }
        
        if (currentStickerTab === 'gif') {
            const content = document.getElementById('sticker-content');
            content.innerHTML = '<div class="text-center py-8"><i class="fas fa-spinner fa-spin text-2xl opacity-50"></i></div>';
            
            try {
                // Tenor API v2 search
                const res = await fetch(`https://tenor.googleapis.com/v2/search?key=${TENOR_API_KEY}&q=${encodeURIComponent(query)}&limit=20`);
                const data = await res.json();
                
                if (data.results && data.results.length > 0) {
                    content.innerHTML = `<div class="gif-grid">
                        ${data.results.map(gif => {
                            const preview = gif.media_formats.tinygif?.url || gif.media_formats.nanogif?.url || gif.media_formats.gif?.url;
                            const full = gif.media_formats.gif?.url || gif.media_formats.mediumgif?.url || preview;
                            return `
                                <div class="gif-item" onclick="sendGif('${full}')">
                                    <img src="${preview}" loading="lazy">
                                </div>
                            `;
                        }).join('')}
                    </div>`;
                } else {
                    content.innerHTML = '<p class="text-center py-8 opacity-50">GIF не найдены</p>';
                }
            } catch (e) {
                console.error('GIF search error:', e);
                content.innerHTML = '<p class="text-center py-8 opacity-50">Ошибка поиска GIF</p>';
            }
        }
    };
    
    window.sendSticker = (sticker) => {
        document.getElementById('sticker-panel').classList.remove('active');
        sendMsg({ type: 'sticker', sticker: sticker });
    };
    
    window.sendGif = (gifUrl) => {
        document.getElementById('sticker-panel').classList.remove('active');
        sendMsg({ type: 'gif', gifUrl: gifUrl });
    };
    
    // ========== Реакции на сообщения ==========
    const availableReactions = ['👍', '❤️', '😂', '😮', '😢', '🔥', '👎'];
    let currentReactionPicker = null;
    
    function showReactionPicker(msgEl, msgId, isGroup = false) {
        closeReactionPicker();
        
        const picker = document.createElement('div');
        picker.className = 'reaction-picker';
        picker.id = 'reaction-picker';
        
        availableReactions.forEach(emoji => {
            const btn = document.createElement('button');
            btn.textContent = emoji;
            btn.onclick = (e) => {
                e.stopPropagation();
                addReaction(msgId, emoji, isGroup);
                closeReactionPicker();
            };
            picker.appendChild(btn);
        });
        
        msgEl.style.position = 'relative';
        msgEl.appendChild(picker);
        currentReactionPicker = picker;
        
        setTimeout(() => {
            document.addEventListener('click', closeReactionPicker);
        }, 10);
    }
    
    function closeReactionPicker() {
        if (currentReactionPicker) {
            currentReactionPicker.remove();
            currentReactionPicker = null;
        }
        document.removeEventListener('click', closeReactionPicker);
    }
    
    async function addReaction(msgId, emoji, isGroup = false) {
        if (!me) return;
        
        try {
            let msgRef;
            if (isGroup && activeGroup) {
                msgRef = doc(db, 'artifacts', appId, 'public', 'data', 'groups', activeGroup.id, 'messages', msgId);
            } else if (activeChatPartner) {
                const chatId = [me.uid, activeChatPartner.uid].sort().join('_');
                msgRef = doc(db, 'artifacts', appId, 'public', 'data', 'chats', chatId, 'messages', msgId);
            } else {
                return;
            }
            
            const msgDoc = await getDoc(msgRef);
            if (!msgDoc.exists()) return;
            
            const data = msgDoc.data();
            let reactions = data.reactions || {};
            
            // Проверяем, есть ли уже такая реакция от этого пользователя
            if (!reactions[emoji]) {
                reactions[emoji] = [];
            }
            
            const userIndex = reactions[emoji].indexOf(me.uid);
            if (userIndex > -1) {
                // Убираем реакцию
                reactions[emoji].splice(userIndex, 1);
                if (reactions[emoji].length === 0) {
                    delete reactions[emoji];
                }
            } else {
                // Добавляем реакцию
                reactions[emoji].push(me.uid);
            }
            
            await setDoc(msgRef, { reactions }, { merge: true });
        } catch (err) {
            console.error('Error adding reaction:', err);
        }
    }
    
    function renderReactions(reactions, msgId, isGroup = false) {
        if (!reactions || Object.keys(reactions).length === 0) return '';
        
        let html = '<div class="message-reactions">';
        
        for (const [emoji, users] of Object.entries(reactions)) {
            if (!users || users.length === 0) continue;
            const isMyReaction = users.includes(me?.uid);
            html += `
                <span class="reaction-badge ${isMyReaction ? 'my-reaction' : ''}" onclick="event.stopPropagation(); addReaction('${msgId}', '${emoji}', ${isGroup})">
                    ${emoji}<span class="reaction-count">${users.length}</span>
                </span>
            `;
        }
        
        html += '</div>';
        return html;
    }
    
    // Делаем функцию глобальной
    window.addReaction = addReaction;
    
    // Удаление сообщения глобально (для всех)
    window.deleteMessageGlobal = async (msgId) => {
        closeContextMenu();
        if (!activeChatPartner || !me) return;
        
        // Показываем анимацию убегающего сообщения
        const msgEl = document.querySelector(`[data-msg-id="${msgId}"]`);
        if (msgEl) {
            // Добавляем ножки
            const legs = document.createElement('div');
            legs.className = 'message-legs';
            legs.innerHTML = '<span class="leg">🦵</span><span class="leg">🦵</span>';
            msgEl.style.position = 'relative';
            msgEl.style.overflow = 'visible';
            msgEl.appendChild(legs);
            
            // Запускаем анимацию
            msgEl.classList.add('message-running-away');
        }
        
        const chatId = [me.uid, activeChatPartner.uid].sort().join('_');
        
        try {
            // Ждём немного, чтобы анимация началась
            await new Promise(r => setTimeout(r, 100));
            
            await setDoc(doc(db, 'artifacts', appId, 'public', 'data', 'chats', chatId, 'messages', msgId), {
                deleted: true,
                deletedAt: Date.now(),
                text: '',
                fileData: null,
                voiceData: null
            }, { merge: true });
        } catch (e) {
            console.error('Failed to delete message:', e);
        }
    };
    
    // Удаление сообщения локально (только у себя)
    window.deleteMessageLocal = (msgId) => {
        closeContextMenu();
        
        const deletedMsgs = JSON.parse(localStorage.getItem('flickers-deleted-msgs') || '[]');
        if (!deletedMsgs.includes(msgId)) {
            deletedMsgs.push(msgId);
            localStorage.setItem('flickers-deleted-msgs', JSON.stringify(deletedMsgs));
        }
        
        // Удаляем элемент из DOM
        const msgEl = document.querySelector(`[data-msg-id="${msgId}"]`);
        if (msgEl) {
            msgEl.style.animation = 'msg-fade-out 0.3s ease forwards';
            setTimeout(() => msgEl.remove(), 300);
        }
    };
    
    // Редактирование сообщения
    window.editMessage = async (msgId, encrypted) => {
        closeContextMenu();
        if (!activeChatPartner || !me) return;
        
        const chatId = [me.uid, activeChatPartner.uid].sort().join('_');
        
        // Получаем текущий текст сообщения
        try {
            const msgDoc = await getDoc(doc(db, 'artifacts', appId, 'public', 'data', 'chats', chatId, 'messages', msgId));
            if (!msgDoc.exists()) return;
            
            let currentText = msgDoc.data().text || '';
            if (encrypted && currentText) {
                currentText = decrypt(currentText);
            }
            
            // Показываем модальное окно редактирования
            showEditModal(msgId, currentText, encrypted);
        } catch (e) {
            console.error('Failed to get message:', e);
        }
    };
    
    function showEditModal(msgId, currentText, wasEncrypted) {
        const modal = document.createElement('div');
        modal.className = 'edit-modal';
        modal.id = 'edit-modal';
        modal.innerHTML = `
            <div class="edit-modal-content">
                <h3 class="text-lg font-bold mb-4"><i class="fas fa-edit mr-2 text-indigo-500"></i>${t('editMessageTitle')}</h3>
                <textarea id="edit-msg-input" class="w-full p-4 bg-slate-100 dark:bg-slate-700 rounded-xl outline-none resize-none h-32 focus:ring-2 focus:ring-indigo-500 transition-all">${currentText}</textarea>
                <div class="flex gap-3 mt-4">
                    <button onclick="closeEditModal()" class="flex-1 py-3 rounded-xl font-bold bg-slate-200 dark:bg-slate-600 hover:bg-slate-300 dark:hover:bg-slate-500 transition-all">
                        ${t('cancel')}
                    </button>
                    <button onclick="saveEditedMessage('${msgId}', ${wasEncrypted})" class="flex-1 py-3 rounded-xl font-bold bg-indigo-500 text-white hover:bg-indigo-600 transition-all">
                        ${t('save')}
                    </button>
                </div>
            </div>
        `;
        
        document.body.appendChild(modal);
        
        // Фокус на поле ввода
        setTimeout(() => {
            const input = document.getElementById('edit-msg-input');
            input.focus();
            input.setSelectionRange(input.value.length, input.value.length);
        }, 100);
        
        // Закрытие по клику на фон
        modal.addEventListener('click', (e) => {
            if (e.target === modal) closeEditModal();
        });
    }
    
    window.closeEditModal = () => {
        const modal = document.getElementById('edit-modal');
        if (modal) modal.remove();
    };
    
    window.saveEditedMessage = async (msgId, wasEncrypted) => {
        const input = document.getElementById('edit-msg-input');
        const newText = input.value.trim();
        
        if (!newText || !activeChatPartner || !me) {
            closeEditModal();
            return;
        }
        
        const chatId = [me.uid, activeChatPartner.uid].sort().join('_');
        
        // Шифруем если было зашифровано или включено шифрование
        const shouldEncrypt = wasEncrypted || privacySettings.encryption;
        const finalText = shouldEncrypt ? encrypt(newText) : newText;
        
        try {
            await setDoc(doc(db, 'artifacts', appId, 'public', 'data', 'chats', chatId, 'messages', msgId), {
                text: finalText,
                edited: true,
                editedAt: serverTimestamp()
            }, { merge: true });
            
            closeEditModal();
        } catch (e) {
            console.error('Failed to edit message:', e);
            alert('Error: ' + e.message);
        }
    };

    window.sendMsg = async (extraData = {}) => {
        const input = document.getElementById('msg-input');
        const text = input.value.trim();
        if ((!text && !extraData.type) || !activeChatPartner || !me) return;
        
        const chatId = [me.uid, activeChatPartner.uid].sort().join('_');
        
        // Проверяем статус чата - если новый, отправляем запрос
        if (currentChatStatus === null) {
            // Проверяем, есть ли уже сообщения
            const existingMsgs = await getDocs(query(
                collection(db, 'artifacts', appId, 'public', 'data', 'chats', chatId, 'messages'),
                limit(1)
            ));
            
            if (existingMsgs.empty) {
                // Первое сообщение - отправляем запрос на общение
                await sendChatRequest();
            }
        }
        
        // Шифруем текст если включено шифрование
        const encryptedText = privacySettings.encryption ? encrypt(text) : text;
        
        const msg = {
            text: encryptedText,
            senderId: me.uid,
            senderName: privacySettings.anonymous ? 'anonymous' : me.username,
            timestamp: serverTimestamp(),
            encrypted: privacySettings.encryption,
            autoDestruct: privacySettings.autoDestruct,
            ...extraData
        };
        
        // Добавляем данные ответа если есть
        if (replyingTo && !replyingTo.isGroup) {
            msg.replyTo = {
                msgId: replyingTo.msgId,
                text: replyingTo.text,
                author: replyingTo.author,
                senderId: replyingTo.senderId
            };
            cancelReply();
        }

        input.value = '';
        
        try {
            await addDoc(collection(db, 'artifacts', appId, 'public', 'data', 'chats', chatId, 'messages'), msg);
            
            // Начисляем рубины за отправку сообщения
            earnRubies(RUBY_PER_MESSAGE);
            
            const lastMsgText = privacySettings.encryption ? '🔒 Зашифровано' : (text || (extraData.type === 'file' ? '[Файл]' : 'Сообщение'));
            
            const updateChat = async (uid, otherId, otherName, isMe) => {
                await setDoc(doc(db, 'artifacts', appId, 'users', uid, 'active_chats', otherId), {
                    uid: otherId, 
                    username: otherName, 
                    last: lastMsgText, 
                    lastSenderId: me.uid,
                    timestamp: serverTimestamp()
                }, { merge: true });
            };
            
            // Всегда используем реальные имена в списке чатов (анонимность только в сообщениях)
            await updateChat(me.uid, activeChatPartner.uid, activeChatPartner.username, true);
            await updateChat(activeChatPartner.uid, me.uid, me.username, false);
        } catch (e) {
            console.error("Firebase Error", e);
        }
    };

    window.triggerFile = () => document.getElementById('file-input').click();
    window.handleFile = async (input) => {
        const file = input.files[0];
        if (!file) return;

        const MAX_SIZE = 150 * 1024 * 1024; // Лимит 150MB
        const STORAGE_THRESHOLD = 500 * 1024; // Файлы > 500KB загружаем в Storage
        const status = document.getElementById('upload-status');
        const pFill = document.getElementById('p-fill');
        const pPerc = document.getElementById('p-percent');
        
        if (file.size > MAX_SIZE) {
            alert("Размер файла ограничен 150 МБ.");
            input.value = '';
            return;
        }

        status.classList.remove('hidden');
        pFill.style.width = '0%';
        pPerc.innerText = '0%';
        
        try {
            if (file.size > STORAGE_THRESHOLD) {
                // Большие файлы загружаем в Firebase Storage
                const fileId = `${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                const filePath = `files/${me.uid}/${fileId}_${file.name}`;
                const storageRef = ref(storage, filePath);
                
                // Показываем прогресс загрузки
                pPerc.innerText = 'Загрузка...';
                
                // Загружаем файл
                const snapshot = await uploadBytes(storageRef, file);
                pFill.style.width = '80%';
                pPerc.innerText = '80%';
                
                // Получаем URL для скачивания
                const downloadURL = await getDownloadURL(snapshot.ref);
                pFill.style.width = '100%';
                pPerc.innerText = '100%';
                
                status.classList.add('hidden');
                
                // Отправляем сообщение с URL файла
                sendMsg({ 
                    type: 'file', 
                    fileName: file.name, 
                    fileType: file.type, 
                    fileData: downloadURL,
                    fileSize: file.size,
                    isStorageFile: true
                });
                
                showToast('Файл загружен!', '📁');
            } else {
                // Маленькие файлы конвертируем в base64
                const reader = new FileReader();
                reader.onprogress = (e) => {
                    if (e.lengthComputable) {
                        const pct = Math.round((e.loaded / e.total) * 100);
                        pFill.style.width = pct + '%';
                        pPerc.innerText = pct + '%';
                    }
                };

                reader.onload = (e) => {
                    status.classList.add('hidden');
                    sendMsg({ type: 'file', fileName: file.name, fileType: file.type, fileData: e.target.result });
                };
                reader.readAsDataURL(file);
            }
        } catch (error) {
            console.error('Upload error:', error);
            status.classList.add('hidden');
            alert('Ошибка загрузки файла: ' + error.message);
        }
        
        input.value = '';
    };

    const emojiCategories = {
        'smileys': {
            icon: '😀',
            name: 'Смайлы',
            emojis: ['😀','😃','😄','😁','😆','😅','🤣','😂','🙂','🙃','😉','😊','😇','🥰','😍','🤩','😘','😗','☺️','😚','😙','🥲','😋','😛','😜','🤪','😝','🤑','🤗','🤭','🤫','🤔','🤐','🤨','😐','😑','😶','😏','😒','🙄','😬','🤥','😌','😔','😪','🤤','😴','😷','🤒','🤕','🤢','🤮','🤧','🥵','🥶','🥴','😵','🤯','🤠','🥳','🥸','😎','🤓','🧐','😕','😟','🙁','☹️','😮','😯','😲','😳','🥺','😦','😧','😨','😰','😥','😢','😭','😱','😖','😣','😞','😓','😩','😫','🥱','😤','😡','😠','🤬','😈','👿','💀','☠️','💩','🤡','👹','👺','👻','👽','👾','🤖']
        },
        'gestures': {
            icon: '👋',
            name: 'Жесты',
            emojis: ['👋','🤚','🖐️','✋','🖖','👌','🤌','🤏','✌️','🤞','🤟','🤘','🤙','👈','👉','👆','🖕','👇','☝️','👍','👎','✊','👊','🤛','🤜','👏','🙌','👐','🤲','🤝','🙏','✍️','💅','🤳','💪','🦾','🦿','🦵','🦶','👂','🦻','👃','🧠','🫀','🫁','🦷','🦴','👀','👁️','👅','👄']
        },
        'people': {
            icon: '👶',
            name: 'Люди',
            emojis: ['👶','🧒','👦','👧','🧑','👱','👨','🧔','👩','🧓','👴','👵','🙍','🙎','🙅','🙆','💁','🙋','🧏','🙇','🤦','🤷','👮','🕵️','💂','🥷','👷','🤴','👸','👳','👲','🧕','🤵','👰','🤰','🤱','👼','🎅','🤶','🦸','🦹','🧙','🧚','🧛','🧜','🧝','🧞','🧟','💆','💇','🚶','🧍','🧎','🏃','💃','🕺','🕴️','👯','🧖','🧗','🤸','🏌️','🏇','⛷️','🏂','🏋️','🤼','🤽','🤾','🤺','⛹️','🏊','🚣','🧘','🛀','🛌']
        },
        'animals': {
            icon: '🐶',
            name: 'Животные',
            emojis: ['🐶','🐕','🦮','🐕‍🦺','🐩','🐺','🦊','🦝','🐱','🐈','🐈‍⬛','🦁','🐯','🐅','🐆','🐴','🐎','🦄','🦓','🦌','🦬','🐮','🐂','🐃','🐄','🐷','🐖','🐗','🐽','🐏','🐑','🐐','🐪','🐫','🦙','🦒','🐘','🦣','🦏','🦛','🐭','🐁','🐀','🐹','🐰','🐇','🐿️','🦫','🦔','🦇','🐻','🐻‍❄️','🐨','🐼','🦥','🦦','🦨','🦘','🦡','🐾','🦃','🐔','🐓','🐣','🐤','🐥','🐦','🐧','🕊️','🦅','🦆','🦢','🦉','🦤','🪶','🦩','🦚','🦜','🐸','🐊','🐢','🦎','🐍','🐲','🐉','🦕','🦖','🐳','🐋','🐬','🦭','🐟','🐠','🐡','🦈','🐙','🐚','🐌','🦋','🐛','🐜','🐝','🪲','🐞','🦗','🪳','🕷️','🕸️','🦂','🦟','🪰','🪱','🦠']
        },
        'food': {
            icon: '🍔',
            name: 'Еда',
            emojis: ['🍇','🍈','🍉','🍊','🍋','🍌','🍍','🥭','🍎','🍏','🍐','🍑','🍒','🍓','🫐','🥝','🍅','🫒','🥥','🥑','🍆','🥔','🥕','🌽','🌶️','🫑','🥒','🥬','🥦','🧄','🧅','🍄','🥜','🌰','🍞','🥐','🥖','🫓','🥨','🥯','🥞','🧇','🧀','🍖','🍗','🥩','🥓','🍔','🍟','🍕','🌭','🥪','🌮','🌯','🫔','🥙','🧆','🥚','🍳','🥘','🍲','🫕','🥣','🥗','🍿','🧈','🧂','🥫','🍱','🍘','🍙','🍚','🍛','🍜','🍝','🍠','🍢','🍣','🍤','🍥','🥮','🍡','🥟','🥠','🥡','🦀','🦞','🦐','🦑','🦪','🍦','🍧','🍨','🍩','🍪','🎂','🍰','🧁','🥧','🍫','🍬','🍭','🍮','🍯','🍼','🥛','☕','🫖','🍵','🍶','🍾','🍷','🍸','🍹','🍺','🍻','🥂','🥃','🥤','🧋','🧃','🧉','🧊']
        },
        'activities': {
            icon: '⚽',
            name: 'Активности',
            emojis: ['⚽','🏀','🏈','⚾','🥎','🎾','🏐','🏉','🥏','🎱','🪀','🏓','🏸','🏒','🏑','🥍','🏏','🪃','🥅','⛳','🪁','🏹','🎣','🤿','🥊','🥋','🎽','🛹','🛼','🛷','⛸️','🥌','🎿','⛷️','🏂','🪂','🏋️','🤼','🤸','🤺','⛹️','🤾','🏌️','🏇','🧘','🏄','🏊','🤽','🚣','🧗','🚴','🚵','🎖️','🏆','🏅','🥇','🥈','🥉','🎪','🤹','🎭','🩰','🎨','🎬','🎤','🎧','🎼','🎹','🥁','🪘','🎷','🎺','🪗','🎸','🪕','🎻','🎲','♟️','🎯','🎳','🎮','🕹️','🎰']
        },
        'travel': {
            icon: '🚗',
            name: 'Путешествия',
            emojis: ['🚗','🚕','🚙','🚌','🚎','🏎️','🚓','🚑','🚒','🚐','🛻','🚚','🚛','🚜','🦯','🦽','🦼','🛴','🚲','🛵','🏍️','🛺','🚨','🚔','🚍','🚘','🚖','🚡','🚠','🚟','🚃','🚋','🚞','🚝','🚄','🚅','🚈','🚂','🚆','🚇','🚊','🚉','✈️','🛫','🛬','🛩️','💺','🛰️','🚀','🛸','🚁','🛶','⛵','🚤','🛥️','🛳️','⛴️','🚢','⚓','🪝','⛽','🚧','🚦','🚥','🚏','🗺️','🗿','🗽','🗼','🏰','🏯','🏟️','🎡','🎢','🎠','⛲','⛱️','🏖️','🏝️','🏜️','🌋','⛰️','🏔️','🗻','🏕️','⛺','🛖','🏠','🏡','🏘️','🏚️','🏗️','🏭','🏢','🏬','🏣','🏤','🏥','🏦','🏨','🏪','🏫','🏩','💒','🏛️','⛪','🕌','🕍','🛕','🕋','⛩️','🛤️','🛣️','🗾','🎑','🏞️','🌅','🌄','🌠','🎇','🎆','🌇','🌆','🏙️','🌃','🌌','🌉','🌁']
        },
        'objects': {
            icon: '💡',
            name: 'Объекты',
            emojis: ['⌚','📱','📲','💻','⌨️','🖥️','🖨️','🖱️','🖲️','🕹️','🗜️','💽','💾','💿','📀','📼','📷','📸','📹','🎥','📽️','🎞️','📞','☎️','📟','📠','📺','📻','🎙️','🎚️','🎛️','🧭','⏱️','⏲️','⏰','🕰️','⌛','⏳','📡','🔋','🔌','💡','🔦','🕯️','🪔','🧯','🛢️','💸','💵','💴','💶','💷','🪙','💰','💳','💎','⚖️','🪜','🧰','🪛','🔧','🔨','⚒️','🛠️','⛏️','🪚','🔩','⚙️','🪤','🧱','⛓️','🧲','🔫','💣','🧨','🪓','🔪','🗡️','⚔️','🛡️','🚬','⚰️','🪦','⚱️','🏺','🔮','📿','🧿','💈','⚗️','🔭','🔬','🕳️','🩹','🩺','💊','💉','🩸','🧬','🦠','🧫','🧪','🌡️','🧹','🪠','🧺','🧻','🚽','🚰','🚿','🛁','🛀','🧼','🪥','🪒','🧽','🪣','🧴','🛎️','🔑','🗝️','🚪','🪑','🛋️','🛏️','🛌','🧸','🪆','🖼️','🪞','🪟','🛍️','🛒','🎁','🎈','🎏','🎀','🪄','🪅','🎊','🎉','🎎','🏮','🎐','🧧','✉️','📩','📨','📧','💌','📥','📤','📦','🏷️','🪧','📪','📫','📬','📭','📮','📯','📜','📃','📄','📑','🧾','📊','📈','📉','🗒️','🗓️','📆','📅','🗑️','📇','🗃️','🗳️','🗄️','📋','📁','📂','🗂️','🗞️','📰','📓','📔','📒','📕','📗','📘','📙','📚','📖','🔖','🧷','🔗','📎','🖇️','📐','📏','🧮','📌','📍','✂️','🖊️','🖋️','✒️','🖌️','🖍️','📝','✏️','🔍','🔎','🔏','🔐','🔒','🔓']
        },
        'symbols': {
            icon: '❤️',
            name: 'Символы',
            emojis: ['❤️','🧡','💛','💚','💙','💜','🖤','🤍','🤎','💔','❣️','💕','💞','💓','💗','💖','💘','💝','💟','☮️','✝️','☪️','🕉️','☸️','✡️','🔯','🕎','☯️','☦️','🛐','⛎','♈','♉','♊','♋','♌','♍','♎','♏','♐','♑','♒','♓','🆔','⚛️','🉑','☢️','☣️','📴','📳','🈶','🈚','🈸','🈺','🈷️','✴️','🆚','💮','🉐','㊙️','㊗️','🈴','🈵','🈹','🈲','🅰️','🅱️','🆎','🆑','🅾️','🆘','❌','⭕','🛑','⛔','📛','🚫','💯','💢','♨️','🚷','🚯','🚳','🚱','🔞','📵','🚭','❗','❕','❓','❔','‼️','⁉️','🔅','🔆','〽️','⚠️','🚸','🔱','⚜️','🔰','♻️','✅','🈯','💹','❇️','✳️','❎','🌐','💠','Ⓜ️','🌀','💤','🏧','🚾','♿','🅿️','🛗','🈳','🈂️','🛂','🛃','🛄','🛅','🚹','🚺','🚼','⚧️','🚻','🚮','🎦','📶','🈁','🔣','ℹ️','🔤','🔡','🔠','🆖','🆗','🆙','🆒','🆕','🆓','0️⃣','1️⃣','2️⃣','3️⃣','4️⃣','5️⃣','6️⃣','7️⃣','8️⃣','9️⃣','🔟','🔢','#️⃣','*️⃣','⏏️','▶️','⏸️','⏯️','⏹️','⏺️','⏭️','⏮️','⏩','⏪','⏫','⏬','◀️','🔼','🔽','➡️','⬅️','⬆️','⬇️','↗️','↘️','↙️','↖️','↕️','↔️','↪️','↩️','⤴️','⤵️','🔀','🔁','🔂','🔄','🔃','🎵','🎶','➕','➖','➗','✖️','🟰','♾️','💲','💱','™️','©️','®️','👁️‍🗨️','🔚','🔙','🔛','🔝','🔜','〰️','➰','➿','✔️','☑️','🔘','🔴','🟠','🟡','🟢','🔵','🟣','⚫','⚪','🟤','🔺','🔻','🔸','🔹','🔶','🔷','🔳','🔲','▪️','▫️','◾','◽','◼️','◻️','🟥','🟧','🟨','🟩','🟦','🟪','⬛','⬜','🟫','🔈','🔇','🔉','🔊','🔔','🔕','📣','📢','💬','💭','🗯️','♠️','♣️','♥️','♦️','🃏','🎴','🀄','🕐','🕑','🕒','🕓','🕔','🕕','🕖','🕗','🕘','🕙','🕚','🕛','🕜','🕝','🕞','🕟','🕠','🕡','🕢','🕣','🕤','🕥','🕦','🕧']
        },
        'flags': {
            icon: '🏳️',
            name: 'Флаги',
            emojis: ['🏳️','🏴','🏴‍☠️','🏁','🚩','🎌','🏳️‍🌈','🏳️‍⚧️','🇺🇳','🇦🇫','🇦🇽','🇦🇱','🇩🇿','🇦🇸','🇦🇩','🇦🇴','🇦🇮','🇦🇶','🇦🇬','🇦🇷','🇦🇲','🇦🇼','🇦🇺','🇦🇹','🇦🇿','🇧🇸','🇧🇭','🇧🇩','🇧🇧','🇧🇾','🇧🇪','🇧🇿','🇧🇯','🇧🇲','🇧🇹','🇧🇴','🇧🇦','🇧🇼','🇧🇷','🇮🇴','🇻🇬','🇧🇳','🇧🇬','🇧🇫','🇧🇮','🇰🇭','🇨🇲','🇨🇦','🇮🇨','🇨🇻','🇧🇶','🇰🇾','🇨🇫','🇹🇩','🇨🇱','🇨🇳','🇨🇽','🇨🇨','🇨🇴','🇰🇲','🇨🇬','🇨🇩','🇨🇰','🇨🇷','🇨🇮','🇭🇷','🇨🇺','🇨🇼','🇨🇾','🇨🇿','🇩🇰','🇩🇯','🇩🇲','🇩🇴','🇪🇨','🇪🇬','🇸🇻','🇬🇶','🇪🇷','🇪🇪','🇸🇿','🇪🇹','🇪🇺','🇫🇰','🇫🇴','🇫🇯','🇫🇮','🇫🇷','🇬🇫','🇵🇫','🇹🇫','🇬🇦','🇬🇲','🇬🇪','🇩🇪','🇬🇭','🇬🇮','🇬🇷','🇬🇱','🇬🇩','🇬🇵','🇬🇺','🇬🇹','🇬🇬','🇬🇳','🇬🇼','🇬🇾','🇭🇹','🇭🇳','🇭🇰','🇭🇺','🇮🇸','🇮🇳','🇮🇩','🇮🇷','🇮🇶','🇮🇪','🇮🇲','🇮🇱','🇮🇹','🇯🇲','🇯🇵','🎌','🇯🇪','🇯🇴','🇰🇿','🇰🇪','🇰🇮','🇽🇰','🇰🇼','🇰🇬','🇱🇦','🇱🇻','🇱🇧','🇱🇸','🇱🇷','🇱🇾','🇱🇮','🇱🇹','🇱🇺','🇲🇴','🇲🇬','🇲🇼','🇲🇾','🇲🇻','🇲🇱','🇲🇹','🇲🇭','🇲🇶','🇲🇷','🇲🇺','🇾🇹','🇲🇽','🇫🇲','🇲🇩','🇲🇨','🇲🇳','🇲🇪','🇲🇸','🇲🇦','🇲🇿','🇲🇲','🇳🇦','🇳🇷','🇳🇵','🇳🇱','🇳🇨','🇳🇿','🇳🇮','🇳🇪','🇳🇬','🇳🇺','🇳🇫','🇰🇵','🇲🇰','🇲🇵','🇳🇴','🇴🇲','🇵🇰','🇵🇼','🇵🇸','🇵🇦','🇵🇬','🇵🇾','🇵🇪','🇵🇭','🇵🇳','🇵🇱','🇵🇹','🇵🇷','🇶🇦','🇷🇪','🇷🇴','🇷🇺','🇷🇼','🇼🇸','🇸🇲','🇸🇹','🇸🇦','🇸🇳','🇷🇸','🇸🇨','🇸🇱','🇸🇬','🇸🇽','🇸🇰','🇸🇮','🇬🇸','🇸🇧','🇸🇴','🇿🇦','🇰🇷','🇸🇸','🇪🇸','🇱🇰','🇧🇱','🇸🇭','🇰🇳','🇱🇨','🇵🇲','🇻🇨','🇸🇩','🇸🇷','🇸🇪','🇨🇭','🇸🇾','🇹🇼','🇹🇯','🇹🇿','🇹🇭','🇹🇱','🇹🇬','🇹🇰','🇹🇴','🇹🇹','🇹🇳','🇹🇷','🇹🇲','🇹🇨','🇹🇻','🇻🇮','🇺🇬','🇺🇦','🇦🇪','🇬🇧','🏴󠁧󠁢󠁥󠁮󠁧󠁿','🏴󠁧󠁢󠁳󠁣󠁴󠁿','🏴󠁧󠁢󠁷󠁬󠁳󠁿','🇺🇸','🇺🇾','🇺🇿','🇻🇺','🇻🇦','🇻🇪','🇻🇳','🇼🇫','🇪🇭','🇾🇪','🇿🇲','🇿🇼']
        }
    };

    let currentEmojiCategory = 'smileys';

    function initEmoji() {
        const tabsContainer = document.getElementById('emoji-tabs');
        const contentContainer = document.getElementById('emoji-content');
        
        // Создаем табы
        tabsContainer.innerHTML = '';
        Object.keys(emojiCategories).forEach(key => {
            const cat = emojiCategories[key];
            const tab = document.createElement('div');
            tab.className = `emoji-tab ${key === currentEmojiCategory ? 'active' : ''}`;
            tab.innerText = cat.icon;
            tab.title = cat.name;
            tab.onclick = () => selectEmojiCategory(key);
            tabsContainer.appendChild(tab);
        });
        
        renderEmojiCategory(currentEmojiCategory);
        
        // Поиск
        document.getElementById('emoji-search-input').oninput = (e) => {
            const query = e.target.value.toLowerCase().trim();
            if (query) {
                searchEmojis(query);
            } else {
                renderEmojiCategory(currentEmojiCategory);
            }
        };
    }

    function selectEmojiCategory(key) {
        currentEmojiCategory = key;
        document.querySelectorAll('.emoji-tab').forEach((tab, i) => {
            tab.classList.toggle('active', Object.keys(emojiCategories)[i] === key);
        });
        document.getElementById('emoji-search-input').value = '';
        renderEmojiCategory(key);
    }

    function renderEmojiCategory(key) {
        const contentContainer = document.getElementById('emoji-content');
        const cat = emojiCategories[key];
        
        contentContainer.innerHTML = `
            <div class="emoji-category-title">${cat.name}</div>
            <div class="emoji-grid"></div>
        `;
        
        const grid = contentContainer.querySelector('.emoji-grid');
        cat.emojis.forEach(emoji => {
            const span = document.createElement('span');
            span.className = 'emoji-item';
            span.innerText = emoji;
            span.onclick = () => insertEmoji(emoji);
            grid.appendChild(span);
        });
    }

    function searchEmojis(query) {
        const contentContainer = document.getElementById('emoji-content');
        contentContainer.innerHTML = '<div class="emoji-category-title">Результаты поиска</div><div class="emoji-grid"></div>';
        const grid = contentContainer.querySelector('.emoji-grid');
        
        let found = false;
        Object.values(emojiCategories).forEach(cat => {
            cat.emojis.forEach(emoji => {
                if (emoji.includes(query) || cat.name.toLowerCase().includes(query)) {
                    found = true;
                    const span = document.createElement('span');
                    span.className = 'emoji-item';
                    span.innerText = emoji;
                    span.onclick = () => insertEmoji(emoji);
                    grid.appendChild(span);
                }
            });
        });
        
        if (!found) {
            contentContainer.innerHTML = '<div class="p-4 text-center text-sm opacity-50">Ничего не найдено</div>';
        }
    }

    function insertEmoji(emoji) {
        const input = document.getElementById('msg-input');
        input.value += emoji;
        input.focus();
    }
    
    window.toggleEmoji = () => document.getElementById('emoji-panel').classList.toggle('active');
    
    // Плюс-меню
    window.togglePlusMenu = () => {
        const btn = document.getElementById('plus-menu-btn');
        const menu = document.getElementById('plus-menu');
        btn.classList.toggle('active');
        menu.classList.toggle('active');
    };
    
    // Закрытие плюс-меню при клике вне
    document.addEventListener('click', (e) => {
        const container = document.querySelector('.plus-menu-container');
        if (container && !container.contains(e.target)) {
            document.getElementById('plus-menu-btn')?.classList.remove('active');
            document.getElementById('plus-menu')?.classList.remove('active');
        }
    });

    // ========== AI Assistant (Локальный - без API) ==========
    let aiResult = '';
    
    window.toggleAI = () => {
        const panel = document.getElementById('ai-panel');
        panel.classList.toggle('hidden');
        
        if (!panel.classList.contains('hidden')) {
            document.getElementById('ai-options').classList.remove('hidden');
            document.getElementById('ai-loading').classList.add('hidden');
            document.getElementById('ai-result').classList.add('hidden');
            document.getElementById('ai-result-actions').classList.add('hidden');
        }
    };
    
    // Анализ настроения сообщения
    function analyzeSentiment(text) {
        const positive = /😊|😄|❤️|🔥|👍|💯|🎉|😍|🥰|круто|класс|супер|отлично|здорово|прекрасно|замечательно|восхитительно|cool|great|awesome|nice|love|amazing|wonderful|fantastic|excellent|perfect|happy|glad/gi;
        const negative = /😢|😔|😞|💔|😭|😤|😡|плохо|грустно|ужас|отстой|дерьмо|хреново|печально|тоскливо|sad|bad|terrible|awful|hate|angry|upset|disappointed|frustrated|annoyed/gi;
        const neutral = /ок|окей|ладно|понятно|ясно|okay|ok|fine|alright|sure|got it/gi;
        
        const posMatches = (text.match(positive) || []).length;
        const negMatches = (text.match(negative) || []).length;
        const neuMatches = (text.match(neutral) || []).length;
        
        if (posMatches > negMatches && posMatches > neuMatches) return 'positive';
        if (negMatches > posMatches && negMatches > neuMatches) return 'negative';
        if (neuMatches > 0) return 'neutral';
        return 'unknown';
    }
    
    // Определение темы разговора
    function detectTopic(text) {
        const topics = {
            work: /работ|проект|задач|дедлайн|босс|коллег|офис|митинг|созвон|work|project|task|deadline|boss|colleague|office|meeting|job/i,
            study: /учёб|учеб|школ|универ|экзамен|лекци|домашк|study|school|university|exam|lecture|homework|college/i,
            gaming: /игр|играть|геймер|стрим|game|gaming|play|stream|xbox|playstation|pc|steam|twitch/i,
            food: /еда|есть|кушать|голод|ресторан|кафе|готов|рецепт|food|eat|hungry|restaurant|cafe|cook|recipe|pizza|burger/i,
            music: /музык|песн|альбом|концерт|слушать|music|song|album|concert|listen|spotify|playlist/i,
            movies: /фильм|кино|сериал|смотреть|movie|film|series|watch|netflix|cinema/i,
            travel: /путешеств|поездк|отпуск|самолёт|отель|travel|trip|vacation|flight|hotel|beach/i,
            tech: /код|программ|разработ|баг|фикс|code|programming|develop|bug|fix|software|app|website/i,
            health: /здоров|болеть|врач|спорт|тренировк|health|sick|doctor|sport|workout|gym|fitness/i,
            weather: /погод|дождь|солнц|холод|жар|снег|weather|rain|sun|cold|hot|snow/i,
            relationship: /отношени|встреч|свидани|парень|девушк|relationship|date|boyfriend|girlfriend|love/i
        };
        
        for (const [topic, regex] of Object.entries(topics)) {
            if (regex.test(text)) return topic;
        }
        return 'general';
    }
    
    // Умные ответы на основе контекста - улучшенная версия с высоким IQ
    function generateSmartReply(messages) {
        const lastMsg = (messages[messages.length - 1]?.content || '').toLowerCase();
        const prevMsgs = messages.slice(-5).map(m => m.content.toLowerCase()).join(' ');
        const isRu = currentLang === 'ru';
        const pick = arr => arr[Math.floor(Math.random() * arr.length)];
        
        // Анализ эмоций и контекста
        const sentiment = analyzeSentiment(lastMsg);
        const topic = detectTopic(lastMsg + ' ' + prevMsgs);
        const isPositive = sentiment === 'positive';
        const isNegative = sentiment === 'negative';
        const hasEmoji = /[\u{1F300}-\u{1F9FF}]/u.test(lastMsg);
        
        // Время суток для контекстных приветствий
        const hour = new Date().getHours();
        const timeOfDay = hour < 6 ? 'night' : hour < 12 ? 'morning' : hour < 18 ? 'afternoon' : 'evening';
        
        // Приветствия с учётом времени суток
        if (/привет|здравствуй|хай|hello|hi|hey|йо|здарова|салют|хелло/i.test(lastMsg)) {
            const timeGreetings = {
                morning: { ru: ['Доброе утро! ☀️', 'Утречко! 🌅 Как спалось?', 'Привет! Раненько ты! ☕'], en: ['Good morning! ☀️', 'Morning! 🌅 Sleep well?', 'Hey! You\'re up early! ☕'] },
                afternoon: { ru: ['Привет! 👋 Как день проходит?', 'Здарова! Что делаешь?', 'Приветик! 😊 Как дела?'], en: ['Hey! 👋 How\'s your day?', 'Hi there! What\'s up?', 'Hello! 😊 How are you?'] },
                evening: { ru: ['Добрый вечер! 🌆', 'Привет! Как прошёл день?', 'Вечерок! 🌙 Чем занят?'], en: ['Good evening! 🌆', 'Hey! How was your day?', 'Evening! 🌙 What\'s up?'] },
                night: { ru: ['Привет, полуночник! 🌙', 'Не спится? 😊', 'Ночной привет! 🦉'], en: ['Hey night owl! 🌙', 'Can\'t sleep? 😊', 'Late night hello! 🦉'] }
            };
            return pick(timeGreetings[timeOfDay][isRu ? 'ru' : 'en']);
        }
        
        // Как дела
        if (/как дела|как ты|как жизнь|как сам|how are you|what's up|how's it going|how you doing/i.test(lastMsg)) {
            const ru = ['Отлично, спасибо! 😊 А у тебя как?', 'Всё супер! Ты как?', 'Хорошо! Чем занимаешься?', 'Норм, работаю потихоньку. А ты?', 'Лучше всех! 🔥 Как сам?'];
            const en = ['Great, thanks! 😊 How about you?', 'Doing well! And you?', 'Good! What are you up to?', 'Pretty good, just working. You?', 'Couldn\'t be better! 🔥 How are you?'];
            return pick(isRu ? ru : en);
        }
        
        // Благодарность
        if (/спасибо|благодарю|thanks|thank you|thx|спс/i.test(lastMsg)) {
            const ru = ['Пожалуйста! 😊', 'Не за что! Обращайся!', 'Рад помочь! 👍', 'Всегда пожалуйста!', 'Без проблем! 🙌'];
            const en = ['You\'re welcome! 😊', 'No problem! Anytime!', 'Happy to help! 👍', 'Always welcome!', 'No worries! 🙌'];
            return pick(isRu ? ru : en);
        }
        
        // Прощание
        if (/пока|до свидания|bye|goodbye|see you|до встречи|удачи|бб|bb/i.test(lastMsg)) {
            const ru = ['Пока! 👋 До связи!', 'До встречи! Удачи тебе!', 'Пока-пока! 😊', 'До скорого! Береги себя!', 'Увидимся! 🙌'];
            const en = ['Bye! 👋 Talk soon!', 'See you! Good luck!', 'Bye bye! 😊', 'Later! Take care!', 'See ya! 🙌'];
            return pick(isRu ? ru : en);
        }
        
        // Извинения
        if (/извини|прости|sorry|сорри|простите|извините/i.test(lastMsg)) {
            const ru = ['Всё окей, не переживай! 😊', 'Ничего страшного!', 'Забей, бывает! 👍', 'Не парься!', 'Всё норм! 🙌'];
            const en = ['It\'s okay, don\'t worry! 😊', 'No worries at all!', 'It\'s fine, happens! 👍', 'Don\'t sweat it!', 'All good! 🙌'];
            return pick(isRu ? ru : en);
        }
        
        // Согласие/подтверждение
        if (/^(да|ага|угу|yes|yeah|yep|yup|ок|окей|okay|ok|конечно|sure|точно)$/i.test(lastMsg.trim())) {
            const ru = ['Отлично! 👍', 'Супер! 🔥', 'Класс!', 'Договорились! 🤝', 'Понял тебя!'];
            const en = ['Great! 👍', 'Awesome! 🔥', 'Cool!', 'Deal! 🤝', 'Got it!'];
            return pick(isRu ? ru : en);
        }
        
        // Отрицание
        if (/^(нет|не|неа|no|nope|nah)$/i.test(lastMsg.trim())) {
            const ru = ['Понял, окей 👌', 'Хорошо, как скажешь', 'Ладно!', 'Ок, без проблем', 'Принято!'];
            const en = ['Got it, okay 👌', 'Alright, fair enough', 'Okay!', 'Sure, no problem', 'Noted!'];
            return pick(isRu ? ru : en);
        }
        
        // Позитивные эмоции
        if (/круто|класс|супер|отлично|здорово|вау|ого|cool|awesome|great|nice|amazing|wow/i.test(lastMsg)) {
            const ru = ['Согласен! 🔥', 'Да, это реально круто!', 'Точно! 💯', 'Вообще огонь! 🔥', 'Я тоже так думаю! 😊'];
            const en = ['Agreed! 🔥', 'Yeah, that\'s really cool!', 'Exactly! 💯', 'Totally fire! 🔥', 'I think so too! 😊'];
            return pick(isRu ? ru : en);
        }
        
        // Негативные эмоции
        if (isNegative) {
            const ru = ['Не грусти! 😊 Всё наладится!', 'Держись! 💪', 'Бывает... Чем могу помочь?', 'Не переживай, всё будет хорошо! ❤️', 'Я рядом, если что! 🤗'];
            const en = ['Don\'t be sad! 😊 It\'ll get better!', 'Hang in there! 💪', 'It happens... How can I help?', 'Don\'t worry, it\'ll be okay! ❤️', 'I\'m here for you! 🤗'];
            return pick(isRu ? ru : en);
        }
        
        // Любовь/симпатия
        if (/люблю|love|нравишься|нравится|обожаю|miss you|скучаю/i.test(lastMsg)) {
            const ru = ['Это так мило! ❤️', 'Ты тоже классный! 😊', 'Взаимно! 💕', 'Ты лучший! ❤️', 'Очень приятно! 🥰'];
            const en = ['That\'s so sweet! ❤️', 'You\'re awesome too! 😊', 'Same here! 💕', 'You\'re the best! ❤️', 'So nice! 🥰'];
            return pick(isRu ? ru : en);
        }
        
        // Вопросы о времени/планах
        if (/когда|во сколько|when|what time|план|plans/i.test(lastMsg)) {
            const ru = ['Давай обсудим детали! 📅', 'Когда тебе удобно?', 'Я свободен, предлагай время!', 'Напиши когда сможешь 👍'];
            const en = ['Let\'s discuss the details! 📅', 'When works for you?', 'I\'m free, suggest a time!', 'Let me know when you can 👍'];
            return pick(isRu ? ru : en);
        }
        
        // Вопросы о месте
        if (/где|куда|where|место|place/i.test(lastMsg)) {
            const ru = ['Хороший вопрос! 🤔 Есть идеи?', 'Давай выберем вместе!', 'Предлагай варианты!', 'Мне без разницы, как тебе удобнее 👍'];
            const en = ['Good question! 🤔 Any ideas?', 'Let\'s pick together!', 'Suggest some options!', 'I\'m flexible, whatever works for you 👍'];
            return pick(isRu ? ru : en);
        }
        
        // Общие вопросы
        if (/\?|как|что|почему|зачем/.test(lastMsg)) {
            const ru = ['Хм, интересный вопрос! 🤔', 'Дай подумать...', 'Хороший вопрос! Надо разобраться', 'Сложно сказать... А ты как думаешь?', 'Интересно! 🧐'];
            const en = ['Hmm, interesting question! 🤔', 'Let me think...', 'Good question! Need to figure it out', 'Hard to say... What do you think?', 'Interesting! 🧐'];
            return pick(isRu ? ru : en);
        }
        
        // Работа/учёба
        if (/работ|учёб|учеб|школ|универ|work|job|school|study|project|проект/i.test(lastMsg)) {
            const ru = ['Как продвигается? 💪', 'Удачи с этим! 🍀', 'Ты справишься! 💪', 'Звучит интересно!', 'Держись там! 😊'];
            const en = ['How\'s it going? 💪', 'Good luck with that! 🍀', 'You got this! 💪', 'Sounds interesting!', 'Hang in there! 😊'];
            return pick(isRu ? ru : en);
        }
        
        // Еда
        if (/есть|еда|кушать|голод|food|eat|hungry|вкусн|pizza|пицца/i.test(lastMsg)) {
            const ru = ['Ммм, вкусно! 😋', 'Я тоже проголодался!', 'Отличный выбор! 🍕', 'Звучит аппетитно!', 'Приятного аппетита! 😊'];
            const en = ['Mmm, yummy! 😋', 'I\'m hungry too!', 'Great choice! 🍕', 'Sounds delicious!', 'Enjoy your meal! 😊'];
            return pick(isRu ? ru : en);
        }
        
        // Погода
        if (/погод|weather|дождь|rain|солнц|sun|холод|cold|жар|hot/i.test(lastMsg)) {
            const ru = ['Да, погода сейчас такая... 🌤️', 'Надеюсь скоро улучшится!', 'Главное настроение хорошее! 😊', 'Бывает! ☔'];
            const en = ['Yeah, the weather is like that... 🌤️', 'Hope it gets better soon!', 'Good mood is what matters! 😊', 'It happens! ☔'];
            return pick(isRu ? ru : en);
        }
        
        // Смех
        if (/ха|lol|😂|🤣|смешно|funny|laugh/i.test(lastMsg)) {
            const ru = ['😂😂😂', 'Ахахах, точно! 🤣', 'Смешно! 😄', 'Лол 😂', 'Ору! 🤣'];
            const en = ['😂😂😂', 'Hahaha, exactly! 🤣', 'Funny! 😄', 'Lol 😂', 'I\'m dying! 🤣'];
            return pick(isRu ? ru : en);
        }
        
        // Ответы на основе определённой темы разговора
        const topicResponses = {
            gaming: {
                ru: ['Во что играешь? 🎮', 'Какой у тебя ранг? �', 'Давай как-нибудь вместе поиграем!', 'Топ игра! 🔥', 'Я тоже люблю поиграть! 🎮'],
                en: ['What are you playing? 🎮', 'What\'s your rank? 💪', 'Let\'s play together sometime!', 'Great game! 🔥', 'I love gaming too! 🎮']
            },
            music: {
                ru: ['Какой жанр слушаешь? 🎵', 'Скинь плейлист! 🎧', 'Музыка - это жизнь! 🎶', 'Отличный вкус! 👌', 'Надо послушать! 🎵'],
                en: ['What genre do you listen to? 🎵', 'Share your playlist! 🎧', 'Music is life! 🎶', 'Great taste! 👌', 'Gotta check it out! 🎵']
            },
            movies: {
                ru: ['Что смотришь? 🎬', 'Какой жанр любишь?', 'Надо глянуть! 📺', 'Без спойлеров! 🤫', 'Топ сериал/фильм! 🔥'],
                en: ['What are you watching? 🎬', 'What genre do you like?', 'Gotta watch it! 📺', 'No spoilers! 🤫', 'Great show/movie! 🔥']
            },
            tech: {
                ru: ['На чём пишешь? 💻', 'Какой стек используешь?', 'Баги - это фичи! 😄', 'Код - это искусство! 🎨', 'Разберёмся! 💪'],
                en: ['What do you code in? 💻', 'What\'s your stack?', 'Bugs are features! 😄', 'Code is art! 🎨', 'We\'ll figure it out! 💪']
            },
            travel: {
                ru: ['Куда собираешься? ✈️', 'Звучит круто! 🌍', 'Хочу тоже туда!', 'Фоточки скинешь? 📸', 'Отличное место! 🏖️'],
                en: ['Where are you going? ✈️', 'Sounds amazing! 🌍', 'I wanna go there too!', 'Send pics? 📸', 'Great place! 🏖️']
            },
            health: {
                ru: ['Здоровье - главное! 💪', 'Выздоравливай! 🙏', 'Береги себя! ❤️', 'Спорт - сила! 🏋️', 'Молодец, что следишь за собой!'],
                en: ['Health is everything! 💪', 'Get well soon! 🙏', 'Take care! ❤️', 'Sports are great! 🏋️', 'Good job taking care of yourself!']
            },
            relationship: {
                ru: ['Расскажи подробнее! 👀', 'Романтика! 💕', 'Удачи вам! ❤️', 'Это так мило! 🥰', 'Держу за вас кулачки! 🤞'],
                en: ['Tell me more! 👀', 'How romantic! 💕', 'Good luck to you both! ❤️', 'That\'s so sweet! 🥰', 'Rooting for you! 🤞']
            }
        };
        
        if (topic !== 'general' && topicResponses[topic]) {
            return pick(topicResponses[topic][isRu ? 'ru' : 'en']);
        }
        
        // Если есть эмодзи - отвечаем с эмодзи
        if (hasEmoji) {
            const ru = ['😊👍', '🔥', '💯', '👌', '🙌', '❤️', '😄'];
            const en = ['😊👍', '🔥', '💯', '👌', '🙌', '❤️', '😄'];
            return pick(isRu ? ru : en);
        }
        
        // Умные ответы на основе настроения
        if (sentiment === 'positive') {
            const ru = ['Рад за тебя! 😊', 'Отлично! 🔥', 'Так держать! 💪', 'Супер! 🎉', 'Класс! 👍'];
            const en = ['Happy for you! 😊', 'Awesome! 🔥', 'Keep it up! 💪', 'Super! 🎉', 'Nice! 👍'];
            return pick(isRu ? ru : en);
        }
        
        // Общие ответы - расширенные
        const defaultRu = ['Понял тебя! 👍', 'Интересно!', 'Окей 👌', 'Хорошо!', 'Согласен!', 'Да, точно!', 'Звучит отлично!', 'Круто! 🔥', 'Ага!', 'Понятно 👍', 'Логично!', 'Принято!', 'Расскажи подробнее!', 'А что думаешь?', 'Продолжай! 👀'];
        const defaultEn = ['Got it! 👍', 'Interesting!', 'Okay 👌', 'Good!', 'Agreed!', 'Yes, exactly!', 'Sounds great!', 'Cool! 🔥', 'Yeah!', 'I see 👍', 'Makes sense!', 'Noted!', 'Tell me more!', 'What do you think?', 'Go on! 👀'];
        return pick(isRu ? defaultRu : defaultEn);
    }
    
    function improveText(text) {
        let result = text.trim();
        
        // Первая буква заглавная
        result = result.charAt(0).toUpperCase() + result.slice(1);
        
        // Убираем двойные пробелы
        result = result.replace(/\s+/g, ' ');
        
        // Исправляем частые сокращения и опечатки
        const fixes = {
            // Русские
            'спс': 'спасибо', 'пжл': 'пожалуйста', 'пжлст': 'пожалуйста', 'норм': 'нормально',
            'ок': 'окей', 'прив': 'привет', 'здр': 'здравствуй', 'пон': 'понятно',
            'оч': 'очень', 'чо': 'что', 'че': 'что', 'ща': 'сейчас', 'щас': 'сейчас',
            'тож': 'тоже', 'мб': 'может быть', 'хз': 'не знаю', 'кст': 'кстати',
            'др': 'день рождения', 'нзч': 'не за что', 'пж': 'пожалуйста',
            'лан': 'ладно', 'ясн': 'ясно', 'поч': 'почему', 'скок': 'сколько',
            // Английские
            'thx': 'thanks', 'pls': 'please', 'plz': 'please', 'u': 'you', 'r': 'are',
            'ur': 'your', 'bc': 'because', 'cuz': 'because', 'idk': "I don't know",
            'btw': 'by the way', 'rn': 'right now', 'nvm': 'never mind',
            'omg': 'oh my god', 'tbh': 'to be honest', 'imo': 'in my opinion',
            'brb': 'be right back', 'gtg': 'got to go', 'ttyl': 'talk to you later',
            'w/': 'with', 'w/o': 'without', 'b4': 'before', '2day': 'today',
            '2morrow': 'tomorrow', '2nite': 'tonight', 'gr8': 'great', 'l8r': 'later'
        };
        
        for (const [from, to] of Object.entries(fixes)) {
            result = result.replace(new RegExp(`\\b${from}\\b`, 'gi'), to);
        }
        
        // Исправляем пунктуацию
        result = result.replace(/\s+([.,!?;:])/g, '$1');
        result = result.replace(/([.,!?;:])([а-яёa-z])/gi, '$1 $2');
        
        // Убираем повторяющиеся знаки препинания
        result = result.replace(/([!?.]){2,}/g, '$1');
        
        // Добавляем точку если нет знака препинания в конце
        if (!/[.!?]$/.test(result)) result += '.';
        
        // Делаем первую букву после точки заглавной
        result = result.replace(/\.\s+([а-яёa-z])/gi, (match, letter) => '. ' + letter.toUpperCase());
        
        return result;
    }
    
    function summarizeChat(messages) {
        const count = messages.length;
        const text = messages.map(m => m.content).join(' ').toLowerCase();
        const isRu = currentLang === 'ru';
        
        // Расширенный анализ тем
        const topics = [];
        const sentiment = { positive: 0, negative: 0 };
        
        // Темы
        if (/привет|hello|hi|здравствуй/.test(text)) topics.push(isRu ? '👋 приветствие' : '👋 greeting');
        if (/пока|bye|до свидания/.test(text)) topics.push(isRu ? '👋 прощание' : '👋 farewell');
        if (/работ|work|job|проект|project|задач/.test(text)) topics.push(isRu ? '💼 работа' : '💼 work');
        if (/учёб|учеб|школ|универ|study|school/.test(text)) topics.push(isRu ? '📚 учёба' : '📚 study');
        if (/встреч|meet|план|plan|завтра|сегодня/.test(text)) topics.push(isRu ? '📅 планы' : '📅 plans');
        if (/\?/.test(text)) topics.push(isRu ? '❓ вопросы' : '❓ questions');
        if (/люблю|love|нравится|like|❤️/.test(text)) topics.push(isRu ? '❤️ чувства' : '❤️ feelings');
        if (/игр|game|играть|play/.test(text)) topics.push(isRu ? '🎮 игры' : '🎮 games');
        if (/фильм|movie|сериал|series|смотр/.test(text)) topics.push(isRu ? '🎬 кино' : '🎬 movies');
        if (/музык|music|песн|song/.test(text)) topics.push(isRu ? '🎵 музыка' : '🎵 music');
        if (/еда|food|есть|eat|вкусн/.test(text)) topics.push(isRu ? '🍕 еда' : '🍕 food');
        
        // Анализ настроения
        const positiveWords = /😊|😄|❤️|🔥|👍|круто|класс|супер|отлично|здорово|cool|great|awesome|nice|love|amazing|хорошо|рад/gi;
        const negativeWords = /😢|😔|😞|💔|плохо|грустно|ужас|sad|bad|terrible|awful|hate|скучно|устал/gi;
        
        sentiment.positive = (text.match(positiveWords) || []).length;
        sentiment.negative = (text.match(negativeWords) || []).length;
        
        let mood = '';
        if (sentiment.positive > sentiment.negative + 2) {
            mood = isRu ? '😊 Позитивное настроение' : '😊 Positive mood';
        } else if (sentiment.negative > sentiment.positive + 2) {
            mood = isRu ? '😔 Грустное настроение' : '😔 Sad mood';
        } else {
            mood = isRu ? '😐 Нейтральное настроение' : '😐 Neutral mood';
        }
        
        // Статистика
        const wordCount = text.split(/\s+/).length;
        
        if (isRu) {
            let summary = `📝 Статистика разговора:\n`;
            summary += `• Сообщений: ${count}\n`;
            summary += `• Слов: ~${wordCount}\n`;
            summary += `• ${mood}\n`;
            if (topics.length > 0) {
                summary += `\n📌 Темы: ${topics.slice(0, 5).join(', ')}`;
            } else {
                summary += `\n💬 Общение без конкретной темы`;
            }
            return summary;
        }
        
        let summary = `📝 Chat statistics:\n`;
        summary += `• Messages: ${count}\n`;
        summary += `• Words: ~${wordCount}\n`;
        summary += `• ${mood}\n`;
        if (topics.length > 0) {
            summary += `\n📌 Topics: ${topics.slice(0, 5).join(', ')}`;
        } else {
            summary += `\n💬 General conversation`;
        }
        return summary;
    }
    
    function translateText(text) {
        // Определяем язык текста
        const ruChars = (text.match(/[а-яё]/gi) || []).length;
        const enChars = (text.match(/[a-z]/gi) || []).length;
        const isRussian = ruChars > enChars;
        
        // Словарь фраз (сначала длинные, потом короткие)
        const ruToEn = {
            // Фразы
            'как дела': 'how are you', 'как ты': 'how are you', 'что делаешь': 'what are you doing',
            'доброе утро': 'good morning', 'добрый день': 'good afternoon', 'добрый вечер': 'good evening',
            'спокойной ночи': 'good night', 'до свидания': 'goodbye', 'до встречи': 'see you',
            'я тебя люблю': 'I love you', 'я тоже': 'me too', 'не знаю': "I don't know",
            'конечно': 'of course', 'может быть': 'maybe', 'не за что': "you're welcome",
            'всё хорошо': "everything is fine", 'мне нравится': 'I like it', 'я согласен': 'I agree',
            'я понял': 'I understand', 'я понимаю': 'I understand', 'подожди': 'wait',
            'скоро увидимся': 'see you soon', 'хорошего дня': 'have a nice day',
            'рад тебя видеть': 'nice to see you', 'как тебя зовут': "what's your name",
            'меня зовут': 'my name is', 'сколько времени': 'what time is it',
            'где ты': 'where are you', 'что это': 'what is this', 'почему': 'why',
            'потому что': 'because', 'я думаю': 'I think', 'мне кажется': 'I think',
            // Слова
            'привет': 'hello', 'здравствуй': 'hello', 'здравствуйте': 'hello',
            'пока': 'bye', 'да': 'yes', 'нет': 'no', 'спасибо': 'thank you', 'благодарю': 'thank you',
            'пожалуйста': 'please', 'хорошо': 'good', 'плохо': 'bad', 'отлично': 'great',
            'супер': 'super', 'круто': 'cool', 'класс': 'awesome', 'ужасно': 'terrible',
            'я': 'I', 'ты': 'you', 'он': 'he', 'она': 'she', 'мы': 'we', 'вы': 'you', 'они': 'they',
            'мой': 'my', 'твой': 'your', 'его': 'his', 'её': 'her', 'наш': 'our', 'их': 'their',
            'что': 'what', 'где': 'where', 'когда': 'when', 'как': 'how', 'кто': 'who',
            'люблю': 'love', 'хочу': 'want', 'могу': 'can', 'нужно': 'need', 'надо': 'need',
            'сегодня': 'today', 'завтра': 'tomorrow', 'вчера': 'yesterday',
            'сейчас': 'now', 'потом': 'later', 'скоро': 'soon', 'всегда': 'always', 'никогда': 'never',
            'здесь': 'here', 'там': 'there', 'дом': 'home', 'работа': 'work',
            'друг': 'friend', 'семья': 'family', 'время': 'time', 'день': 'day', 'ночь': 'night',
            'утро': 'morning', 'вечер': 'evening', 'год': 'year', 'месяц': 'month', 'неделя': 'week',
            'большой': 'big', 'маленький': 'small', 'новый': 'new', 'старый': 'old',
            'красивый': 'beautiful', 'интересный': 'interesting', 'важный': 'important',
            'быстро': 'fast', 'медленно': 'slow', 'много': 'many', 'мало': 'few',
            'есть': 'eat', 'пить': 'drink', 'спать': 'sleep', 'идти': 'go', 'делать': 'do',
            'говорить': 'speak', 'слушать': 'listen', 'смотреть': 'watch', 'читать': 'read',
            'писать': 'write', 'знать': 'know', 'думать': 'think', 'видеть': 'see',
            'окей': 'okay', 'ок': 'ok', 'лол': 'lol', 'ахах': 'haha'
        };
        
        // Создаём обратный словарь EN->RU
        const enToRu = {};
        for (const [ru, en] of Object.entries(ruToEn)) {
            enToRu[en.toLowerCase()] = ru;
        }
        // Добавляем дополнительные английские фразы
        Object.assign(enToRu, {
            'how are you': 'как дела', 'what are you doing': 'что делаешь',
            'good morning': 'доброе утро', 'good afternoon': 'добрый день', 'good evening': 'добрый вечер',
            'good night': 'спокойной ночи', 'goodbye': 'до свидания', 'see you': 'до встречи',
            'i love you': 'я тебя люблю', 'me too': 'я тоже', "i don't know": 'не знаю',
            'of course': 'конечно', 'maybe': 'может быть', "you're welcome": 'не за что',
            'hello': 'привет', 'hi': 'привет', 'hey': 'привет', 'bye': 'пока',
            'yes': 'да', 'no': 'нет', 'thank you': 'спасибо', 'thanks': 'спасибо',
            'please': 'пожалуйста', 'good': 'хорошо', 'bad': 'плохо', 'great': 'отлично',
            'cool': 'круто', 'awesome': 'класс', 'nice': 'классно', 'wow': 'вау',
            'i': 'я', 'you': 'ты', 'he': 'он', 'she': 'она', 'we': 'мы', 'they': 'они',
            'my': 'мой', 'your': 'твой', 'his': 'его', 'her': 'её', 'our': 'наш', 'their': 'их',
            'what': 'что', 'where': 'где', 'when': 'когда', 'how': 'как', 'who': 'кто', 'why': 'почему',
            'love': 'люблю', 'want': 'хочу', 'can': 'могу', 'need': 'нужно',
            'today': 'сегодня', 'tomorrow': 'завтра', 'yesterday': 'вчера',
            'now': 'сейчас', 'later': 'потом', 'soon': 'скоро', 'always': 'всегда', 'never': 'никогда',
            'here': 'здесь', 'there': 'там', 'home': 'дом', 'work': 'работа',
            'friend': 'друг', 'family': 'семья', 'time': 'время', 'day': 'день', 'night': 'ночь',
            'okay': 'окей', 'ok': 'ок', 'lol': 'лол', 'haha': 'ахах', 'yeah': 'да', 'yep': 'да', 'nope': 'нет',
            'sorry': 'извини', 'wait': 'подожди', 'stop': 'стоп', 'go': 'иди',
            'like': 'нравится', 'think': 'думаю', 'know': 'знаю', 'see': 'вижу',
            'morning': 'утро', 'evening': 'вечер', 'afternoon': 'день'
        });
        
        const dict = isRussian ? ruToEn : enToRu;
        let result = text.toLowerCase();
        
        // Сортируем по длине (сначала длинные фразы)
        const sorted = Object.entries(dict).sort((a, b) => b[0].length - a[0].length);
        
        for (const [from, to] of sorted) {
            const regex = new RegExp(from.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi');
            result = result.replace(regex, to);
        }
        
        // Первая буква заглавная
        result = result.charAt(0).toUpperCase() + result.slice(1);
        
        return result;
    }
    
    function showAILoading() {
        document.getElementById('ai-options').classList.add('hidden');
        document.getElementById('ai-loading').classList.remove('hidden');
        document.getElementById('ai-result').classList.add('hidden');
        document.getElementById('ai-result-actions').classList.add('hidden');
    }
    
    function showAIResult(text) {
        aiResult = text;
        document.getElementById('ai-loading').classList.add('hidden');
        document.getElementById('ai-result').classList.remove('hidden');
        document.getElementById('ai-result').innerText = text;
        document.getElementById('ai-result-actions').classList.remove('hidden');
    }
    
    function getLastMessages(count = 10) {
        const container = document.getElementById('messages-container');
        const messages = [];
        const bubbles = container.querySelectorAll('.message-bubble');
        
        Array.from(bubbles).slice(-count).forEach(bubble => {
            const text = bubble.querySelector('p')?.innerText || '';
            const isSent = bubble.classList.contains('sent');
            if (text && !text.includes('Сообщение удалено')) {
                messages.push({ role: isSent ? 'user' : 'assistant', content: text });
            }
        });
        return messages;
    }
    
    window.aiGenerateReply = async () => {
        const msgs = getLastMessages(5);
        if (msgs.length === 0) { alert(t('aiNoMessages')); return; }
        
        showAILoading();
        setTimeout(() => {
            showAIResult(generateSmartReply(msgs));
        }, 300 + Math.random() * 400);
    };
    
    window.aiImproveText = async () => {
        const text = document.getElementById('msg-input').value.trim();
        if (!text) { alert(t('aiEnterText')); return; }
        
        showAILoading();
        setTimeout(() => {
            showAIResult(improveText(text));
        }, 200 + Math.random() * 300);
    };
    
    window.aiSummarize = async () => {
        const msgs = getLastMessages(20);
        if (msgs.length < 2) { alert(t('aiNoMessages')); return; }
        
        showAILoading();
        setTimeout(() => {
            showAIResult(summarizeChat(msgs));
        }, 300 + Math.random() * 400);
    };
    
    window.aiTranslate = async () => {
        let text = document.getElementById('msg-input').value.trim();
        if (!text) {
            const last = getLastMessages(5).filter(m => m.role === 'assistant').pop();
            if (last) text = last.content;
        }
        if (!text) { alert(t('aiEnterText')); return; }
        
        showAILoading();
        setTimeout(() => {
            showAIResult(translateText(text));
        }, 200 + Math.random() * 300);
    };
    
    window.aiUseResult = () => {
        document.getElementById('msg-input').value = aiResult;
        document.getElementById('msg-input').focus();
        toggleAI();
    };
    
    window.aiCopyResult = () => {
        navigator.clipboard.writeText(aiResult).then(() => alert(t('aiCopied')));
    };


    // ========== Голосовые сообщения ==========
    let mediaRecorder = null;
    let audioChunks = [];
    let voiceTimerInterval = null;
    let voiceStartTime = null;
    let isRecording = false;

    window.startVoice = async () => {
        if (isRecording || !activeChatPartner) return;
        
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            mediaRecorder = new MediaRecorder(stream);
            audioChunks = [];
            
            mediaRecorder.ondataavailable = (e) => {
                if (e.data.size > 0) audioChunks.push(e.data);
            };
            
            mediaRecorder.onstop = async () => {
                stream.getTracks().forEach(track => track.stop());
                
                if (audioChunks.length > 0 && isRecording) {
                    const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                    
                    // Проверяем размер (лимит 1MB)
                    if (audioBlob.size > 1 * 1024 * 1024) {
                        alert('Голосовое сообщение слишком длинное (макс ~1 минута)');
                        resetVoiceUI();
                        return;
                    }
                    
                    const reader = new FileReader();
                    reader.onload = () => {
                        const duration = Math.floor((Date.now() - voiceStartTime) / 1000);
                        sendMsg({ 
                            type: 'voice', 
                            voiceData: reader.result,
                            voiceDuration: duration
                        });
                    };
                    reader.readAsDataURL(audioBlob);
                }
                
                resetVoiceUI();
            };
            
            mediaRecorder.start();
            isRecording = true;
            
            document.getElementById('voice-btn').classList.add('recording');
            document.getElementById('msg-input').classList.add('hidden');
            document.getElementById('voice-recording-ui').classList.remove('hidden');
            
            voiceStartTime = Date.now();
            voiceTimerInterval = setInterval(() => {
                const elapsed = Math.floor((Date.now() - voiceStartTime) / 1000);
                const mins = Math.floor(elapsed / 60);
                const secs = elapsed % 60;
                document.getElementById('voice-timer').innerText = `${mins}:${secs.toString().padStart(2, '0')}`;
            }, 1000);
            
        } catch (err) {
            console.error('Ошибка записи:', err);
            alert('Не удалось получить доступ к микрофону');
        }
    };

    window.stopVoice = () => {
        if (mediaRecorder && mediaRecorder.state === 'recording') {
            mediaRecorder.stop();
        }
    };

    window.cancelVoice = () => {
        isRecording = false;
        audioChunks = [];
        if (mediaRecorder && mediaRecorder.state === 'recording') {
            mediaRecorder.stop();
        }
        resetVoiceUI();
    };

    function resetVoiceUI() {
        isRecording = false;
        document.getElementById('voice-btn').classList.remove('recording');
        document.getElementById('msg-input').classList.remove('hidden');
        document.getElementById('voice-recording-ui').classList.add('hidden');
        document.getElementById('voice-timer').innerText = '0:00';
        
        if (voiceTimerInterval) {
            clearInterval(voiceTimerInterval);
            voiceTimerInterval = null;
        }
    }

    // ========== Видео-кружки (как в Telegram) ==========
    let videoCircleStream = null;
    let videoCircleRecorder = null;
    let videoCircleChunks = [];
    let videoCircleTimer = null;
    let videoCircleSeconds = 0;
    const MAX_VIDEO_CIRCLE_DURATION = 60; // максимум 60 секунд

    window.openVideoCircle = async () => {
        if (!activeChatPartner) {
            showToast('Сначала выберите чат', '❌');
            return;
        }

        try {
            // Запрашиваем доступ к камере и микрофону
            videoCircleStream = await navigator.mediaDevices.getUserMedia({
                video: { facingMode: 'user', width: 480, height: 480 },
                audio: true
            });

            // Создаём оверлей для записи
            const overlay = document.createElement('div');
            overlay.className = 'video-circle-overlay';
            overlay.id = 'video-circle-overlay';
            overlay.innerHTML = `
                <div class="video-circle-preview">
                    <video id="video-circle-preview" autoplay muted playsinline></video>
                    <div class="video-circle-timer">
                        <span id="video-circle-time">0:00</span> / 1:00
                    </div>
                </div>
                <p class="text-white mt-4 text-sm opacity-70">Запись начнётся автоматически</p>
                <div class="video-circle-controls">
                    <button class="video-circle-cancel" onclick="cancelVideoCircle()">
                        <i class="fas fa-times"></i>
                    </button>
                    <button class="video-circle-send" onclick="sendVideoCircle()">
                        <i class="fas fa-paper-plane"></i>
                    </button>
                </div>
            `;
            document.body.appendChild(overlay);

            // Показываем превью
            const preview = document.getElementById('video-circle-preview');
            preview.srcObject = videoCircleStream;

            // Начинаем запись
            videoCircleChunks = [];
            videoCircleRecorder = new MediaRecorder(videoCircleStream, {
                mimeType: MediaRecorder.isTypeSupported('video/webm;codecs=vp9') 
                    ? 'video/webm;codecs=vp9' 
                    : 'video/webm'
            });

            videoCircleRecorder.ondataavailable = (e) => {
                if (e.data.size > 0) {
                    videoCircleChunks.push(e.data);
                }
            };

            videoCircleRecorder.start(100);

            // Запускаем таймер
            videoCircleSeconds = 0;
            videoCircleTimer = setInterval(() => {
                videoCircleSeconds++;
                const mins = Math.floor(videoCircleSeconds / 60);
                const secs = videoCircleSeconds % 60;
                document.getElementById('video-circle-time').textContent = 
                    `${mins}:${secs.toString().padStart(2, '0')}`;

                // Автоматически останавливаем после 60 секунд
                if (videoCircleSeconds >= MAX_VIDEO_CIRCLE_DURATION) {
                    sendVideoCircle();
                }
            }, 1000);

        } catch (err) {
            console.error('Ошибка доступа к камере:', err);
            showToast('Не удалось получить доступ к камере', '❌');
        }
    };

    window.cancelVideoCircle = () => {
        cleanupVideoCircle();
        const overlay = document.getElementById('video-circle-overlay');
        if (overlay) overlay.remove();
    };

    let isSendingVideoCircle = false;

    window.sendVideoCircle = async () => {
        if (isSendingVideoCircle) return;
        isSendingVideoCircle = true;
        
        // Останавливаем таймер
        if (videoCircleTimer) {
            clearInterval(videoCircleTimer);
            videoCircleTimer = null;
        }

        const duration = videoCircleSeconds;

        if (!videoCircleRecorder) {
            isSendingVideoCircle = false;
            cancelVideoCircle();
            return;
        }

        try {
            // СНАЧАЛА останавливаем запись и ждём данные (пока стрим ещё активен!)
            if (videoCircleRecorder.state === 'recording') {
                await new Promise((resolve) => {
                    videoCircleRecorder.onstop = resolve;
                    videoCircleRecorder.stop();
                });
            }

            // Теперь закрываем UI и останавливаем камеру
            const overlay = document.getElementById('video-circle-overlay');
            if (overlay) overlay.remove();
            
            if (videoCircleStream) {
                videoCircleStream.getTracks().forEach(track => track.stop());
                videoCircleStream = null;
            }

            // Создаём blob
            const blob = new Blob(videoCircleChunks, { type: 'video/webm' });
            
            if (blob.size === 0) {
                showToast('Видео пустое', '❌');
                return;
            }
            
            if (blob.size > 4 * 1024 * 1024) {
                showToast('Видео слишком большое', '❌');
                return;
            }

            // Конвертируем в base64
            const base64 = await new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsDataURL(blob);
            });

            // Отправляем сообщение
            const chatId = [me.uid, activeChatPartner.uid].sort().join('_');
            await addDoc(collection(db, 'artifacts', appId, 'public', 'data', 'chats', chatId, 'messages'), {
                type: 'video_circle',
                senderId: me.uid,
                senderName: me.username,
                videoData: base64,
                videoDuration: duration,
                timestamp: serverTimestamp()
            });

            // Начисляем рубины
            me.rubies = (me.rubies || 0) + RUBY_PER_MESSAGE;
            await setDoc(doc(db, 'artifacts', appId, 'public', 'data', 'users', me.uid), {
                rubies: me.rubies
            }, { merge: true });
            updateRubiesDisplay();

            showToast('Кружок отправлен!', '🎥');
        } catch (e) {
            console.error('Ошибка отправки кружка:', e);
            showToast('Ошибка отправки', '❌');
            // Закрываем UI при ошибке
            const overlay = document.getElementById('video-circle-overlay');
            if (overlay) overlay.remove();
        }
        
        isSendingVideoCircle = false;
        videoCircleRecorder = null;
        videoCircleChunks = [];
        videoCircleSeconds = 0;
    };

    function cleanupVideoCircle() {
        if (videoCircleTimer) {
            clearInterval(videoCircleTimer);
            videoCircleTimer = null;
        }
        if (videoCircleStream) {
            videoCircleStream.getTracks().forEach(track => track.stop());
            videoCircleStream = null;
        }
        if (videoCircleRecorder && videoCircleRecorder.state === 'recording') {
            videoCircleRecorder.stop();
        }
        videoCircleRecorder = null;
        videoCircleChunks = [];
        videoCircleSeconds = 0;
    }

    // Воспроизведение видео-кружка
    window.playVideoCircle = (videoEl) => {
        // Останавливаем все другие видео-кружки
        document.querySelectorAll('.video-circle-message video').forEach(v => {
            if (v !== videoEl) {
                v.pause();
                v.currentTime = 0;
            }
        });

        if (videoEl.paused) {
            videoEl.play();
            videoEl.style.border = '3px solid #22c55e';
        } else {
            videoEl.pause();
            videoEl.style.border = '3px solid var(--accent)';
        }
    };

    // ========== Предпросмотр ссылок ==========
    const linkPreviewCache = new Map();
    
    // Извлечение URL из текста
    function extractUrls(text) {
        const urlRegex = /(https?:\/\/[^\s<>"{}|\\^`\[\]]+)/gi;
        return text.match(urlRegex) || [];
    }
    
    // Преобразование URL в кликабельные ссылки
    function linkifyText(text) {
        const urlRegex = /(https?:\/\/[^\s<>"{}|\\^`\[\]]+)/gi;
        return text.replace(urlRegex, (url) => {
            return `<a href="${url}" target="_blank" rel="noopener noreferrer" class="text-blue-400 hover:underline" onclick="event.stopPropagation()">${url}</a>`;
        });
    }
    
    // Получение метаданных ссылки через прокси
    async function fetchLinkPreview(url) {
        // Проверяем кэш
        if (linkPreviewCache.has(url)) {
            return linkPreviewCache.get(url);
        }
        
        try {
            // Используем бесплатный API для получения метаданных
            const proxyUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`;
            const response = await fetch(proxyUrl, { 
                signal: AbortSignal.timeout(5000)
            });
            
            if (!response.ok) return null;
            
            const html = await response.text();
            const parser = new DOMParser();
            const doc = parser.parseFromString(html, 'text/html');
            
            // Извлекаем метаданные
            const getMetaContent = (name) => {
                const meta = doc.querySelector(`meta[property="${name}"], meta[name="${name}"]`);
                return meta ? meta.getAttribute('content') : null;
            };
            
            const preview = {
                url: url,
                title: getMetaContent('og:title') || doc.querySelector('title')?.textContent || '',
                description: getMetaContent('og:description') || getMetaContent('description') || '',
                image: getMetaContent('og:image') || '',
                siteName: getMetaContent('og:site_name') || new URL(url).hostname.replace('www.', '')
            };
            
            // Исправляем относительные URL изображений
            if (preview.image && !preview.image.startsWith('http')) {
                const baseUrl = new URL(url);
                preview.image = preview.image.startsWith('/') 
                    ? `${baseUrl.origin}${preview.image}`
                    : `${baseUrl.origin}/${preview.image}`;
            }
            
            // Кэшируем результат
            linkPreviewCache.set(url, preview);
            
            return preview;
        } catch (e) {
            console.log('Link preview error:', e);
            return null;
        }
    }
    
    // Рендеринг превью ссылки
    function renderLinkPreview(preview) {
        if (!preview || (!preview.title && !preview.description)) return '';
        
        const imageHtml = preview.image 
            ? `<img src="${preview.image}" class="link-preview-image" onerror="this.style.display='none'" loading="lazy">` 
            : '';
        
        return `
            <div class="link-preview" onclick="window.open('${preview.url}', '_blank')">
                ${imageHtml}
                <div class="link-preview-site">${preview.siteName}</div>
                ${preview.title ? `<div class="link-preview-title">${preview.title}</div>` : ''}
                ${preview.description ? `<div class="link-preview-description">${preview.description}</div>` : ''}
            </div>
        `;
    }
    
    // Загрузка превью для сообщения
    async function loadLinkPreviewForMessage(msgElement, text) {
        const urls = extractUrls(text);
        if (urls.length === 0) return;
        
        // Берём только первую ссылку
        const url = urls[0];
        const preview = await fetchLinkPreview(url);
        
        if (preview && msgElement) {
            const previewHtml = renderLinkPreview(preview);
            if (previewHtml) {
                const previewContainer = document.createElement('div');
                previewContainer.innerHTML = previewHtml;
                const textEl = msgElement.querySelector('p');
                if (textEl) {
                    textEl.insertAdjacentElement('afterend', previewContainer.firstElementChild);
                }
            }
        }
    }

    // Глобальный объект для управления воспроизведением
    let currentPlayingAudio = null;

    window.playVoice = (btn, audioData, duration) => {
        // Останавливаем предыдущее воспроизведение
        if (currentPlayingAudio) {
            currentPlayingAudio.pause();
            currentPlayingAudio.currentTime = 0;
            document.querySelectorAll('.voice-play-btn').forEach(b => {
                b.innerHTML = '<i class="fas fa-play"></i>';
            });
        }
        
        const audio = new Audio(audioData);
        const progressFill = btn.parentElement.querySelector('.voice-progress-fill');
        const timeDisplay = btn.parentElement.querySelector('.voice-time');
        
        if (currentPlayingAudio === audio) {
            currentPlayingAudio = null;
            return;
        }
        
        currentPlayingAudio = audio;
        btn.innerHTML = '<i class="fas fa-pause"></i>';
        
        audio.ontimeupdate = () => {
            const progress = (audio.currentTime / audio.duration) * 100;
            progressFill.style.width = progress + '%';
            const remaining = Math.ceil(audio.duration - audio.currentTime);
            timeDisplay.innerText = `0:${remaining.toString().padStart(2, '0')}`;
        };
        
        audio.onended = () => {
            btn.innerHTML = '<i class="fas fa-play"></i>';
            progressFill.style.width = '0%';
            timeDisplay.innerText = `0:${duration.toString().padStart(2, '0')}`;
            currentPlayingAudio = null;
        };
        
        audio.play();
    };

    window.handleNicknameSearch = async (val) => {
        console.log('Search called with:', val);
        val = val.trim().toLowerCase();
        const res = document.getElementById('nickname-search-results');
        if (val.length < 1) { res.classList.add('hidden'); return; }
        
        console.log('Searching for:', val);
        const snap = await getDocs(collection(db, 'artifacts', appId, 'public', 'data', 'users'));
        console.log('Found users:', snap.size);
        res.innerHTML = '';
        res.classList.remove('hidden');
        
        let found = false;
        snap.forEach(d => {
            const u = { uid: d.id, ...d.data() };
            // Пропускаем удалённых пользователей и себя
            if (u.deleted) return;
            if (u.username && u.username.toLowerCase().includes(val) && u.uid !== me?.uid) {
                found = true;
                const div = document.createElement('div');
                div.className = "p-4 hover:bg-indigo-500/10 cursor-pointer text-sm font-bold flex items-center justify-between group";
                div.innerHTML = `
                    <div class="flex items-center space-x-3">
                        <div class="w-8 h-8 rounded-lg bg-indigo-500 text-white flex items-center justify-center">${u.username[0]}</div>
                        <span>@${u.username}</span>
                    </div>
                `;
                div.onclick = () => { 
                    selectChat(u); 
                    res.classList.add('hidden'); 
                    document.getElementById('search-input').value = ''; 
                };
                res.appendChild(div);
            }
        });
        if(!found) res.innerHTML = '<div class="p-4 text-center text-xs opacity-50 italic">Никто не найден</div>';
    };

    window.toggleSettings = () => {
        document.getElementById('settings-panel').classList.toggle('active');
        if (me) {
            document.getElementById('settings-username').innerText = '@' + me.username;
            updateSettingsAvatar();
            loadBio();
            loadProfileSettings();
            loadFrameAndStyleSettings();
        }
    };
    
    // Загрузка био
    async function loadBio() {
        if (!me) return;
        const bioInput = document.getElementById('settings-bio');
        const bioCounter = document.getElementById('bio-counter');
        if (!bioInput) return;
        
        try {
            const userDoc = await getDoc(doc(db, 'artifacts', appId, 'public', 'data', 'users', me.uid));
            if (userDoc.exists() && userDoc.data().bio) {
                bioInput.value = userDoc.data().bio;
                if (bioCounter) bioCounter.textContent = bioInput.value.length;
            }
        } catch (e) {}
        
        // Счётчик символов
        bioInput.oninput = () => {
            if (bioCounter) bioCounter.textContent = bioInput.value.length;
        };
    }
    
    // Сохранение био
    window.saveBio = async () => {
        if (!me) return;
        const bioInput = document.getElementById('settings-bio');
        if (!bioInput) return;
        
        try {
            await setDoc(doc(db, 'artifacts', appId, 'public', 'data', 'users', me.uid), {
                bio: bioInput.value.trim()
            }, { merge: true });
            showToast(currentLang === 'ru' ? 'Описание сохранено' : 'Bio saved', '✅');
        } catch (e) {
            console.error('Error saving bio:', e);
        }
    };
    
    // Загрузка настроек профиля (пол, скрытие)
    async function loadProfileSettings() {
        if (!me) return;
        
        try {
            const userDoc = await getDoc(doc(db, 'artifacts', appId, 'public', 'data', 'users', me.uid));
            if (userDoc.exists()) {
                const data = userDoc.data();
                
                // Пол
                document.querySelectorAll('[id^="gender-"]').forEach(btn => {
                    btn.classList.remove('bg-indigo-500', 'text-white', 'border-indigo-500');
                });
                if (data.gender) {
                    const genderBtn = document.getElementById('gender-' + data.gender);
                    if (genderBtn) {
                        genderBtn.classList.add('bg-indigo-500', 'text-white', 'border-indigo-500');
                    }
                }
                
                // Скрытие профиля
                const hideToggle = document.getElementById('hide-profile-toggle');
                if (hideToggle) {
                    hideToggle.checked = data.profileHidden === true;
                }
            }
        } catch (e) {}
    }
    
    // Установка пола
    window.setGender = async (gender) => {
        if (!me) return;
        
        document.querySelectorAll('[id^="gender-"]').forEach(btn => {
            btn.classList.remove('bg-indigo-500', 'text-white', 'border-indigo-500');
        });
        document.getElementById('gender-' + gender)?.classList.add('bg-indigo-500', 'text-white', 'border-indigo-500');
        
        try {
            await setDoc(doc(db, 'artifacts', appId, 'public', 'data', 'users', me.uid), {
                gender: gender
            }, { merge: true });
            showToast(currentLang === 'ru' ? 'Пол сохранён' : 'Gender saved', '✅');
        } catch (e) {}
    };
    
    // Скрытие профиля
    window.toggleHideProfile = async () => {
        if (!me) return;
        const hideToggle = document.getElementById('hide-profile-toggle');
        
        try {
            await setDoc(doc(db, 'artifacts', appId, 'public', 'data', 'users', me.uid), {
                profileHidden: hideToggle.checked
            }, { merge: true });
            showToast(hideToggle.checked ? 
                (currentLang === 'ru' ? 'Профиль скрыт' : 'Profile hidden') : 
                (currentLang === 'ru' ? 'Профиль виден' : 'Profile visible'), '✅');
        } catch (e) {}
    };
    
    // Цены на рамки и стили
    const framePrices = {
        'none': 0,
        'rainbow': 50,
        'gold': 75,
        'neon': 100,
        'fire': 100,
        'purple': 75,
        'emerald': 75,
        'diamond': 150
    };
    
    const frameNames = {
        'none': 'Без рамки',
        'rainbow': 'Радужная',
        'gold': 'Золотая',
        'neon': 'Неоновая',
        'fire': 'Огненная',
        'purple': 'Фиолетовая',
        'emerald': 'Изумрудная',
        'diamond': 'Бриллиантовая'
    };
    
    const stylePrices = {
        'default': 0,
        'gradient': 100,
        'neon': 150,
        'glass': 200
    };
    
    const styleNames = {
        'default': 'Стандартное',
        'gradient': 'Градиент',
        'neon': 'Неон',
        'glass': 'Стекло'
    };
    
    // Выбор рамки аватара
    window.selectAvatarFrame = async (frame) => {
        if (!me) return;
        
        const price = framePrices[frame] || 0;
        const currentRubies = me.rubies || 0;
        
        // Проверяем, куплена ли уже рамка
        const ownedFrames = me.ownedFrames || ['none'];
        
        if (!ownedFrames.includes(frame)) {
            // Нужно купить
            if (currentRubies < price) {
                showToast(`Недостаточно рубинов! Нужно ${price}💎`, '❌');
                return;
            }
            
            if (!confirm(`Купить рамку "${frameNames[frame]}" за ${price}💎?`)) return;
            
            // Списываем рубины и добавляем рамку
            ownedFrames.push(frame);
            me.rubies = currentRubies - price;
            me.ownedFrames = ownedFrames;
            
            await setDoc(doc(db, 'artifacts', appId, 'public', 'data', 'users', me.uid), {
                rubies: me.rubies,
                ownedFrames: ownedFrames,
                avatarFrame: frame
            }, { merge: true });
            
            updateRubiesDisplay();
            showToast(`Рамка "${frameNames[frame]}" куплена!`, '🎉');
        } else {
            // Уже куплена - просто выбираем
            await setDoc(doc(db, 'artifacts', appId, 'public', 'data', 'users', me.uid), {
                avatarFrame: frame
            }, { merge: true });
        }
        
        me.avatarFrame = frame;
        window.updateFrameSelection(frame);
        window.applyAvatarFrame();
        showToast(`Рамка: ${frameNames[frame]}`, '✅');
    };
    
    // Обновление UI выбора рамки
    window.updateFrameSelection = function(frame) {
        document.querySelectorAll('.frame-btn').forEach(btn => {
            btn.classList.remove('active');
            if (btn.dataset.frame === frame) {
                btn.classList.add('active');
            }
        });
        const nameEl = document.getElementById('current-frame-name');
        if (nameEl) nameEl.textContent = frameNames[frame] || 'Без рамки';
    }
    
    // Применение рамки к аватару
    window.applyAvatarFrame = function() {
        const frame = me?.avatarFrame || 'none';
        const settingsAvatar = document.getElementById('settings-avatar');
        const myAvatar = document.getElementById('my-avatar');
        
        // Удаляем все классы рамок
        const frameClasses = ['avatar-frame-rainbow', 'avatar-frame-gold', 'avatar-frame-neon', 'avatar-frame-fire', 'avatar-frame-purple', 'avatar-frame-emerald', 'avatar-frame-diamond'];
        
        [settingsAvatar, myAvatar].forEach(el => {
            if (el) {
                frameClasses.forEach(cls => el.classList.remove(cls));
                if (frame !== 'none') {
                    el.classList.add('avatar-frame-' + frame);
                }
            }
        });
    }
    
    // Выбор стиля сообщений
    window.selectChatStyle = async (style) => {
        if (!me) return;
        
        const price = stylePrices[style] || 0;
        const currentRubies = me.rubies || 0;
        
        // Проверяем, куплен ли уже стиль
        const ownedStyles = me.ownedStyles || ['default'];
        
        if (!ownedStyles.includes(style)) {
            // Нужно купить
            if (currentRubies < price) {
                showToast(`Недостаточно рубинов! Нужно ${price}💎`, '❌');
                return;
            }
            
            if (!confirm(`Купить стиль "${styleNames[style]}" за ${price}💎?`)) return;
            
            // Списываем рубины и добавляем стиль
            ownedStyles.push(style);
            me.rubies = currentRubies - price;
            me.ownedStyles = ownedStyles;
            
            await setDoc(doc(db, 'artifacts', appId, 'public', 'data', 'users', me.uid), {
                rubies: me.rubies,
                ownedStyles: ownedStyles,
                chatStyle: style
            }, { merge: true });
            
            updateRubiesDisplay();
            showToast(`Стиль "${styleNames[style]}" куплен!`, '🎉');
        } else {
            // Уже куплен - просто выбираем
            await setDoc(doc(db, 'artifacts', appId, 'public', 'data', 'users', me.uid), {
                chatStyle: style
            }, { merge: true });
        }
        
        me.chatStyle = style;
        window.updateStyleSelection(style);
        window.applyChatStyle();
        showToast(`Стиль: ${styleNames[style]}`, '✅');
    };
    
    // Обновление UI выбора стиля
    window.updateStyleSelection = function(style) {
        document.querySelectorAll('.chat-style-btn').forEach(btn => {
            btn.classList.remove('active');
            if (btn.dataset.style === style) {
                btn.classList.add('active');
            }
        });
        const nameEl = document.getElementById('current-style-name');
        if (nameEl) nameEl.textContent = styleNames[style] || 'Стандартное';
    }
    
    // Применение стиля к сообщениям
    window.applyChatStyle = function() {
        const style = me?.chatStyle || 'default';
        const messagesContainer = document.getElementById('messages-container');
        
        if (messagesContainer) {
            messagesContainer.classList.remove('msg-style-gradient', 'msg-style-neon', 'msg-style-glass');
            if (style !== 'default') {
                messagesContainer.classList.add('msg-style-' + style);
            }
        }
    }
    
    // Загрузка настроек рамок и стилей
    window.loadFrameAndStyleSettings = async function() {
        if (!me) return;
        
        try {
            const userDoc = await getDoc(doc(db, 'artifacts', appId, 'public', 'data', 'users', me.uid));
            if (userDoc.exists()) {
                const data = userDoc.data();
                me.avatarFrame = data.avatarFrame || 'none';
                me.chatStyle = data.chatStyle || 'default';
                me.ownedFrames = data.ownedFrames || ['none'];
                me.ownedStyles = data.ownedStyles || ['default'];
                
                window.updateFrameSelection(me.avatarFrame);
                window.updateStyleSelection(me.chatStyle);
                window.applyAvatarFrame();
                window.applyChatStyle();
                
                // Обновляем рубины в настройках
                const settingsRubies = document.getElementById('settings-rubies');
                if (settingsRubies) settingsRubies.textContent = (me.rubies || 0).toFixed(2);
                
                // Помечаем купленные рамки
                document.querySelectorAll('.frame-btn').forEach(btn => {
                    const frame = btn.dataset.frame;
                    if (me.ownedFrames.includes(frame)) {
                        const priceSpan = btn.querySelector('span');
                        if (priceSpan && frame !== 'none') {
                            priceSpan.textContent = '✓';
                            priceSpan.className = 'absolute -bottom-1 text-[8px] bg-green-500 text-white px-1 rounded';
                        }
                    }
                });
                
                // Помечаем купленные стили
                document.querySelectorAll('.chat-style-btn').forEach(btn => {
                    const style = btn.dataset.style;
                    if (me.ownedStyles.includes(style)) {
                        const priceSpan = btn.querySelector('span:last-child');
                        if (priceSpan && style !== 'default') {
                            priceSpan.textContent = '✓ Куплено';
                            priceSpan.className = 'text-[10px] bg-green-500 text-white px-2 py-1 rounded';
                        }
                    }
                });
            }
        } catch (e) {
            console.error('Error loading frame/style settings:', e);
        }
    };
    
    // Показать профиль пользователя
    window.showUserProfile = async (uid) => {
        if (!uid) return;
        
        const modal = document.getElementById('profile-modal');
        const avatar = document.getElementById('profile-modal-avatar');
        const name = document.getElementById('profile-modal-name');
        const status = document.getElementById('profile-modal-status');
        const body = document.getElementById('profile-modal-body');
        
        modal.style.display = 'flex';
        body.innerHTML = '<div class="text-center py-8"><i class="fas fa-spinner fa-spin text-2xl opacity-50"></i></div>';
        
        try {
            const userDoc = await getDoc(doc(db, 'artifacts', appId, 'public', 'data', 'users', uid));
            
            if (!userDoc.exists()) {
                body.innerHTML = '<div class="profile-hidden"><i class="fas fa-user-slash text-4xl mb-3"></i><p>Пользователь не найден</p></div>';
                return;
            }
            
            const data = userDoc.data();
            
            // Проверяем скрытие профиля
            if (data.profileHidden && uid !== me?.uid) {
                avatar.innerHTML = '<i class="fas fa-user-secret text-3xl"></i>';
                name.textContent = '@' + data.username;
                status.textContent = '';
                body.innerHTML = '<div class="profile-hidden"><i class="fas fa-lock text-4xl mb-3"></i><p>' + 
                    (currentLang === 'ru' ? 'Профиль скрыт' : 'Profile is hidden') + '</p></div>';
                return;
            }
            
            // Аватар
            if (data.avatar) {
                avatar.innerHTML = '<img src="' + data.avatar + '">';
            } else {
                avatar.innerHTML = data.username[0].toUpperCase();
            }
            
            // Имя
            name.textContent = '@' + data.username;
            
            // Статус онлайн
            const isOnline = data.isOnline === true;
            status.innerHTML = isOnline ? 
                '<span class="text-green-400">' + (currentLang === 'ru' ? 'в сети' : 'online') + '</span>' : 
                formatLastSeen(data.lastSeen);
            
            // Информация
            let infoHtml = '';
            
            // Пол
            if (data.gender) {
                const genderText = {
                    male: currentLang === 'ru' ? 'Мужской' : 'Male',
                    female: currentLang === 'ru' ? 'Женский' : 'Female',
                    other: currentLang === 'ru' ? 'Другой' : 'Other'
                };
                const genderIcon = { male: '👨', female: '👩', other: '🤷' };
                infoHtml += '<div class="profile-info-item">' +
                    '<div class="profile-info-icon">' + genderIcon[data.gender] + '</div>' +
                    '<div><div class="profile-info-label">' + (currentLang === 'ru' ? 'Пол' : 'Gender') + '</div>' +
                    '<div class="profile-info-value">' + genderText[data.gender] + '</div></div></div>';
            }
            
            // Био
            if (data.bio) {
                infoHtml += '<div class="profile-info-item">' +
                    '<div class="profile-info-icon"><i class="fas fa-quote-left"></i></div>' +
                    '<div><div class="profile-info-label">' + (currentLang === 'ru' ? 'О себе' : 'About') + '</div>' +
                    '<div class="profile-info-value">' + data.bio + '</div></div></div>';
            }
            
            // Витрина подарков
            if (data.giftsShowcase && Object.keys(data.giftsShowcase).length > 0) {
                let giftsHtml = '<div class="profile-info-item" style="flex-direction: column; align-items: flex-start;">' +
                    '<div class="profile-info-label mb-2"><i class="fas fa-gift mr-1"></i> ' + 
                    (currentLang === 'ru' ? 'Витрина подарков' : 'Gift Showcase') + '</div>' +
                    '<div class="gifts-showcase">';
                
                // Сортируем по количеству
                const sortedGifts = Object.entries(data.giftsShowcase)
                    .sort((a, b) => b[1] - a[1]);
                
                for (const [giftId, count] of sortedGifts) {
                    if (count > 0) {
                        const giftSvg = (window.giftSVGs && window.giftSVGs[giftId]) ? window.giftSVGs[giftId] : (window.giftSVGs ? window.giftSVGs.gift : '🎁');
                        giftsHtml += '<div class="showcase-gift">' +
                            '<span class="showcase-gift-icon">' + giftSvg + '</span>' +
                            '<span class="showcase-gift-count">×' + count + '</span>' +
                        '</div>';
                    }
                }
                
                giftsHtml += '</div></div>';
                infoHtml += giftsHtml;
            }
            
            if (!infoHtml) {
                infoHtml = '<div class="text-center py-4 opacity-50 text-sm">' + 
                    (currentLang === 'ru' ? 'Нет информации' : 'No information') + '</div>';
            }
            
            body.innerHTML = infoHtml;
            
        } catch (e) {
            console.error('Error loading profile:', e);
            body.innerHTML = '<div class="profile-hidden"><i class="fas fa-exclamation-triangle text-4xl mb-3"></i><p>Ошибка загрузки</p></div>';
        }
    };
    
    window.closeProfileModal = () => {
        document.getElementById('profile-modal').style.display = 'none';
    };
    
    // ========== ГОЛОСОВАНИЯ (POLLS) ==========
    
    window.openPollModal = () => {
        if (!activeChatPartner && !activeGroup) {
            showToast('Сначала откройте чат', '⚠️');
            return;
        }
        document.getElementById('poll-modal').style.display = 'flex';
        document.getElementById('poll-question').value = '';
        document.getElementById('poll-anonymous').checked = false;
        document.getElementById('poll-multiple').checked = false;
        
        // Сбрасываем варианты
        const container = document.getElementById('poll-options-container');
        container.innerHTML = `
            <div class="poll-option-input">
                <input type="text" placeholder="Вариант 1" maxlength="100">
                <button class="poll-remove-option" onclick="removePollOption(this)" style="visibility: hidden;">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="poll-option-input">
                <input type="text" placeholder="Вариант 2" maxlength="100">
                <button class="poll-remove-option" onclick="removePollOption(this)" style="visibility: hidden;">
                    <i class="fas fa-times"></i>
                </button>
            </div>
        `;
    };
    
    window.closePollModal = () => {
        document.getElementById('poll-modal').style.display = 'none';
    };
    
    window.addPollOption = () => {
        const container = document.getElementById('poll-options-container');
        const count = container.children.length;
        if (count >= 10) {
            showToast('Максимум 10 вариантов', '⚠️');
            return;
        }
        
        const div = document.createElement('div');
        div.className = 'poll-option-input';
        div.innerHTML = `
            <input type="text" placeholder="Вариант ${count + 1}" maxlength="100">
            <button class="poll-remove-option" onclick="removePollOption(this)">
                <i class="fas fa-times"></i>
            </button>
        `;
        container.appendChild(div);
        div.querySelector('input').focus();
        updatePollRemoveButtons();
    };
    
    window.removePollOption = (btn) => {
        const container = document.getElementById('poll-options-container');
        if (container.children.length <= 2) return;
        btn.closest('.poll-option-input').remove();
        updatePollRemoveButtons();
    };
    
    function updatePollRemoveButtons() {
        const container = document.getElementById('poll-options-container');
        const buttons = container.querySelectorAll('.poll-remove-option');
        buttons.forEach(btn => {
            btn.style.visibility = container.children.length > 2 ? 'visible' : 'hidden';
        });
    }
    
    window.createPoll = async () => {
        const question = document.getElementById('poll-question').value.trim();
        const isAnonymous = document.getElementById('poll-anonymous').checked;
        const isMultiple = document.getElementById('poll-multiple').checked;
        
        const optionInputs = document.querySelectorAll('#poll-options-container input');
        const options = [];
        optionInputs.forEach(input => {
            const val = input.value.trim();
            if (val) options.push(val);
        });
        
        if (!question) {
            showToast('Введите вопрос', '⚠️');
            return;
        }
        if (options.length < 2) {
            showToast('Нужно минимум 2 варианта', '⚠️');
            return;
        }
        
        const pollId = 'poll_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        
        const pollData = {
            type: 'poll',
            pollId: pollId,
            question: question,
            options: options.map((text, idx) => ({ id: idx, text: text, votes: [] })),
            isAnonymous: isAnonymous,
            isMultiple: isMultiple,
            creatorId: me.uid,
            creatorName: me.username,
            totalVotes: 0,
            timestamp: serverTimestamp(),
            senderId: me.uid,
            senderName: me.username
        };
        
        // Отправляем как сообщение
        if (activeGroup) {
            await addDoc(collection(db, 'artifacts', appId, 'public', 'data', 'groups', activeGroup.id, 'messages'), pollData);
        } else if (activeChatPartner) {
            const chatId = [me.uid, activeChatPartner.uid].sort().join('_');
            await addDoc(collection(db, 'artifacts', appId, 'public', 'data', 'chats', chatId, 'messages'), pollData);
            
            // Обновляем last message
            await setDoc(doc(db, 'artifacts', appId, 'users', me.uid, 'active_chats', activeChatPartner.uid), {
                uid: activeChatPartner.uid,
                username: activeChatPartner.username,
                last: '📊 Голосование: ' + question.substring(0, 30) + (question.length > 30 ? '...' : ''),
                lastSenderId: me.uid,
                updatedAt: serverTimestamp()
            }, { merge: true });
            
            await setDoc(doc(db, 'artifacts', appId, 'users', activeChatPartner.uid, 'active_chats', me.uid), {
                uid: me.uid,
                username: me.username,
                last: '📊 Голосование: ' + question.substring(0, 30) + (question.length > 30 ? '...' : ''),
                lastSenderId: me.uid,
                updatedAt: serverTimestamp()
            }, { merge: true });
        }
        
        closePollModal();
        showToast('Голосование создано!', '📊');
    };
    
    window.votePoll = async (msgId, optionId, pollData) => {
        if (!me) return;
        
        const chatId = activeGroup ? null : [me.uid, activeChatPartner.uid].sort().join('_');
        const msgRef = activeGroup 
            ? doc(db, 'artifacts', appId, 'public', 'data', 'groups', activeGroup.id, 'messages', msgId)
            : doc(db, 'artifacts', appId, 'public', 'data', 'chats', chatId, 'messages', msgId);
        
        // Получаем текущие данные
        const msgDoc = await getDoc(msgRef);
        if (!msgDoc.exists()) return;
        
        const data = msgDoc.data();
        const options = data.options || [];
        
        // Проверяем, голосовал ли уже
        let hasVoted = false;
        let votedOptionId = -1;
        options.forEach((opt, idx) => {
            if (opt.votes && opt.votes.includes(me.uid)) {
                hasVoted = true;
                votedOptionId = idx;
            }
        });
        
        // Если не множественный выбор и уже голосовал за другой вариант - убираем старый голос
        if (!data.isMultiple && hasVoted && votedOptionId !== optionId) {
            options[votedOptionId].votes = options[votedOptionId].votes.filter(uid => uid !== me.uid);
        }
        
        // Если уже голосовал за этот вариант - убираем голос (toggle)
        if (options[optionId].votes && options[optionId].votes.includes(me.uid)) {
            options[optionId].votes = options[optionId].votes.filter(uid => uid !== me.uid);
        } else {
            // Добавляем голос
            if (!options[optionId].votes) options[optionId].votes = [];
            options[optionId].votes.push(me.uid);
        }
        
        // Считаем общее количество голосов
        let totalVotes = 0;
        options.forEach(opt => {
            totalVotes += (opt.votes || []).length;
        });
        
        await updateDoc(msgRef, {
            options: options,
            totalVotes: totalVotes
        });
    };
    
    function renderPollMessage(m, msgId, isMine) {
        const options = m.options || [];
        const totalVotes = m.totalVotes || 0;
        
        // Проверяем, голосовал ли текущий пользователь
        let userVoted = false;
        options.forEach(opt => {
            if (opt.votes && opt.votes.includes(me.uid)) {
                userVoted = true;
            }
        });
        
        let optionsHtml = '';
        options.forEach((opt, idx) => {
            const votes = (opt.votes || []).length;
            const percent = totalVotes > 0 ? Math.round((votes / totalVotes) * 100) : 0;
            const isSelected = opt.votes && opt.votes.includes(me.uid);
            const votedClass = userVoted ? 'voted' : '';
            const selectedClass = isSelected ? 'selected' : '';
            
            optionsHtml += `
                <div class="poll-option ${votedClass} ${selectedClass}" onclick="votePoll('${msgId}', ${idx}, ${JSON.stringify(m).replace(/"/g, '&quot;')})">
                    <div class="poll-progress" style="width: ${userVoted ? percent : 0}%"></div>
                    <div class="poll-option-content">
                        <span class="poll-option-text">${isSelected ? '✓ ' : ''}${opt.text}</span>
                        <span class="poll-option-percent">${percent}%</span>
                    </div>
                </div>
            `;
        });
        
        const anonymousLabel = m.isAnonymous ? '<i class="fas fa-user-secret" title="Анонимное"></i>' : '';
        const multipleLabel = m.isMultiple ? '<i class="fas fa-check-double" title="Множественный выбор"></i>' : '';
        
        return `
            <div class="poll-container">
                <div class="poll-question">
                    <i class="fas fa-poll"></i>
                    ${m.question}
                </div>
                ${optionsHtml}
                <div class="poll-footer">
                    <div class="poll-votes-count">
                        <i class="fas fa-users"></i>
                        ${totalVotes} ${totalVotes === 1 ? 'голос' : totalVotes < 5 ? 'голоса' : 'голосов'}
                    </div>
                    <div class="flex gap-2">
                        ${anonymousLabel}
                        ${multipleLabel}
                    </div>
                </div>
            </div>
        `;
    }
    
    window.openPartnerProfile = () => {
        if (typeof activeChatPartner !== 'undefined' && activeChatPartner && activeChatPartner.uid) {
            showUserProfile(activeChatPartner.uid);
        }
    };

    window.triggerAvatarUpload = () => document.getElementById('avatar-input').click();

    window.handleAvatarUpload = async (input) => {
        const file = input.files[0];
        if (!file || !me) return;

        // Проверяем размер (макс 1MB для аватарки)
        if (file.size > 1024 * 1024) {
            alert(currentLang === 'ru' ? 'Аватарка слишком большая. Максимум 1MB.' : 'Avatar is too large. Maximum 1MB.');
            input.value = '';
            return;
        }

        // Проверяем тип
        if (!file.type.startsWith('image/')) {
            alert('Выберите изображение');
            input.value = '';
            return;
        }

        const reader = new FileReader();
        reader.onload = async (e) => {
            const avatarData = e.target.result;
            
            // Сохраняем в Firebase
            await setDoc(doc(db, 'artifacts', appId, 'public', 'data', 'users', me.uid), {
                avatar: avatarData
            }, { merge: true });

            me.avatar = avatarData;
            updateAllAvatars();
        };
        reader.readAsDataURL(file);
        input.value = '';
    };

    function updateSettingsAvatar() {
        const settingsAvatar = document.getElementById('settings-avatar');
        if (me?.avatar) {
            settingsAvatar.innerHTML = `<img src="${me.avatar}" class="w-full h-full object-cover">`;
        } else {
            settingsAvatar.innerText = me?.username?.[0]?.toUpperCase() || '?';
        }
    }

    function updateAllAvatars() {
        // Обновляем аватар в боковой панели
        const myAvatar = document.getElementById('my-avatar');
        if (me?.avatar) {
            myAvatar.innerHTML = `<img src="${me.avatar}" class="w-full h-full object-cover rounded-2xl">`;
        } else {
            myAvatar.innerHTML = me?.username?.[0]?.toUpperCase() || '?';
        }
        
        // Обновляем в настройках
        updateSettingsAvatar();
    }
    
    window.setTheme = (t) => {
        document.body.className = `theme-${t} h-screen flex flex-col overflow-hidden`;
        if(me?.uid) setDoc(doc(db, 'artifacts', appId, 'public', 'data', 'users', me.uid), { settings: { theme: t } }, { merge: true });
    };

    // ========== Обои чата ==========
    const wallpaperPatterns = {
        none: 'none',
        dots: 'radial-gradient(circle, rgba(99,102,241,0.15) 1px, transparent 1px)',
        grid: 'linear-gradient(rgba(99,102,241,0.1) 1px, transparent 1px), linear-gradient(90deg, rgba(99,102,241,0.1) 1px, transparent 1px)',
        diagonal: 'repeating-linear-gradient(45deg, transparent, transparent 10px, rgba(99,102,241,0.08) 10px, rgba(99,102,241,0.08) 20px)',
        waves: 'repeating-linear-gradient(90deg, transparent, transparent 20px, rgba(99,102,241,0.05) 20px, rgba(99,102,241,0.1) 40px)',
        circles: 'radial-gradient(circle at 50% 50%, transparent 20px, rgba(99,102,241,0.05) 21px, rgba(99,102,241,0.05) 22px, transparent 23px)',
        triangles: 'linear-gradient(135deg, rgba(99,102,241,0.1) 25%, transparent 25%), linear-gradient(225deg, rgba(99,102,241,0.1) 25%, transparent 25%)'
    };
    
    const wallpaperSizes = {
        dots: '10px 10px',
        grid: '15px 15px',
        diagonal: 'auto',
        waves: 'auto',
        circles: '50px 50px',
        triangles: '20px 20px'
    };

    window.setWallpaper = (type) => {
        if (type === 'custom') {
            document.getElementById('custom-wallpaper-input').click();
            return;
        }
        
        const messagesContainer = document.getElementById('messages-container');
        if (!messagesContainer) return;
        
        // Убираем выделение со всех кнопок
        document.querySelectorAll('.wallpaper-btn').forEach(btn => {
            btn.classList.remove('border-indigo-500', 'ring-2', 'ring-indigo-500');
        });
        
        // Выделяем выбранную
        const selectedBtn = document.querySelector(`.wallpaper-btn[data-wallpaper="${type}"]`);
        if (selectedBtn) {
            selectedBtn.classList.add('border-indigo-500', 'ring-2', 'ring-indigo-500');
        }
        
        if (type === 'none') {
            messagesContainer.style.backgroundImage = 'none';
            messagesContainer.style.backgroundSize = 'auto';
        } else {
            messagesContainer.style.backgroundImage = wallpaperPatterns[type];
            messagesContainer.style.backgroundSize = wallpaperSizes[type] || 'auto';
        }
        
        // Сохраняем в localStorage и Firebase
        localStorage.setItem('flickers-wallpaper', type);
        if(me?.uid) {
            setDoc(doc(db, 'artifacts', appId, 'public', 'data', 'users', me.uid), { settings: { wallpaper: type } }, { merge: true });
        }
    };

    window.handleCustomWallpaper = (event) => {
        const file = event.target.files[0];
        if (!file) return;
        
        if (file.size > 500 * 1024) {
            alert(currentLang === 'ru' ? 'Изображение слишком большое. Максимум 500KB.' : 'Image too large. Max 500KB.');
            return;
        }
        
        const reader = new FileReader();
        reader.onload = (e) => {
            const dataUrl = e.target.result;
            const messagesContainer = document.getElementById('messages-container');
            
            messagesContainer.style.backgroundImage = `url(${dataUrl})`;
            messagesContainer.style.backgroundSize = 'cover';
            messagesContainer.style.backgroundPosition = 'center';
            
            // Убираем выделение со всех кнопок
            document.querySelectorAll('.wallpaper-btn').forEach(btn => {
                btn.classList.remove('border-indigo-500', 'ring-2', 'ring-indigo-500');
            });
            
            // Выделяем кнопку custom
            const customBtn = document.querySelector('.wallpaper-btn[data-wallpaper="custom"]');
            if (customBtn) {
                customBtn.classList.add('border-indigo-500', 'ring-2', 'ring-indigo-500');
            }
            
            // Сохраняем в localStorage
            localStorage.setItem('flickers-wallpaper', 'custom');
            localStorage.setItem('flickers-wallpaper-custom', dataUrl);
        };
        reader.readAsDataURL(file);
    };

    function loadWallpaper() {
        const savedWallpaper = localStorage.getItem('flickers-wallpaper') || 'none';
        
        if (savedWallpaper === 'custom') {
            const customData = localStorage.getItem('flickers-wallpaper-custom');
            if (customData) {
                const messagesContainer = document.getElementById('messages-container');
                if (messagesContainer) {
                    messagesContainer.style.backgroundImage = `url(${customData})`;
                    messagesContainer.style.backgroundSize = 'cover';
                    messagesContainer.style.backgroundPosition = 'center';
                }
            }
        } else if (savedWallpaper !== 'none') {
            setWallpaper(savedWallpaper);
        }
        
        // Выделяем сохранённую кнопку
        const selectedBtn = document.querySelector(`.wallpaper-btn[data-wallpaper="${savedWallpaper}"]`);
        if (selectedBtn) {
            selectedBtn.classList.add('border-indigo-500', 'ring-2', 'ring-indigo-500');
        }
    }

    // ========== Просмотр изображений (совместимость) ==========
    let currentImageIndex = 0;
    let chatImages = [];

    window.openImageViewer = (src) => {
        // Перенаправляем на новый медиа-просмотрщик
        openMediaViewer(src, 'image');
    };

    // Старые функции для совместимости
    window.closeImageViewer = (event) => {
        if (event && event.target !== event.currentTarget) return;
        const viewer = document.getElementById('image-viewer');
        viewer.classList.add('hidden');
        document.body.style.overflow = '';
    };

    window.navigateImage = (direction) => {
        navigateMedia(direction);
    };

    function updateImageNavigation() {}

    function handleImageViewerKeys(e) {
        handleMediaViewerKeys(e);
    }

    // ========== Медиа-просмотрщик (фото + видео) ==========
    let currentMediaIndex = 0;
    let chatMedia = []; // { src: string, type: 'image' | 'video' }

    window.openMediaViewer = (src, type = 'image') => {
        // Собираем все медиа из чата
        chatMedia = [];
        
        // Изображения
        document.querySelectorAll('.chat-image').forEach(img => {
            chatMedia.push({ src: img.src, type: 'image' });
        });
        
        // Видео (не кружки)
        document.querySelectorAll('.chat-video').forEach(video => {
            chatMedia.push({ src: video.src, type: 'video' });
        });
        
        // Видео-кружки тоже добавляем
        document.querySelectorAll('.video-circle-message video').forEach(video => {
            chatMedia.push({ src: video.src, type: 'video' });
        });
        
        // Находим индекс текущего медиа
        currentMediaIndex = chatMedia.findIndex(m => m.src === src);
        if (currentMediaIndex === -1) {
            chatMedia.push({ src, type });
            currentMediaIndex = chatMedia.length - 1;
        }
        
        showMediaAtIndex(currentMediaIndex);
        
        const viewer = document.getElementById('media-viewer');
        viewer.classList.remove('hidden');
        document.body.style.overflow = 'hidden';
        
        // Обработчик клавиш
        document.addEventListener('keydown', handleMediaViewerKeys);
        
        // Показываем миниатюры если больше 1 медиа
        renderMediaThumbnails();
    };

    function showMediaAtIndex(index) {
        const media = chatMedia[index];
        if (!media) return;
        
        const imgEl = document.getElementById('media-viewer-img');
        const videoEl = document.getElementById('media-viewer-video');
        const downloadBtn = document.getElementById('media-viewer-download');
        const counter = document.getElementById('media-viewer-counter');
        
        // Останавливаем предыдущее видео
        videoEl.pause();
        
        if (media.type === 'video') {
            imgEl.classList.add('hidden');
            videoEl.classList.remove('hidden');
            videoEl.src = media.src;
            videoEl.play().catch(() => {});
        } else {
            videoEl.classList.add('hidden');
            imgEl.classList.remove('hidden');
            imgEl.src = media.src;
        }
        
        downloadBtn.href = media.src;
        
        // Счётчик
        if (chatMedia.length > 1) {
            counter.textContent = `${index + 1} / ${chatMedia.length}`;
        } else {
            counter.textContent = '';
        }
        
        // Обновляем навигацию
        updateMediaNavigation();
        
        // Обновляем активную миниатюру
        document.querySelectorAll('.media-thumbnail').forEach((thumb, i) => {
            thumb.classList.toggle('active', i === index);
        });
    }

    function renderMediaThumbnails() {
        const container = document.getElementById('media-viewer-thumbnails');
        
        if (chatMedia.length <= 1) {
            container.classList.add('hidden');
            return;
        }
        
        container.classList.remove('hidden');
        container.innerHTML = '';
        
        chatMedia.forEach((media, index) => {
            if (media.type === 'video') {
                const wrapper = document.createElement('div');
                wrapper.className = `media-thumbnail media-thumbnail-video ${index === currentMediaIndex ? 'active' : ''}`;
                wrapper.style.cssText = 'position:relative;width:60px;height:60px;background:#333;border-radius:8px;display:flex;align-items:center;justify-content:center;cursor:pointer;';
                wrapper.innerHTML = '<i class="fas fa-play text-white"></i>';
                wrapper.onclick = (e) => {
                    e.stopPropagation();
                    currentMediaIndex = index;
                    showMediaAtIndex(index);
                };
                container.appendChild(wrapper);
            } else {
                const thumb = document.createElement('img');
                thumb.className = `media-thumbnail ${index === currentMediaIndex ? 'active' : ''}`;
                thumb.src = media.src;
                thumb.onclick = (e) => {
                    e.stopPropagation();
                    currentMediaIndex = index;
                    showMediaAtIndex(index);
                };
                container.appendChild(thumb);
            }
        });
    }

    window.closeMediaViewer = (event) => {
        if (event && event.target !== event.currentTarget) return;
        
        const viewer = document.getElementById('media-viewer');
        const videoEl = document.getElementById('media-viewer-video');
        
        videoEl.pause();
        viewer.classList.add('hidden');
        document.body.style.overflow = '';
        document.removeEventListener('keydown', handleMediaViewerKeys);
    };

    window.navigateMedia = (direction) => {
        currentMediaIndex += direction;
        
        if (currentMediaIndex < 0) currentMediaIndex = chatMedia.length - 1;
        if (currentMediaIndex >= chatMedia.length) currentMediaIndex = 0;
        
        showMediaAtIndex(currentMediaIndex);
    };

    function updateMediaNavigation() {
        const prevBtn = document.getElementById('media-viewer-prev');
        const nextBtn = document.getElementById('media-viewer-next');
        
        if (chatMedia.length <= 1) {
            prevBtn.classList.add('hidden');
            nextBtn.classList.add('hidden');
        } else {
            prevBtn.classList.remove('hidden');
            nextBtn.classList.remove('hidden');
        }
    }

    function handleMediaViewerKeys(e) {
        if (e.key === 'Escape') {
            closeMediaViewer();
        } else if (e.key === 'ArrowLeft') {
            navigateMedia(-1);
        } else if (e.key === 'ArrowRight') {
            navigateMedia(1);
        } else if (e.key === ' ') {
            // Пробел для паузы/воспроизведения видео
            const videoEl = document.getElementById('media-viewer-video');
            if (!videoEl.classList.contains('hidden')) {
                e.preventDefault();
                if (videoEl.paused) {
                    videoEl.play();
                } else {
                    videoEl.pause();
                }
            }
        }
    }

    // ========== Меню чата ==========
    let mutedChats = JSON.parse(localStorage.getItem('flickers-muted-chats') || '{}');

    window.toggleChatMenu = async () => {
        const menu = document.getElementById('chat-menu');
        menu.classList.toggle('hidden');
        
        if (activeChatPartner && !menu.classList.contains('hidden')) {
            // Обновляем состояние кнопки mute
            const isMuted = mutedChats[activeChatPartner.uid];
            const muteIcon = document.getElementById('mute-chat-icon');
            const muteText = document.getElementById('mute-chat-text');
            
            if (isMuted) {
                muteIcon.className = 'fas fa-bell text-indigo-500 w-5';
                muteText.setAttribute('data-i18n', 'unmuteNotifications');
                muteText.innerText = currentLang === 'ru' ? 'Включить уведомления' : 'Enable notifications';
            } else {
                muteIcon.className = 'fas fa-bell-slash text-indigo-500 w-5';
                muteText.setAttribute('data-i18n', 'muteNotifications');
                muteText.innerText = currentLang === 'ru' ? 'Отключить уведомления' : 'Mute notifications';
            }
            
            // Обновляем состояние кнопки блокировки
            const blockIcon = document.getElementById('block-user-icon');
            const blockText = document.getElementById('block-user-text');
            const blockBtn = document.getElementById('block-user-btn');
            
            // Проверяем, заблокирован ли пользователь
            let isBlocked = false;
            if (me.blockedUsers && me.blockedUsers[activeChatPartner.uid]) {
                isBlocked = true;
            } else {
                // Проверяем в Firebase
                try {
                    const userDoc = await getDoc(doc(db, 'artifacts', appId, 'public', 'data', 'users', me.uid));
                    if (userDoc.exists()) {
                        const userData = userDoc.data();
                        isBlocked = userData.blockedUsers && userData.blockedUsers[activeChatPartner.uid] === true;
                        me.blockedUsers = userData.blockedUsers || {};
                    }
                } catch (e) {}
            }
            
            if (isBlocked) {
                blockIcon.className = 'fas fa-user-check w-5';
                blockText.setAttribute('data-i18n', 'unblockUser');
                blockText.innerText = currentLang === 'ru' ? 'Разблокировать' : 'Unblock';
                blockBtn.className = 'w-full px-4 py-3 flex items-center gap-3 hover:bg-green-50 dark:hover:bg-green-900/20 transition-colors text-left text-green-500';
            } else {
                blockIcon.className = 'fas fa-ban w-5';
                blockText.setAttribute('data-i18n', 'blockUser');
                blockText.innerText = currentLang === 'ru' ? 'Заблокировать' : 'Block';
                blockBtn.className = 'w-full px-4 py-3 flex items-center gap-3 hover:bg-red-50 dark:hover:bg-red-900/20 transition-colors text-left text-red-500';
            }
        }
    };

    window.searchInChat = () => {
        document.getElementById('chat-menu').classList.add('hidden');
        const query = prompt(currentLang === 'ru' ? 'Поиск в чате:' : 'Search in chat:');
        if (!query) return;
        
        const messages = document.querySelectorAll('#messages-container .message-bubble');
        let found = false;
        
        messages.forEach(msg => {
            msg.style.backgroundColor = '';
        });
        
        messages.forEach(msg => {
            const text = msg.innerText.toLowerCase();
            if (text.includes(query.toLowerCase())) {
                msg.style.backgroundColor = 'rgba(99, 102, 241, 0.3)';
                if (!found) {
                    msg.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    found = true;
                }
            }
        });
        
        if (!found) {
            alert(currentLang === 'ru' ? 'Ничего не найдено' : 'Nothing found');
        }
    };

    window.showChatMedia = () => {
        document.getElementById('chat-menu').classList.add('hidden');
        
        const images = document.querySelectorAll('#messages-container .chat-image');
        if (images.length === 0) {
            alert(currentLang === 'ru' ? 'Нет медиафайлов в этом чате' : 'No media files in this chat');
            return;
        }
        
        // Открываем первое изображение в галерее
        openImageViewer(images[0].src);
    };

    window.muteChat = () => {
        document.getElementById('chat-menu').classList.add('hidden');
        if (!activeChatPartner) return;
        
        const isMuted = mutedChats[activeChatPartner.uid];
        
        if (isMuted) {
            delete mutedChats[activeChatPartner.uid];
        } else {
            mutedChats[activeChatPartner.uid] = true;
        }
        
        localStorage.setItem('flickers-muted-chats', JSON.stringify(mutedChats));
        
        const message = isMuted 
            ? (currentLang === 'ru' ? 'Уведомления включены' : 'Notifications enabled')
            : (currentLang === 'ru' ? 'Уведомления отключены' : 'Notifications muted');
        
        // Показываем toast
        const container = document.getElementById('toast-container');
        const toast = document.createElement('div');
        toast.className = 'notification-toast';
        toast.innerHTML = `<i class="fas ${isMuted ? 'fa-bell' : 'fa-bell-slash'} text-indigo-500"></i><span>${message}</span>`;
        container.appendChild(toast);
        setTimeout(() => toast.classList.add('show'), 10);
        setTimeout(() => {
            toast.classList.remove('show');
            setTimeout(() => toast.remove(), 300);
        }, 2000);
    };

    window.clearChatHistory = async () => {
        document.getElementById('chat-menu').classList.add('hidden');
        if (!activeChatPartner || !me) return;
        
        const confirmed = confirm(currentLang === 'ru' 
            ? 'Очистить историю чата? Сообщения будут удалены только у вас.' 
            : 'Clear chat history? Messages will be deleted only for you.');
        
        if (!confirmed) return;
        
        const chatId = [me.uid, activeChatPartner.uid].sort().join('_');
        
        try {
            const messagesRef = collection(db, 'artifacts', appId, 'public', 'data', 'chats', chatId, 'messages');
            const snapshot = await getDocs(messagesRef);
            
            const batch = [];
            snapshot.forEach(doc => {
                batch.push(updateDoc(doc.ref, { 
                    [`deletedFor.${me.uid}`]: true 
                }));
            });
            
            await Promise.all(batch);
            
            // Показываем toast
            const container = document.getElementById('toast-container');
            const toast = document.createElement('div');
            toast.className = 'notification-toast';
            toast.innerHTML = `<i class="fas fa-check text-green-500"></i><span>${currentLang === 'ru' ? 'История очищена' : 'History cleared'}</span>`;
            container.appendChild(toast);
            setTimeout(() => toast.classList.add('show'), 10);
            setTimeout(() => {
                toast.classList.remove('show');
                setTimeout(() => toast.remove(), 300);
            }, 2000);
        } catch (err) {
            console.error('Error clearing history:', err);
        }
    };

    window.blockUser = async () => {
        document.getElementById('chat-menu').classList.add('hidden');
        if (!activeChatPartner || !me) return;
        
        // Проверяем, заблокирован ли уже пользователь
        const userDoc = await getDoc(doc(db, 'artifacts', appId, 'public', 'data', 'users', me.uid));
        const userData = userDoc.exists() ? userDoc.data() : {};
        const blockedUsers = userData.blockedUsers || {};
        const isBlocked = blockedUsers[activeChatPartner.uid] === true;
        
        if (isBlocked) {
            // Разблокируем
            const confirmed = confirm(currentLang === 'ru' 
                ? `Разблокировать @${activeChatPartner.username}?` 
                : `Unblock @${activeChatPartner.username}?`);
            
            if (!confirmed) return;
            
            try {
                delete blockedUsers[activeChatPartner.uid];
                await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'users', me.uid), {
                    blockedUsers: blockedUsers
                });
                
                // Обновляем локальный кэш
                if (me.blockedUsers) delete me.blockedUsers[activeChatPartner.uid];
                
                // Показываем toast
                const container = document.getElementById('toast-container');
                const toast = document.createElement('div');
                toast.className = 'notification-toast';
                toast.innerHTML = `<i class="fas fa-check text-green-500"></i><span>${currentLang === 'ru' ? 'Пользователь разблокирован' : 'User unblocked'}</span>`;
                container.appendChild(toast);
                setTimeout(() => toast.classList.add('show'), 10);
                setTimeout(() => {
                    toast.classList.remove('show');
                    setTimeout(() => toast.remove(), 300);
                }, 2000);
            } catch (err) {
                console.error('Error unblocking user:', err);
            }
        } else {
            // Блокируем
            const confirmed = confirm(currentLang === 'ru' 
                ? `Заблокировать @${activeChatPartner.username}? Вы не сможете получать от него сообщения.` 
                : `Block @${activeChatPartner.username}? You won't receive messages from them.`);
            
            if (!confirmed) return;
            
            try {
                blockedUsers[activeChatPartner.uid] = true;
                await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'users', me.uid), {
                    blockedUsers: blockedUsers
                });
                
                // Обновляем локальный кэш
                if (!me.blockedUsers) me.blockedUsers = {};
                me.blockedUsers[activeChatPartner.uid] = true;
                
                // Показываем toast
                const container = document.getElementById('toast-container');
                const toast = document.createElement('div');
                toast.className = 'notification-toast';
                toast.innerHTML = `<i class="fas fa-ban text-red-500"></i><span>${currentLang === 'ru' ? 'Пользователь заблокирован' : 'User blocked'}</span>`;
                container.appendChild(toast);
                setTimeout(() => toast.classList.add('show'), 10);
                setTimeout(() => {
                    toast.classList.remove('show');
                    setTimeout(() => toast.remove(), 300);
                }, 2000);
            } catch (err) {
                console.error('Error blocking user:', err);
            }
        }
    };

    document.getElementById('msg-input').onkeydown = e => { if(e.key === 'Enter') sendMsg(); };

    // ========== Групповые чаты ==========
    let selectedGroupMembers = [];
    let groupChatsUnsub = null;
    let activeGroup = null;

    window.openCreateGroup = () => {
        selectedGroupMembers = [];
        document.getElementById('create-group-modal').classList.remove('hidden');
        document.getElementById('group-name-input').value = '';
        document.getElementById('selected-members').innerHTML = '';
        document.getElementById('group-search-results').innerHTML = '';
        document.getElementById('selected-count').innerText = '0';
        document.getElementById('create-group-btn').disabled = true;
        document.getElementById('group-search-input').value = '';
    };

    window.closeCreateGroup = (event) => {
        if (event && event.target !== event.currentTarget) return;
        document.getElementById('create-group-modal').classList.add('hidden');
    };

    window.addGroupMember = (user) => {
        if (selectedGroupMembers.length >= 12) {
            alert(currentLang === 'ru' ? 'Максимум 12 участников' : 'Maximum 12 members');
            return;
        }
        if (selectedGroupMembers.find(m => m.uid === user.uid)) return;
        selectedGroupMembers.push(user);
        updateSelectedMembers();
        document.getElementById('group-search-input').value = '';
        document.getElementById('group-search-results').innerHTML = '';
    };

    window.removeGroupMember = (uid) => {
        selectedGroupMembers = selectedGroupMembers.filter(m => m.uid !== uid);
        updateSelectedMembers();
    };

    function updateSelectedMembers() {
        const container = document.getElementById('selected-members');
        const countEl = document.getElementById('selected-count');
        const createBtn = document.getElementById('create-group-btn');
        
        container.innerHTML = selectedGroupMembers.map(m => `
            <div class="flex items-center gap-1 bg-indigo-100 dark:bg-indigo-900/50 text-indigo-600 dark:text-indigo-300 px-2 py-1 rounded-full text-xs">
                <span>@${m.username}</span>
                <button onclick="removeGroupMember('${m.uid}')" class="w-4 h-4 rounded-full hover:bg-indigo-200 dark:hover:bg-indigo-800 flex items-center justify-center">
                    <i class="fas fa-times text-[10px]"></i>
                </button>
            </div>
        `).join('');
        
        countEl.innerText = selectedGroupMembers.length;
        createBtn.disabled = selectedGroupMembers.length < 1 || !document.getElementById('group-name-input').value.trim();
    }

    // Поиск пользователей для группы
    document.getElementById('group-search-input')?.addEventListener('input', async (e) => {
        const searchQuery = e.target.value.trim().toLowerCase();
        const resultsDiv = document.getElementById('group-search-results');
        
        if (searchQuery.length < 2) {
            resultsDiv.innerHTML = '';
            return;
        }
        
        try {
            const usersRef = collection(db, 'artifacts', appId, 'public', 'data', 'users');
            const snapshot = await getDocs(usersRef);
            
            resultsDiv.innerHTML = '';
            
            snapshot.forEach(docSnap => {
                const user = docSnap.data();
                if (user.deleted || docSnap.id === me.uid) return;
                if (!user.username.toLowerCase().includes(searchQuery)) return;
                if (selectedGroupMembers.find(m => m.uid === docSnap.id)) return;
                
                const div = document.createElement('div');
                div.className = 'flex items-center gap-3 p-2 rounded-xl hover:bg-slate-100 dark:hover:bg-slate-800 cursor-pointer transition-colors';
                div.innerHTML = `
                    <div class="w-10 h-10 rounded-full bg-indigo-100 text-indigo-500 flex items-center justify-center font-bold overflow-hidden">
                        ${user.avatar ? `<img src="${user.avatar}" class="w-full h-full object-cover">` : user.username[0].toUpperCase()}
                    </div>
                    <span class="font-medium">@${user.username}</span>
                `;
                div.onclick = () => addGroupMember({ uid: docSnap.id, username: user.username, avatar: user.avatar });
                resultsDiv.appendChild(div);
            });
            
            if (resultsDiv.children.length === 0) {
                resultsDiv.innerHTML = `<p class="text-center text-slate-400 text-sm py-4">${currentLang === 'ru' ? 'Никто не найден' : 'No one found'}</p>`;
            }
        } catch (err) {
            console.error('Error searching users:', err);
        }
    });

    document.getElementById('group-name-input')?.addEventListener('input', updateSelectedMembers);

    window.createGroup = async () => {
        const groupName = document.getElementById('group-name-input').value.trim();
        if (!groupName || selectedGroupMembers.length < 1) return;
        
        const memberIds = [me.uid, ...selectedGroupMembers.map(m => m.uid)];
        const memberNames = { [me.uid]: me.username };
        selectedGroupMembers.forEach(m => memberNames[m.uid] = m.username);
        
        try {
            const groupRef = await addDoc(collection(db, 'artifacts', appId, 'public', 'data', 'groups'), {
                name: groupName,
                members: memberIds,
                memberNames: memberNames,
                createdBy: me.uid,
                createdAt: serverTimestamp(),
                lastMessage: null,
                lastMessageTime: serverTimestamp()
            });
            
            closeCreateGroup();
            
            const container = document.getElementById('toast-container');
            const toast = document.createElement('div');
            toast.className = 'notification-toast';
            toast.innerHTML = `<i class="fas fa-check text-green-500"></i><span>${currentLang === 'ru' ? 'Группа создана!' : 'Group created!'}</span>`;
            container.appendChild(toast);
            setTimeout(() => toast.classList.add('show'), 10);
            setTimeout(() => { toast.classList.remove('show'); setTimeout(() => toast.remove(), 300); }, 2000);
            
            selectGroup({ id: groupRef.id, name: groupName, members: memberIds, memberNames });
        } catch (err) {
            console.error('Error creating group:', err);
        }
    };

    window.selectGroup = async (group) => {
        activeGroup = group;
        activeChatPartner = null;
        
        document.getElementById('chat-placeholder').classList.add('hidden');
        document.getElementById('active-chat').classList.remove('hidden');
        document.getElementById('target-avatar').innerHTML = `<i class="fas fa-users text-indigo-500"></i>`;
        document.getElementById('target-name').innerText = group.name;
        
        // Мобильная навигация - показываем чат
        mobileShowChat();
        if (isMobileView) history.pushState({ chat: true }, '');
        
        // Скрываем онлайн-статус для групп
        document.getElementById('online-status').style.display = 'none';
        document.getElementById('online-indicator').classList.add('hidden');
        
        // Показываем кнопки звонков для групп
        const callBtns = document.querySelectorAll('[onclick^="startCall"]');
        callBtns.forEach(btn => btn.style.display = '');
        
        // Скрываем баннеры запросов (не нужны для групп)
        document.getElementById('chat-request-banner')?.classList.add('hidden');
        document.getElementById('chat-pending-banner')?.classList.add('hidden');
        document.querySelector('#active-chat footer')?.classList.remove('hidden');
        
        // Проверяем активный звонок в группе
        checkAndShowActiveGroupCall(group.id);
        
        // Загружаем закреплённое сообщение
        loadPinnedMessage(true);
        
        if (msgUnsub) msgUnsub();
        
        const q = query(collection(db, 'artifacts', appId, 'public', 'data', 'groups', group.id, 'messages'), orderBy('timestamp', 'asc'));
        
        msgUnsub = onSnapshot(q, (snap) => {
            const cont = document.getElementById('messages-container');
            const shouldScroll = cont.scrollTop + cont.offsetHeight >= cont.scrollHeight - 100;
            cont.innerHTML = '';
            
            snap.forEach(d => {
                const m = d.data();
                const msgId = d.id;
                if (m.deleted) return;
                
                const div = document.createElement('div');
                const isMine = m.senderId === me.uid;
                div.className = `message-bubble p-4 shadow-sm ${isMine ? 'sent' : 'received'}`;
                div.dataset.msgId = msgId;
                div.dataset.senderId = m.senderId;
                
                const senderName = group.memberNames[m.senderId] || m.senderName || 'Unknown';
                let displayText = m.text || '';
                if (m.encrypted && displayText) displayText = decrypt(displayText);
                
                // Цитата ответа
                let replyQuoteHtml = '';
                if (m.replyTo) {
                    replyQuoteHtml = `
                        <div class="reply-quote" onclick="scrollToMessage('${m.replyTo.msgId}')">
                            <div class="reply-quote-author">${m.replyTo.author}</div>
                            <div class="reply-quote-text">${m.replyTo.text}</div>
                        </div>
                    `;
                }
                
                // Пересланное сообщение
                let forwardedHtml = '';
                if (m.forwarded) {
                    forwardedHtml = `<div class="forwarded-label"><i class="fas fa-share"></i> Переслано от ${m.forwardedFrom}</div>`;
                }
                
                // Реакции
                const reactionsHtml = renderReactions(m.reactions, msgId, true);
                
                // Применяем linkify для текстовых сообщений
                const linkedText = (!m.type || m.type === 'text') ? linkifyText(displayText) : displayText;
                
                div.innerHTML = `
                    <div class="swipe-reply-hint"><i class="fas fa-reply"></i></div>
                    ${forwardedHtml}
                    ${replyQuoteHtml}
                    ${!isMine ? `<p class="text-xs text-indigo-500 font-bold mb-1">@${senderName}</p>` : ''}
                    <p class="text-sm leading-relaxed">${linkedText}</p>
                    ${reactionsHtml}
                    <span class="text-[9px] block mt-1 opacity-50 text-right">${m.timestamp ? new Date(m.timestamp.seconds * 1000).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'}) : '...'}</span>
                `;
                
                // Контекстное меню
                div.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    showMessageContextMenu(e, msgId, isMine, m.text, m.encrypted, m.type);
                });
                
                // Двойной клик для быстрой реакции ❤️
                div.addEventListener('dblclick', (e) => {
                    e.preventDefault();
                    addReaction(msgId, '❤️', true);
                });
                
                // Свайп вправо для ответа (мобильные)
                setupSwipeToReply(div, msgId, true);
                
                cont.appendChild(div);
                
                // Загружаем предпросмотр ссылок для текстовых сообщений
                if ((!m.type || m.type === 'text') && displayText) {
                    loadLinkPreviewForMessage(div, displayText);
                }
            });
            
            if (shouldScroll) cont.scrollTop = cont.scrollHeight;
        });
    };
    
    // Показать баннер активного звонка в группе
    async function checkAndShowActiveGroupCall(groupId) {
        if (activeGroupCallUnsub) activeGroupCallUnsub();
        
        const groupCallsRef = collection(db, 'artifacts', appId, 'public', 'data', 'group_calls');
        const q = query(groupCallsRef, where('groupId', '==', groupId), where('status', '==', 'active'));
        
        activeGroupCallUnsub = onSnapshot(q, (snap) => {
            // Удаляем старый баннер
            const oldBanner = document.getElementById('group-call-banner');
            if (oldBanner) oldBanner.remove();
            
            if (!snap.empty && !isGroupCall) {
                const callData = snap.docs[0].data();
                const callId = snap.docs[0].id;
                const participantCount = callData.participants?.length || 1;
                
                // Проверяем, не участвуем ли мы уже в этом звонке
                if (callData.participants?.includes(me.uid)) return;
                
                // Создаём баннер
                const banner = document.createElement('div');
                banner.id = 'group-call-banner';
                banner.className = 'p-3 bg-gradient-to-r from-green-500/20 to-emerald-500/20 border-b border-green-500/30 flex items-center justify-between animate-pulse';
                banner.innerHTML = `
                    <div class="flex items-center gap-3">
                        <div class="w-10 h-10 rounded-full bg-green-500 flex items-center justify-center">
                            <i class="fas fa-phone-alt text-white animate-bounce"></i>
                        </div>
                        <div>
                            <p class="font-bold text-green-600 dark:text-green-400">${currentLang === 'ru' ? 'Активный звонок' : 'Active call'}</p>
                            <p class="text-xs text-green-500">${participantCount} ${currentLang === 'ru' ? 'участник(ов)' : 'participant(s)'} • ${callData.isVideo ? (currentLang === 'ru' ? 'Видео' : 'Video') : (currentLang === 'ru' ? 'Аудио' : 'Audio')}</p>
                        </div>
                    </div>
                    <button onclick="joinGroupCall('${groupId}')" class="px-4 py-2 bg-green-500 hover:bg-green-600 text-white rounded-xl font-bold transition-all hover:scale-105">
                        <i class="fas fa-phone-alt mr-2"></i>${currentLang === 'ru' ? 'Присоединиться' : 'Join'}
                    </button>
                `;
                
                // Вставляем после header
                const header = document.querySelector('#active-chat header');
                if (header) header.after(banner);
            }
        });
    }

    // Переопределяем sendMsg для поддержки групп
    const originalSendMsgFunc = window.sendMsg;
    window.sendMsg = async (fileData) => {
        if (activeGroup) {
            const input = document.getElementById('msg-input');
            const text = input.value.trim();
            if (!text && !fileData) return;
            
            input.value = '';
            const encryptedText = text ? encrypt(text) : '';
            
            // Подготавливаем данные сообщения
            const msgData = {
                senderId: me.uid,
                senderName: me.username,
                text: encryptedText,
                encrypted: true,
                timestamp: serverTimestamp(),
                ...fileData
            };
            
            // Добавляем данные ответа если есть
            if (replyingTo && replyingTo.isGroup) {
                msgData.replyTo = {
                    msgId: replyingTo.msgId,
                    text: replyingTo.text,
                    author: replyingTo.author,
                    senderId: replyingTo.senderId
                };
                cancelReply();
            }
            
            try {
                await addDoc(collection(db, 'artifacts', appId, 'public', 'data', 'groups', activeGroup.id, 'messages'), msgData);
                
                // Начисляем рубины за отправку сообщения в группу
                earnRubies(RUBY_PER_MESSAGE);
                
                await setDoc(doc(db, 'artifacts', appId, 'public', 'data', 'groups', activeGroup.id), {
                    lastMessage: text.substring(0, 50),
                    lastMessageTime: serverTimestamp()
                }, { merge: true });
            } catch (err) {
                console.error('Error sending group message:', err);
            }
        } else if (originalSendMsgFunc) {
            originalSendMsgFunc(fileData);
        }
    };

    function listenToGroups() {
        if (groupChatsUnsub) groupChatsUnsub();
        
        const groupsRef = collection(db, 'artifacts', appId, 'public', 'data', 'groups');
        
        groupChatsUnsub = onSnapshot(groupsRef, (snap) => {
            snap.forEach(d => {
                const group = d.data();
                if (!group.members || !group.members.includes(me.uid)) return;
                
                const chatsList = document.getElementById('chats-list');
                let existingEl = document.querySelector(`[data-group-id="${d.id}"]`);
                
                if (!existingEl) {
                    existingEl = document.createElement('div');
                    existingEl.dataset.groupId = d.id;
                    existingEl.className = 'flex items-center space-x-3 p-3 rounded-2xl hover:bg-slate-100 dark:hover:bg-slate-800 cursor-pointer transition-all';
                    existingEl.onclick = () => selectGroup({ id: d.id, ...group });
                    chatsList.insertBefore(existingEl, chatsList.firstChild);
                }
                
                const memberCount = group.members.length;
                existingEl.innerHTML = `
                    <div class="w-12 h-12 rounded-xl bg-gradient-to-br from-indigo-500 to-purple-500 text-white flex items-center justify-center font-bold shadow-lg relative">
                        <i class="fas fa-users"></i>
                        <div class="group-call-indicator hidden absolute -top-1 -right-1 w-5 h-5 bg-green-500 rounded-full flex items-center justify-center animate-pulse" data-group-call="${d.id}">
                            <i class="fas fa-phone-alt text-white text-[8px]"></i>
                        </div>
                    </div>
                    <div class="flex-1 overflow-hidden">
                        <div class="flex justify-between items-center">
                            <p class="font-bold truncate">${group.name}</p>
                            <span class="text-[10px] text-slate-400">${memberCount} 👥</span>
                        </div>
                        <p class="text-xs text-slate-400 truncate group-last-msg">${group.lastMessage || (currentLang === 'ru' ? 'Нет сообщений' : 'No messages')}</p>
                    </div>
                `;
                
                // Проверяем активный звонок в группе
                checkGroupActiveCall(d.id);
            });
        });
    }
    
    // Проверка активного звонка в группе
    async function checkGroupActiveCall(groupId) {
        const groupCallsRef = collection(db, 'artifacts', appId, 'public', 'data', 'group_calls');
        const q = query(groupCallsRef, where('groupId', '==', groupId), where('status', '==', 'active'));
        
        onSnapshot(q, (snap) => {
            const indicator = document.querySelector(`[data-group-call="${groupId}"]`);
            const lastMsgEl = document.querySelector(`[data-group-id="${groupId}"] .group-last-msg`);
            
            if (!snap.empty) {
                // Есть активный звонок
                if (indicator) indicator.classList.remove('hidden');
                if (lastMsgEl) {
                    const callData = snap.docs[0].data();
                    const participantCount = callData.participants?.length || 1;
                    lastMsgEl.innerHTML = `<span class="text-green-500"><i class="fas fa-phone-alt mr-1"></i>${currentLang === 'ru' ? 'Звонок' : 'Call'} (${participantCount})</span>`;
                }
            } else {
                if (indicator) indicator.classList.add('hidden');
            }
        });
    }
    
    // Присоединиться к активному групповому звонку
    window.joinGroupCall = async (groupId) => {
        // Находим активный звонок
        const groupCallsRef = collection(db, 'artifacts', appId, 'public', 'data', 'group_calls');
        const q = query(groupCallsRef, where('groupId', '==', groupId), where('status', '==', 'active'));
        const snap = await getDocs(q);
        
        if (snap.empty) {
            alert(currentLang === 'ru' ? 'Звонок уже завершён' : 'Call has ended');
            return;
        }
        
        const callDoc = snap.docs[0];
        const callData = callDoc.data();
        
        // Присоединяемся как будто приняли звонок
        await acceptGroupCall({
            callId: callDoc.id,
            isVideo: callData.isVideo,
            groupName: callData.groupName,
            groupId: callData.groupId,
            isGroupCall: true
        });
    };

    // ========== Система запросов на общение ==========
    let currentChatStatus = null; // 'pending', 'accepted', 'declined', null

    async function checkChatPermission() {
        if (!activeChatPartner || !me) return;
        
        const chatId = [me.uid, activeChatPartner.uid].sort().join('_');
        
        try {
            const chatDoc = await getDoc(doc(db, 'artifacts', appId, 'public', 'data', 'chats', chatId, 'meta', 'permission'));
            
            const requestBanner = document.getElementById('chat-request-banner');
            const pendingBanner = document.getElementById('chat-pending-banner');
            const footer = document.querySelector('#active-chat footer');
            
            if (!chatDoc.exists()) {
                // Новый чат - проверяем, есть ли уже сообщения
                const messagesSnap = await getDocs(query(
                    collection(db, 'artifacts', appId, 'public', 'data', 'chats', chatId, 'messages'),
                    limit(1)
                ));
                
                if (messagesSnap.empty) {
                    // Совсем новый чат - разрешаем писать первое сообщение
                    currentChatStatus = null;
                    requestBanner.classList.add('hidden');
                    pendingBanner.classList.add('hidden');
                    footer.classList.remove('hidden');
                } else {
                    // Есть сообщения но нет разрешения - старый чат, разрешаем
                    currentChatStatus = 'accepted';
                    requestBanner.classList.add('hidden');
                    pendingBanner.classList.add('hidden');
                    footer.classList.remove('hidden');
                }
                return;
            }
            
            const data = chatDoc.data();
            currentChatStatus = data.status;
            
            if (data.status === 'pending') {
                if (data.requestedBy === me.uid) {
                    // Я отправил запрос - жду ответа
                    requestBanner.classList.add('hidden');
                    pendingBanner.classList.remove('hidden');
                    footer.classList.add('hidden');
                } else {
                    // Мне отправили запрос - показываю кнопки
                    requestBanner.classList.remove('hidden');
                    pendingBanner.classList.add('hidden');
                    footer.classList.add('hidden');
                }
            } else if (data.status === 'accepted') {
                // Чат принят - всё ок
                requestBanner.classList.add('hidden');
                pendingBanner.classList.add('hidden');
                footer.classList.remove('hidden');
            } else if (data.status === 'declined') {
                // Чат отклонён
                if (data.requestedBy === me.uid) {
                    requestBanner.classList.add('hidden');
                    pendingBanner.classList.add('hidden');
                    footer.classList.add('hidden');
                    // Показываем сообщение
                    document.getElementById('messages-container').innerHTML = `
                        <div class="flex-1 flex items-center justify-center">
                            <div class="text-center opacity-50">
                                <i class="fas fa-ban text-4xl mb-2"></i>
                                <p class="text-sm">${currentLang === 'ru' ? 'Запрос отклонён' : 'Request declined'}</p>
                            </div>
                        </div>
                    `;
                } else {
                    footer.classList.remove('hidden');
                }
            }
        } catch (err) {
            console.error('Error checking chat permission:', err);
        }
    }

    window.acceptChatRequest = async () => {
        if (!activeChatPartner || !me) return;
        
        const chatId = [me.uid, activeChatPartner.uid].sort().join('_');
        
        try {
            await setDoc(doc(db, 'artifacts', appId, 'public', 'data', 'chats', chatId, 'meta', 'permission'), {
                status: 'accepted',
                acceptedAt: serverTimestamp()
            }, { merge: true });
            
            document.getElementById('chat-request-banner').classList.add('hidden');
            document.querySelector('#active-chat footer').classList.remove('hidden');
            currentChatStatus = 'accepted';
            
            // Toast
            const container = document.getElementById('toast-container');
            const toast = document.createElement('div');
            toast.className = 'notification-toast';
            toast.innerHTML = `<i class="fas fa-check text-green-500"></i><span>${currentLang === 'ru' ? 'Запрос принят' : 'Request accepted'}</span>`;
            container.appendChild(toast);
            setTimeout(() => toast.classList.add('show'), 10);
            setTimeout(() => { toast.classList.remove('show'); setTimeout(() => toast.remove(), 300); }, 2000);
        } catch (err) {
            console.error('Error accepting request:', err);
        }
    };

    window.declineChatRequest = async () => {
        if (!activeChatPartner || !me) return;
        
        const chatId = [me.uid, activeChatPartner.uid].sort().join('_');
        
        try {
            await setDoc(doc(db, 'artifacts', appId, 'public', 'data', 'chats', chatId, 'meta', 'permission'), {
                status: 'declined',
                declinedAt: serverTimestamp()
            }, { merge: true });
            
            document.getElementById('chat-request-banner').classList.add('hidden');
            currentChatStatus = 'declined';
            
            // Toast
            const container = document.getElementById('toast-container');
            const toast = document.createElement('div');
            toast.className = 'notification-toast';
            toast.innerHTML = `<i class="fas fa-ban text-red-500"></i><span>${currentLang === 'ru' ? 'Запрос отклонён' : 'Request declined'}</span>`;
            container.appendChild(toast);
            setTimeout(() => toast.classList.add('show'), 10);
            setTimeout(() => { toast.classList.remove('show'); setTimeout(() => toast.remove(), 300); }, 2000);
        } catch (err) {
            console.error('Error declining request:', err);
        }
    };

    async function sendChatRequest() {
        if (!activeChatPartner || !me) return;
        
        const chatId = [me.uid, activeChatPartner.uid].sort().join('_');
        
        try {
            await setDoc(doc(db, 'artifacts', appId, 'public', 'data', 'chats', chatId, 'meta', 'permission'), {
                status: 'pending',
                requestedBy: me.uid,
                requestedAt: serverTimestamp()
            });
            
            currentChatStatus = 'pending';
            document.getElementById('chat-pending-banner').classList.remove('hidden');
            document.querySelector('#active-chat footer').classList.add('hidden');
        } catch (err) {
            console.error('Error sending chat request:', err);
        }
    }

    document.addEventListener('mousedown', (e) => {
        const emojiPanel = document.getElementById('emoji-panel');
        if (!emojiPanel.contains(e.target) && !e.target.closest('button')) {
            emojiPanel.classList.remove('active');
        }
        
        // Закрываем AI панель при клике вне её
        const aiPanel = document.getElementById('ai-panel');
        if (aiPanel && !aiPanel.contains(e.target) && !e.target.closest('button[onclick="toggleAI()"]')) {
            aiPanel.classList.add('hidden');
        }
        
        // Закрываем меню чата при клике вне его
        const chatMenu = document.getElementById('chat-menu');
        if (chatMenu && !chatMenu.contains(e.target) && !e.target.closest('button[onclick="toggleChatMenu()"]')) {
            chatMenu.classList.add('hidden');
        }
    });

    // ========== WebRTC Звонки ==========
    const iceServers = {
        iceServers: [
            { urls: 'stun:stun.l.google.com:19302' },
            { urls: 'stun:stun1.l.google.com:19302' },
            { urls: 'stun:stun2.l.google.com:19302' },
            { urls: 'stun:stun3.l.google.com:19302' }
        ],
        iceCandidatePoolSize: 10
    };

    // Настройки качества видео для SDP
    function setVideoBitrate(sdp, bitrate = 2500) {
        // Устанавливаем битрейт для видео (2.5 Mbps для 1080p)
        let lines = sdp.split('\n');
        let newLines = [];
        
        for (let i = 0; i < lines.length; i++) {
            newLines.push(lines[i]);
            if (lines[i].indexOf('m=video') === 0) {
                newLines.push(`b=AS:${bitrate}`);
            }
        }
        
        return newLines.join('\n');
    }

    let peerConnection = null;
    let localStream = null;
    let remoteStream = null;
    let currentCallId = null;
    let callTimerInterval = null;
    let callStartTime = null;
    let isVideoCall = false;
    let callUnsub = null;
    let isMuted = false;
    let isVideoOff = false;
    let isScreenSharing = false;
    let originalVideoTrack = null;

    // Кастомный рингтон (смесь Discord + Telegram стиля)
    let ringtoneCtx = null;
    let ringtoneInterval = null;
    let ringtoneGain = null;
    
    const ringtone = {
        _playing: false,
        loop: true,
        volume: 0.7,
        
        play: function() {
            if (this._playing) return Promise.resolve();
            this._playing = true;
            
            try {
                ringtoneCtx = new (window.AudioContext || window.webkitAudioContext)();
                ringtoneGain = ringtoneCtx.createGain();
                ringtoneGain.connect(ringtoneCtx.destination);
                ringtoneGain.gain.value = this.volume;
                
                const playTone = () => {
                    if (!this._playing) return;
                    
                    // Первый тон (высокий, как Discord)
                    const osc1 = ringtoneCtx.createOscillator();
                    const gain1 = ringtoneCtx.createGain();
                    osc1.connect(gain1);
                    gain1.connect(ringtoneGain);
                    osc1.frequency.value = 880;
                    osc1.type = 'sine';
                    gain1.gain.setValueAtTime(0.3, ringtoneCtx.currentTime);
                    gain1.gain.exponentialRampToValueAtTime(0.01, ringtoneCtx.currentTime + 0.15);
                    osc1.start(ringtoneCtx.currentTime);
                    osc1.stop(ringtoneCtx.currentTime + 0.15);
                    
                    // Второй тон (ниже, мягче - как Telegram)
                    setTimeout(() => {
                        if (!this._playing) return;
                        const osc2 = ringtoneCtx.createOscillator();
                        const gain2 = ringtoneCtx.createGain();
                        osc2.connect(gain2);
                        gain2.connect(ringtoneGain);
                        osc2.frequency.value = 659;
                        osc2.type = 'sine';
                        gain2.gain.setValueAtTime(0.25, ringtoneCtx.currentTime);
                        gain2.gain.exponentialRampToValueAtTime(0.01, ringtoneCtx.currentTime + 0.2);
                        osc2.start(ringtoneCtx.currentTime);
                        osc2.stop(ringtoneCtx.currentTime + 0.2);
                    }, 180);
                    
                    // Третий тон (ещё ниже, завершающий)
                    setTimeout(() => {
                        if (!this._playing) return;
                        const osc3 = ringtoneCtx.createOscillator();
                        const gain3 = ringtoneCtx.createGain();
                        osc3.connect(gain3);
                        gain3.connect(ringtoneGain);
                        osc3.frequency.value = 523;
                        osc3.type = 'sine';
                        gain3.gain.setValueAtTime(0.2, ringtoneCtx.currentTime);
                        gain3.gain.exponentialRampToValueAtTime(0.01, ringtoneCtx.currentTime + 0.25);
                        osc3.start(ringtoneCtx.currentTime);
                        osc3.stop(ringtoneCtx.currentTime + 0.25);
                    }, 380);
                };
                
                playTone();
                if (this.loop) {
                    ringtoneInterval = setInterval(playTone, 2000);
                }
            } catch(e) {
                console.log('Audio error:', e);
            }
            
            return Promise.resolve();
        },
        
        pause: function() {
            this._playing = false;
            if (ringtoneInterval) {
                clearInterval(ringtoneInterval);
                ringtoneInterval = null;
            }
            if (ringtoneCtx) {
                ringtoneCtx.close().catch(() => {});
                ringtoneCtx = null;
            }
        },
        
        get currentTime() { return 0; },
        set currentTime(v) {}
    };

    // Звук исходящего звонка (гудки как в телефоне)
    let dialToneCtx = null;
    let dialToneInterval = null;
    
    const dialTone = {
        _playing: false,
        loop: true,
        volume: 0.4,
        
        play: function() {
            if (this._playing) return Promise.resolve();
            this._playing = true;
            
            try {
                dialToneCtx = new (window.AudioContext || window.webkitAudioContext)();
                
                const playBeep = () => {
                    if (!this._playing || !dialToneCtx) return;
                    
                    // Классический телефонный гудок (два тона)
                    const osc1 = dialToneCtx.createOscillator();
                    const osc2 = dialToneCtx.createOscillator();
                    const gain = dialToneCtx.createGain();
                    
                    osc1.connect(gain);
                    osc2.connect(gain);
                    gain.connect(dialToneCtx.destination);
                    
                    // Частоты телефонного гудка (425 Hz в Европе, 440+480 Hz в США)
                    osc1.frequency.value = 440;
                    osc2.frequency.value = 480;
                    osc1.type = 'sine';
                    osc2.type = 'sine';
                    
                    gain.gain.setValueAtTime(this.volume, dialToneCtx.currentTime);
                    gain.gain.setValueAtTime(this.volume, dialToneCtx.currentTime + 0.8);
                    gain.gain.exponentialRampToValueAtTime(0.01, dialToneCtx.currentTime + 0.85);
                    
                    osc1.start(dialToneCtx.currentTime);
                    osc2.start(dialToneCtx.currentTime);
                    osc1.stop(dialToneCtx.currentTime + 0.85);
                    osc2.stop(dialToneCtx.currentTime + 0.85);
                };
                
                playBeep();
                if (this.loop) {
                    dialToneInterval = setInterval(playBeep, 3000); // Гудок каждые 3 секунды
                }
            } catch(e) {
                console.log('Dial tone error:', e);
            }
            
            return Promise.resolve();
        },
        
        pause: function() {
            this._playing = false;
            if (dialToneInterval) {
                clearInterval(dialToneInterval);
                dialToneInterval = null;
            }
            if (dialToneCtx) {
                dialToneCtx.close().catch(() => {});
                dialToneCtx = null;
            }
        },
        
        get currentTime() { return 0; },
        set currentTime(v) {}
    };

    // Звук завершения звонка
    const endCallSound = {
        play: function() {
            try {
                const ctx = new (window.AudioContext || window.webkitAudioContext)();
                
                // Три нисходящих тона (как при завершении звонка)
                const playEndTone = (freq, delay, duration) => {
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    osc.connect(gain);
                    gain.connect(ctx.destination);
                    
                    osc.frequency.value = freq;
                    osc.type = 'sine';
                    
                    gain.gain.setValueAtTime(0, ctx.currentTime + delay);
                    gain.gain.linearRampToValueAtTime(0.3, ctx.currentTime + delay + 0.02);
                    gain.gain.setValueAtTime(0.3, ctx.currentTime + delay + duration - 0.05);
                    gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + delay + duration);
                    
                    osc.start(ctx.currentTime + delay);
                    osc.stop(ctx.currentTime + delay + duration);
                };
                
                // Три коротких нисходящих тона
                playEndTone(880, 0, 0.15);      // Высокий
                playEndTone(698, 0.12, 0.15);   // Средний
                playEndTone(523, 0.24, 0.2);    // Низкий
                
                // Закрываем контекст после воспроизведения
                setTimeout(() => ctx.close().catch(() => {}), 500);
            } catch(e) {
                console.log('End call sound error:', e);
            }
            return Promise.resolve();
        }
    };

    // Определение мобильного устройства
    function isMobileDevice() {
        return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
               (navigator.maxTouchPoints && navigator.maxTouchPoints > 2 && /MacIntel/.test(navigator.platform));
    }

    // Получение оптимальных настроек аудио для устройства
    function getOptimalAudioConstraints() {
        const isMobile = isMobileDevice();
        const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
        
        if (isMobile) {
            return {
                echoCancellation: true,
                noiseSuppression: true,
                autoGainControl: true,
                // Специальные настройки для мобильных
                sampleRate: isIOS ? 48000 : 44100,
                channelCount: 1, // Моно для стабильности на мобильных
                volume: 1.0,
                // Дополнительные настройки для iOS
                ...(isIOS && {
                    latency: 0.01,
                    sampleSize: 16
                })
            };
        }
        
        return {
            echoCancellation: true,
            noiseSuppression: true,
            autoGainControl: true,
            sampleRate: 48000,
            channelCount: 2
        };
    }

    // Исправление аудио контекста для iOS
    async function fixIOSAudioContext() {
        if (/iPad|iPhone|iPod/.test(navigator.userAgent)) {
            try {
                // Создаём временный аудио контекст для разблокировки
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                gainNode.gain.value = 0; // Беззвучно
                
                oscillator.start();
                oscillator.stop(audioContext.currentTime + 0.1);
                
                await audioContext.close();
            } catch (e) {
                console.log('iOS audio context fix failed:', e);
            }
        }
    }

    // Настройка аудио элемента для мобильных устройств
    function setupMobileAudio(audioElement) {
        if (!audioElement) return;
        
        const isMobile = isMobileDevice();
        const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
        
        if (isMobile) {
            audioElement.setAttribute('playsinline', 'true');
            audioElement.setAttribute('webkit-playsinline', 'true');
            audioElement.muted = false;
            
            if (isIOS) {
                // Специальные настройки для iOS
                audioElement.volume = 1.0;
                audioElement.preload = 'auto';
                
                // Принудительное воспроизведение для iOS
                audioElement.addEventListener('loadedmetadata', () => {
                    audioElement.play().catch(e => console.log('iOS audio play failed:', e));
                });
            }
            
            // Обработка ошибок воспроизведения
            audioElement.addEventListener('error', (e) => {
                console.log('Mobile audio error:', e);
                // Попытка перезапуска
                setTimeout(() => {
                    audioElement.load();
                    audioElement.play().catch(err => console.log('Audio restart failed:', err));
                }, 1000);
            });
        }
    }

    // Слушаем входящие звонки
    function listenForCalls() {
        if (!me) return;
        const callRef = doc(db, 'artifacts', appId, 'users', me.uid, 'incoming_call', 'current');
        
        callUnsub = onSnapshot(callRef, async (snap) => {
            if (snap.exists()) {
                const callData = snap.data();
                if (callData.status === 'ringing' && !currentCallId && !document.getElementById('active-call-screen').classList.contains('active')) {
                    showIncomingCall(callData);
                } else if (callData.status === 'cleared' || callData.status === 'answered') {
                    // Скрываем экран входящего звонка если он показан
                    const incomingScreen = document.getElementById('incoming-call-screen');
                    if (!incomingScreen.classList.contains('hidden')) {
                        incomingScreen.classList.add('hidden');
                        ringtone.pause();
                        ringtone.currentTime = 0;
                    }
                }
            } else {
                // Если документ не существует, тоже скрываем экран входящего звонка
                const incomingScreen = document.getElementById('incoming-call-screen');
                if (!incomingScreen.classList.contains('hidden')) {
                    incomingScreen.classList.add('hidden');
                    ringtone.pause();
                    ringtone.currentTime = 0;
                }
            }
        });
    }

    function showIncomingCall(callData) {
        currentCallId = callData.callId;
        isVideoCall = callData.isVideo;
        
        const callerAvatarEl = document.getElementById('caller-avatar');
        const callerNameEl = document.getElementById('caller-name');
        const callTypeEl = document.getElementById('call-type-label');
        
        // Проверяем, это групповой звонок
        if (callData.isGroupCall) {
            isGroupCall = true;
            // Показываем иконку группы
            callerAvatarEl.innerHTML = `<i class="fas fa-users text-3xl"></i>`;
            callerNameEl.innerText = callData.groupName;
            callTypeEl.innerText = isVideoCall ? 
                (currentLang === 'ru' ? 'Групповой видео звонок' : 'Group video call') : 
                (currentLang === 'ru' ? 'Групповой аудио звонок' : 'Group audio call');
        } else {
            isGroupCall = false;
            // Устанавливаем аватар (сначала буква, потом загружаем из Firebase)
            callerAvatarEl.innerHTML = callData.callerName[0].toUpperCase();
            
            getDoc(doc(db, 'artifacts', appId, 'public', 'data', 'users', callData.callerId)).then(userDoc => {
                if (userDoc.exists() && userDoc.data().avatar) {
                    callerAvatarEl.innerHTML = `<img src="${userDoc.data().avatar}" class="w-full h-full object-cover rounded-full">`;
                }
            }).catch(() => {});
            
            callerNameEl.innerText = '@' + callData.callerName;
            callTypeEl.innerText = isVideoCall ? 
                (currentLang === 'ru' ? 'Видео звонок' : 'Video call') : 
                (currentLang === 'ru' ? 'Аудио звонок' : 'Audio call');
        }
        
        document.getElementById('incoming-call-screen').classList.remove('hidden');
        ringtone.play().catch(() => {});
    }

    // Групповые звонки
    let groupCallConnections = {}; // uid -> RTCPeerConnection
    let groupCallStreams = {}; // uid -> MediaStream
    let isGroupCall = false;

    window.startCall = async (withVideo) => {
        // Проверяем, это групповой или личный звонок
        if (activeGroup) {
            await startGroupCall(withVideo);
            return;
        }
        
        if (!activeChatPartner || !me) return;
        
        isVideoCall = withVideo;
        currentCallId = `${me.uid}_${activeChatPartner.uid}_${Date.now()}`;
        
        // Устанавливаем аватар (сначала буква, потом загружаем из Firebase)
        const calleeAvatarEl = document.getElementById('callee-avatar');
        calleeAvatarEl.innerHTML = activeChatPartner.username[0].toUpperCase();
        
        getDoc(doc(db, 'artifacts', appId, 'public', 'data', 'users', activeChatPartner.uid)).then(userDoc => {
            if (userDoc.exists() && userDoc.data().avatar) {
                calleeAvatarEl.innerHTML = `<img src="${userDoc.data().avatar}" class="w-full h-full object-cover rounded-full">`;
            }
        }).catch(() => {});
        
        document.getElementById('callee-name').innerText = '@' + activeChatPartner.username;
        document.getElementById('outgoing-call-screen').classList.remove('hidden');
        
        // Воспроизводим звук исходящего звонка (гудки)
        dialTone.play().catch(() => {});
        
        try {
            // Настройки видео 1080p для высокого качества
            const videoConstraints = withVideo ? {
                width: { ideal: 1920, min: 1280 },
                height: { ideal: 1080, min: 720 },
                frameRate: { ideal: 30, min: 24 },
                facingMode: 'user'
            } : false;
            
            localStream = await navigator.mediaDevices.getUserMedia({
                audio: getOptimalAudioConstraints(),
                video: videoConstraints
            });
            
            // Исправляем аудио для мобильных устройств
            await fixIOSAudioContext();
            
            // Закрываем предыдущее соединение если есть
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }
            
            // Создаем offer
            peerConnection = new RTCPeerConnection(iceServers);
            
            localStream.getTracks().forEach(track => {
                peerConnection.addTrack(track, localStream);
            });
            
            peerConnection.onicecandidate = async (e) => {
                if (e.candidate) {
                    await addDoc(collection(db, 'artifacts', appId, 'public', 'data', 'calls', currentCallId, 'ice_candidates_caller'), {
                        candidate: e.candidate.toJSON(),
                        timestamp: serverTimestamp()
                    });
                }
            };
            
            peerConnection.ontrack = (e) => {
                remoteStream = e.streams[0];
                const remoteVideo = document.getElementById('remote-video');
                remoteVideo.srcObject = remoteStream;
                
                // Настраиваем аудио для мобильных устройств
                setupMobileAudio(remoteVideo);
            };
            
            const offer = await peerConnection.createOffer();
            // Применяем высокий битрейт для 1080p
            const modifiedOffer = {
                type: offer.type,
                sdp: withVideo ? setVideoBitrate(offer.sdp, 2500) : offer.sdp
            };
            await peerConnection.setLocalDescription(modifiedOffer);
            
            // Сохраняем звонок в Firebase
            await setDoc(doc(db, 'artifacts', appId, 'public', 'data', 'calls', currentCallId), {
                callerId: me.uid,
                callerName: me.username,
                calleeId: activeChatPartner.uid,
                calleeName: activeChatPartner.username,
                isVideo: withVideo,
                offer: { type: modifiedOffer.type, sdp: modifiedOffer.sdp },
                status: 'ringing',
                timestamp: serverTimestamp()
            });
            
            // Уведомляем получателя
            await setDoc(doc(db, 'artifacts', appId, 'users', activeChatPartner.uid, 'incoming_call', 'current'), {
                callId: currentCallId,
                callerId: me.uid,
                callerName: me.username,
                isVideo: withVideo,
                status: 'ringing'
            });
            
            // Слушаем ответ
            const callDocRef = doc(db, 'artifacts', appId, 'public', 'data', 'calls', currentCallId);
            onSnapshot(callDocRef, async (snap) => {
                if (!snap.exists()) return;
                const data = snap.data();
                
                if (data.status === 'answered' && data.answer && peerConnection.signalingState !== 'stable') {
                    try {
                        await peerConnection.setRemoteDescription(new RTCSessionDescription(data.answer));
                        showActiveCall(activeChatPartner.username);
                    } catch (err) {
                        console.log('Set remote description error:', err);
                    }
                }
                
                if (data.status === 'declined' || data.status === 'ended') {
                    endCallCleanup();
                }
                
                // Слушаем изменения демонстрации экрана
                if (data.screenSharing && data.screenSharing.userId !== me.uid) {
                    const { userName, isSharing } = data.screenSharing;
                    if (isSharing) {
                        showScreenShareNotification(`${userName} демонстрирует экран`);
                    } else {
                        showScreenShareNotification(`${userName} остановил демонстрацию экрана`);
                    }
                }
            });
            
            // Слушаем ICE кандидаты от получателя
            onSnapshot(collection(db, 'artifacts', appId, 'public', 'data', 'calls', currentCallId, 'ice_candidates_callee'), (snap) => {
                snap.docChanges().forEach(async (change) => {
                    if (change.type === 'added' && peerConnection) {
                        const data = change.doc.data();
                        try {
                            // Проверяем, что remoteDescription установлен
                            if (peerConnection.remoteDescription) {
                                await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
                            } else {
                                console.warn('Пропускаем ICE кандидат - remoteDescription не установлен');
                            }
                        } catch (err) {
                            // Игнорируем ошибку "No such transceiver" - это нормально во время пересогласования
                            if (err.message && err.message.includes('No such transceiver')) {
                                console.log('ICE кандидат пропущен (transceiver ещё не создан) - это нормально');
                            } else {
                                console.error('Ошибка добавления ICE кандидата:', err);
                            }
                        }
                    }
                });
            });
            
        } catch (err) {
            console.error('Ошибка звонка:', err);
            alert('Не удалось получить доступ к камере/микрофону');
            endCallCleanup();
        }
    };

    // Групповой звонок
    async function startGroupCall(withVideo) {
        if (!activeGroup || !me) return;
        
        isVideoCall = withVideo;
        isGroupCall = true;
        currentCallId = `group_${activeGroup.id}_${Date.now()}`;
        
        // Показываем экран исходящего звонка
        const calleeAvatarEl = document.getElementById('callee-avatar');
        calleeAvatarEl.innerHTML = `<i class="fas fa-users text-2xl"></i>`;
        document.getElementById('callee-name').innerText = activeGroup.name;
        document.getElementById('outgoing-call-screen').classList.remove('hidden');
        
        try {
            const videoConstraints = withVideo ? {
                width: { ideal: 1280, min: 640 },
                height: { ideal: 720, min: 480 },
                frameRate: { ideal: 24, min: 15 },
                facingMode: 'user'
            } : false;
            
            localStream = await navigator.mediaDevices.getUserMedia({
                audio: getOptimalAudioConstraints(),
                video: videoConstraints
            });
            
            // Исправляем аудио для мобильных устройств
            await fixIOSAudioContext();
            
            // Создаём запись о групповом звонке
            await setDoc(doc(db, 'artifacts', appId, 'public', 'data', 'group_calls', currentCallId), {
                groupId: activeGroup.id,
                groupName: activeGroup.name,
                callerId: me.uid,
                callerName: me.username,
                isVideo: withVideo,
                participants: [me.uid],
                status: 'active',
                timestamp: serverTimestamp()
            });
            
            // Уведомляем всех участников группы
            for (const memberId of activeGroup.members) {
                if (memberId === me.uid) continue;
                
                await setDoc(doc(db, 'artifacts', appId, 'users', memberId, 'incoming_call', 'current'), {
                    callId: currentCallId,
                    callerId: me.uid,
                    callerName: me.username,
                    isVideo: withVideo,
                    isGroupCall: true,
                    groupName: activeGroup.name,
                    groupId: activeGroup.id,
                    status: 'ringing'
                });
            }
            
            // Показываем активный звонок
            showActiveCall(activeGroup.name);
            
            // Слушаем новых участников
            onSnapshot(doc(db, 'artifacts', appId, 'public', 'data', 'group_calls', currentCallId), async (snap) => {
                if (!snap.exists()) return;
                const data = snap.data();
                
                if (data.status === 'ended') {
                    endGroupCallCleanup();
                    return;
                }
                
                // Слушаем изменения демонстрации экрана
                if (data.screenSharing && data.screenSharing.userId !== me.uid) {
                    const { userName, isSharing } = data.screenSharing;
                    if (isSharing) {
                        showScreenShareNotification(`${userName} демонстрирует экран`);
                    } else {
                        showScreenShareNotification(`${userName} остановил демонстрацию экрана`);
                    }
                }
                
                // Подключаемся к новым участникам
                for (const participantId of data.participants || []) {
                    if (participantId === me.uid) continue;
                    if (groupCallConnections[participantId]) continue;
                    
                    await connectToGroupParticipant(participantId, true);
                }
            });
            
        } catch (err) {
            console.error('Ошибка группового звонка:', err);
            alert('Не удалось получить доступ к камере/микрофону');
            endGroupCallCleanup();
        }
    }

    async function connectToGroupParticipant(participantId, isInitiator) {
        const pc = new RTCPeerConnection(iceServers);
        groupCallConnections[participantId] = pc;
        
        localStream.getTracks().forEach(track => {
            pc.addTrack(track, localStream);
        });
        
        pc.ontrack = (e) => {
            groupCallStreams[participantId] = e.streams[0];
            
            // Создаём аудио элемент для воспроизведения звука от участника
            let audioEl = document.getElementById(`group-audio-${participantId}`);
            if (!audioEl) {
                audioEl = document.createElement('audio');
                audioEl.id = `group-audio-${participantId}`;
                audioEl.autoplay = true;
                audioEl.playsInline = true;
                document.body.appendChild(audioEl);
            }
            audioEl.srcObject = e.streams[0];
            
            // Настраиваем аудио для мобильных устройств
            setupMobileAudio(audioEl);
            
            audioEl.play().catch(err => console.log('Audio play error:', err));
            
            updateGroupCallUI();
        };
        
        const pairId = [me.uid, participantId].sort().join('_');
        
        pc.onicecandidate = async (e) => {
            if (e.candidate) {
                // Используем подколлекцию ice_candidates с pairId в имени документа
                await addDoc(collection(db, 'artifacts', appId, 'public', 'data', 'group_calls', currentCallId, 'ice_candidates'), {
                    pairId: pairId,
                    from: me.uid,
                    candidate: e.candidate.toJSON(),
                    timestamp: serverTimestamp()
                });
            }
        };
        
        // Слушаем ICE кандидаты
        onSnapshot(collection(db, 'artifacts', appId, 'public', 'data', 'group_calls', currentCallId, 'ice_candidates'), (snap) => {
            snap.docChanges().forEach(async (change) => {
                if (change.type === 'added') {
                    const data = change.doc.data();
                    if (data.pairId === pairId && data.from !== me.uid && pc.remoteDescription) {
                        try {
                            await pc.addIceCandidate(new RTCIceCandidate(data.candidate));
                        } catch (err) {
                            // Игнорируем ошибку "No such transceiver"
                            if (err.message && err.message.includes('No such transceiver')) {
                                console.log('ICE кандидат пропущен (transceiver ещё не создан)');
                            } else {
                                console.error('ICE candidate error:', err);
                            }
                        }
                    }
                }
            });
        });
        
        if (isInitiator) {
            const offer = await pc.createOffer();
            await pc.setLocalDescription(offer);
            
            await setDoc(doc(db, 'artifacts', appId, 'public', 'data', 'group_calls', currentCallId, 'signals', pairId), {
                offer: { type: offer.type, sdp: offer.sdp },
                from: me.uid,
                to: participantId
            });
            
            // Слушаем ответ
            onSnapshot(doc(db, 'artifacts', appId, 'public', 'data', 'group_calls', currentCallId, 'signals', pairId), async (snap) => {
                if (!snap.exists()) return;
                const data = snap.data();
                if (data.answer && data.from === participantId && pc.signalingState !== 'stable') {
                    try {
                        await pc.setRemoteDescription(new RTCSessionDescription(data.answer));
                    } catch (err) {
                        console.log('Set remote description error:', err);
                    }
                }
            });
        } else {
            // Слушаем offer
            onSnapshot(doc(db, 'artifacts', appId, 'public', 'data', 'group_calls', currentCallId, 'signals', pairId), async (snap) => {
                if (!snap.exists()) return;
                const data = snap.data();
                
                if (data.offer && data.from === participantId && !pc.remoteDescription) {
                    try {
                        await pc.setRemoteDescription(new RTCSessionDescription(data.offer));
                        const answer = await pc.createAnswer();
                        await pc.setLocalDescription(answer);
                        
                        await setDoc(doc(db, 'artifacts', appId, 'public', 'data', 'group_calls', currentCallId, 'signals', pairId), {
                            ...data,
                            answer: { type: answer.type, sdp: answer.sdp },
                            from: me.uid
                        }, { merge: true });
                    } catch (err) {
                        console.log('Offer handling error:', err);
                    }
                }
            });
        }
    }

    function updateGroupCallUI() {
        if (!isGroupCall) return;
        
        const participantCount = Object.keys(groupCallStreams).length + 1;
        const hasVideo = isVideoCall && localStream && localStream.getVideoTracks().length > 0;
        
        if (hasVideo) {
            // Видео звонок - показываем сетку видео
            const groupContainer = document.getElementById('group-call-participants');
            const videosGrid = document.getElementById('group-videos-grid');
            const audioOverlay = document.getElementById('audio-call-overlay');
            
            if (groupContainer && videosGrid) {
                groupContainer.classList.remove('hidden');
                if (audioOverlay) audioOverlay.classList.add('hidden');
                
                // Определяем сетку в зависимости от количества участников
                let gridCols = 'grid-cols-1';
                if (participantCount === 2) gridCols = 'grid-cols-2';
                else if (participantCount <= 4) gridCols = 'grid-cols-2';
                else if (participantCount <= 6) gridCols = 'grid-cols-3';
                else gridCols = 'grid-cols-4';
                
                videosGrid.className = `w-full h-full grid gap-2 p-2 ${gridCols}`;
                
                // Очищаем и перестраиваем
                videosGrid.innerHTML = '';
                
                // Добавляем локальное видео
                const localDiv = document.createElement('div');
                localDiv.className = 'relative rounded-xl overflow-hidden bg-slate-800';
                localDiv.innerHTML = `
                    <video autoplay playsinline muted class="w-full h-full object-cover"></video>
                    <div class="absolute bottom-2 left-2 bg-black/50 px-2 py-1 rounded text-white text-xs">
                        ${currentLang === 'ru' ? 'Вы' : 'You'}
                    </div>
                `;
                localDiv.querySelector('video').srcObject = localStream;
                videosGrid.appendChild(localDiv);
                
                // Добавляем видео участников
                for (const [participantId, stream] of Object.entries(groupCallStreams)) {
                    const participantDiv = document.createElement('div');
                    participantDiv.className = 'relative rounded-xl overflow-hidden bg-slate-800';
                    participantDiv.innerHTML = `
                        <video autoplay playsinline class="w-full h-full object-cover"></video>
                        <div class="absolute bottom-2 left-2 bg-black/50 px-2 py-1 rounded text-white text-xs" id="participant-name-${participantId}">
                            <i class="fas fa-user mr-1"></i>
                        </div>
                    `;
                    participantDiv.querySelector('video').srcObject = stream;
                    videosGrid.appendChild(participantDiv);
                    
                    // Загружаем имя участника
                    getDoc(doc(db, 'artifacts', appId, 'public', 'data', 'users', participantId)).then(userDoc => {
                        if (userDoc.exists()) {
                            const nameEl = document.getElementById(`participant-name-${participantId}`);
                            if (nameEl) nameEl.innerHTML = `<i class="fas fa-user mr-1"></i>${userDoc.data().username}`;
                        }
                    }).catch(() => {});
                }
            }
        } else {
            // Аудио звонок - показываем аватары участников
            const groupAudioContainer = document.getElementById('group-audio-participants');
            const singleAvatarContainer = document.getElementById('single-call-avatar-container');
            
            if (groupAudioContainer && participantCount > 1) {
                groupAudioContainer.classList.remove('hidden');
                groupAudioContainer.classList.add('flex');
                if (singleAvatarContainer) singleAvatarContainer.classList.add('hidden');
                
                groupAudioContainer.innerHTML = '';
                
                // Добавляем свой аватар
                const myDiv = document.createElement('div');
                myDiv.className = 'flex flex-col items-center';
                myDiv.innerHTML = `
                    <div class="w-20 h-20 rounded-full bg-indigo-500/30 flex items-center justify-center text-2xl font-bold text-white border-2 border-green-400 overflow-hidden">
                        ${me.avatar ? `<img src="${me.avatar}" class="w-full h-full object-cover">` : me.username[0].toUpperCase()}
                    </div>
                    <p class="text-white text-xs mt-2">${currentLang === 'ru' ? 'Вы' : 'You'}</p>
                `;
                groupAudioContainer.appendChild(myDiv);
                
                // Добавляем аватары участников
                for (const participantId of Object.keys(groupCallStreams)) {
                    const participantDiv = document.createElement('div');
                    participantDiv.className = 'flex flex-col items-center';
                    participantDiv.id = `audio-participant-${participantId}`;
                    participantDiv.innerHTML = `
                        <div class="w-20 h-20 rounded-full bg-indigo-500/30 flex items-center justify-center text-2xl font-bold text-white border-2 border-indigo-400/50 overflow-hidden animate-pulse">
                            <i class="fas fa-user"></i>
                        </div>
                        <p class="text-white text-xs mt-2">...</p>
                    `;
                    groupAudioContainer.appendChild(participantDiv);
                    
                    // Загружаем данные участника
                    getDoc(doc(db, 'artifacts', appId, 'public', 'data', 'users', participantId)).then(userDoc => {
                        if (userDoc.exists()) {
                            const userData = userDoc.data();
                            const el = document.getElementById(`audio-participant-${participantId}`);
                            if (el) {
                                el.innerHTML = `
                                    <div class="w-20 h-20 rounded-full bg-indigo-500/30 flex items-center justify-center text-2xl font-bold text-white border-2 border-green-400 overflow-hidden">
                                        ${userData.avatar ? `<img src="${userData.avatar}" class="w-full h-full object-cover">` : userData.username[0].toUpperCase()}
                                    </div>
                                    <p class="text-white text-xs mt-2">@${userData.username}</p>
                                `;
                            }
                        }
                    }).catch(() => {});
                }
            } else {
                // Один участник - показываем обычный UI
                if (groupAudioContainer) {
                    groupAudioContainer.classList.add('hidden');
                    groupAudioContainer.classList.remove('flex');
                }
                if (singleAvatarContainer) singleAvatarContainer.classList.remove('hidden');
                
                const avatarEl = document.getElementById('active-call-avatar');
                if (avatarEl) {
                    avatarEl.innerHTML = `<i class="fas fa-users"></i><span class="absolute -bottom-1 -right-1 bg-green-500 text-white text-xs rounded-full w-6 h-6 flex items-center justify-center">${participantCount}</span>`;
                }
            }
        }
        
        // Обновляем счётчик участников в заголовке
        const callNameEl = document.getElementById('active-call-name');
        if (callNameEl && isGroupCall) {
            const currentName = callNameEl.innerText.split(' (')[0];
            callNameEl.innerText = `${currentName} (${participantCount})`;
        }
    }

    function endGroupCallCleanup() {
        // Удаляем аудио элементы участников
        Object.keys(groupCallConnections).forEach(participantId => {
            const audioEl = document.getElementById(`group-audio-${participantId}`);
            if (audioEl) {
                audioEl.srcObject = null;
                audioEl.remove();
            }
        });
        
        // Закрываем все соединения
        Object.values(groupCallConnections).forEach(pc => pc.close());
        groupCallConnections = {};
        groupCallStreams = {};
        isGroupCall = false;
        
        // Сбрасываем UI группового звонка
        const groupContainer = document.getElementById('group-call-participants');
        const groupAudioContainer = document.getElementById('group-audio-participants');
        const singleAvatarContainer = document.getElementById('single-call-avatar-container');
        
        if (groupContainer) groupContainer.classList.add('hidden');
        if (groupAudioContainer) {
            groupAudioContainer.classList.add('hidden');
            groupAudioContainer.classList.remove('flex');
            groupAudioContainer.innerHTML = '';
        }
        if (singleAvatarContainer) singleAvatarContainer.classList.remove('hidden');
        
        endCallCleanup();
    }

    window.acceptCall = async () => {
        ringtone.pause();
        ringtone.currentTime = 0;
        document.getElementById('incoming-call-screen').classList.add('hidden');
        
        // Проверяем, это групповой звонок
        const incomingCallDoc = await getDoc(doc(db, 'artifacts', appId, 'users', me.uid, 'incoming_call', 'current'));
        const incomingData = incomingCallDoc.exists() ? incomingCallDoc.data() : {};
        
        if (incomingData.isGroupCall) {
            await acceptGroupCall(incomingData);
            return;
        }
        
        try {
            // Настройки видео 1080p для высокого качества
            const videoConstraints = isVideoCall ? {
                width: { ideal: 1920, min: 1280 },
                height: { ideal: 1080, min: 720 },
                frameRate: { ideal: 30, min: 24 },
                facingMode: 'user'
            } : false;
            
            localStream = await navigator.mediaDevices.getUserMedia({
                audio: getOptimalAudioConstraints(),
                video: videoConstraints
            });
            
            // Исправляем аудио для мобильных устройств
            await fixIOSAudioContext();
            
            // Закрываем предыдущее соединение если есть
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }
            
            peerConnection = new RTCPeerConnection(iceServers);
            
            localStream.getTracks().forEach(track => {
                peerConnection.addTrack(track, localStream);
            });
            
            peerConnection.onicecandidate = async (e) => {
                if (e.candidate) {
                    await addDoc(collection(db, 'artifacts', appId, 'public', 'data', 'calls', currentCallId, 'ice_candidates_callee'), {
                        candidate: e.candidate.toJSON(),
                        timestamp: serverTimestamp()
                    });
                }
            };
            
            peerConnection.ontrack = (e) => {
                remoteStream = e.streams[0];
                const remoteVideo = document.getElementById('remote-video');
                remoteVideo.srcObject = remoteStream;
                
                // Настраиваем аудио для мобильных устройств
                setupMobileAudio(remoteVideo);
            };
            
            // Получаем offer
            const callDoc = await getDoc(doc(db, 'artifacts', appId, 'public', 'data', 'calls', currentCallId));
            const callData = callDoc.data();
            
            if (callData && callData.offer && peerConnection.signalingState === 'stable') {
                await peerConnection.setRemoteDescription(new RTCSessionDescription(callData.offer));
            }
            
            const answer = await peerConnection.createAnswer();
            // Применяем высокий битрейт для 1080p
            const modifiedAnswer = {
                type: answer.type,
                sdp: isVideoCall ? setVideoBitrate(answer.sdp, 2500) : answer.sdp
            };
            await peerConnection.setLocalDescription(modifiedAnswer);
            
            // Отправляем answer
            await setDoc(doc(db, 'artifacts', appId, 'public', 'data', 'calls', currentCallId), {
                answer: { type: modifiedAnswer.type, sdp: modifiedAnswer.sdp },
                status: 'answered'
            }, { merge: true });
            
            // Очищаем уведомление
            await setDoc(doc(db, 'artifacts', appId, 'users', me.uid, 'incoming_call', 'current'), { status: 'answered' });
            
            // Слушаем ICE кандидаты от звонящего
            onSnapshot(collection(db, 'artifacts', appId, 'public', 'data', 'calls', currentCallId, 'ice_candidates_caller'), (snap) => {
                snap.docChanges().forEach(async (change) => {
                    if (change.type === 'added' && peerConnection) {
                        const data = change.doc.data();
                        try {
                            // Проверяем, что remoteDescription установлен
                            if (peerConnection.remoteDescription) {
                                await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
                            } else {
                                console.warn('Пропускаем ICE кандидат - remoteDescription не установлен');
                            }
                        } catch (err) {
                            // Игнорируем ошибку "No such transceiver" - это нормально во время пересогласования
                            if (err.message && err.message.includes('No such transceiver')) {
                                console.log('ICE кандидат пропущен (transceiver ещё не создан) - это нормально');
                            } else {
                                console.error('Ошибка добавления ICE кандидата:', err);
                            }
                        }
                    }
                });
            });
            
            // Слушаем завершение звонка
            onSnapshot(doc(db, 'artifacts', appId, 'public', 'data', 'calls', currentCallId), async (snap) => {
                if (snap.exists()) {
                    const data = snap.data();
                    if (data.status === 'ended') {
                        endCallCleanup();
                    }
                    
                    // Слушаем изменения демонстрации экрана
                    if (data.screenSharing && data.screenSharing.userId !== me.uid) {
                        const { userName, isSharing } = data.screenSharing;
                        if (isSharing) {
                            showScreenShareNotification(`${userName} демонстрирует экран`);
                        } else {
                            showScreenShareNotification(`${userName} остановил демонстрацию экрана`);
                        }
                    }
                }
            });
            
            showActiveCall(callData.callerName);
            
        } catch (err) {
            console.error('Ошибка принятия звонка:', err);
            alert('Не удалось получить доступ к камере/микрофону');
            declineCall();
        }
    };

    window.declineCall = async () => {
        ringtone.pause();
        ringtone.currentTime = 0;
        document.getElementById('incoming-call-screen').classList.add('hidden');
        
        // Полностью удаляем уведомление о входящем звонке
        await deleteDoc(doc(db, 'artifacts', appId, 'users', me.uid, 'incoming_call', 'current'));
        
        if (isGroupCall) {
            // Для группового звонка просто отклоняем - не завершаем весь звонок
            endGroupCallCleanup();
        } else if (currentCallId) {
            await setDoc(doc(db, 'artifacts', appId, 'public', 'data', 'calls', currentCallId), {
                status: 'declined'
            }, { merge: true });
            endCallCleanup();
        } else {
            endCallCleanup();
        }
    };

    async function acceptGroupCall(callData) {
        isGroupCall = true;
        isVideoCall = callData.isVideo;
        currentCallId = callData.callId;
        
        try {
            const videoConstraints = isVideoCall ? {
                width: { ideal: 1280, min: 640 },
                height: { ideal: 720, min: 480 },
                frameRate: { ideal: 24, min: 15 },
                facingMode: 'user'
            } : false;
            
            localStream = await navigator.mediaDevices.getUserMedia({
                audio: getOptimalAudioConstraints(),
                video: videoConstraints
            });
            
            // Исправляем аудио для мобильных устройств
            await fixIOSAudioContext();
            
            // Добавляем себя в участники
            const callDocRef = doc(db, 'artifacts', appId, 'public', 'data', 'group_calls', currentCallId);
            const callDoc = await getDoc(callDocRef);
            
            if (callDoc.exists()) {
                const participants = callDoc.data().participants || [];
                if (!participants.includes(me.uid)) {
                    participants.push(me.uid);
                    await setDoc(callDocRef, { participants }, { merge: true });
                }
                
                // Подключаемся к существующим участникам
                for (const participantId of participants) {
                    if (participantId === me.uid) continue;
                    await connectToGroupParticipant(participantId, false);
                }
            }
            
            // Очищаем уведомление
            await setDoc(doc(db, 'artifacts', appId, 'users', me.uid, 'incoming_call', 'current'), { status: 'answered' });
            
            showActiveCall(callData.groupName);
            
            // Слушаем изменения участников
            onSnapshot(callDocRef, async (snap) => {
                if (!snap.exists()) return;
                const data = snap.data();
                
                if (data.status === 'ended') {
                    endGroupCallCleanup();
                    return;
                }
                
                // Слушаем изменения демонстрации экрана
                if (data.screenSharing && data.screenSharing.userId !== me.uid) {
                    const { userName, isSharing } = data.screenSharing;
                    if (isSharing) {
                        showScreenShareNotification(`${userName} демонстрирует экран`);
                    } else {
                        showScreenShareNotification(`${userName} остановил демонстрацию экрана`);
                    }
                }
                
                for (const participantId of data.participants || []) {
                    if (participantId === me.uid) continue;
                    if (groupCallConnections[participantId]) continue;
                    await connectToGroupParticipant(participantId, false);
                }
            });
            
        } catch (err) {
            console.error('Ошибка принятия группового звонка:', err);
            alert('Не удалось получить доступ к камере/микрофону');
            endGroupCallCleanup();
        }
    }

    window.cancelCall = async () => {
        // Останавливаем звук исходящего звонка
        dialTone.pause();
        dialTone.currentTime = 0;
        
        document.getElementById('outgoing-call-screen').classList.add('hidden');
        
        if (isGroupCall && currentCallId && activeGroup) {
            // Отменяем групповой звонок
            await setDoc(doc(db, 'artifacts', appId, 'public', 'data', 'group_calls', currentCallId), {
                status: 'ended'
            }, { merge: true });
            
            // Очищаем уведомления у всех участников
            for (const memberId of activeGroup.members) {
                if (memberId === me.uid) continue;
                await setDoc(doc(db, 'artifacts', appId, 'users', memberId, 'incoming_call', 'current'), { status: 'cleared' });
            }
            
            endGroupCallCleanup();
        } else if (currentCallId && activeChatPartner) {
            await setDoc(doc(db, 'artifacts', appId, 'public', 'data', 'calls', currentCallId), {
                status: 'ended'
            }, { merge: true });
            await setDoc(doc(db, 'artifacts', appId, 'users', activeChatPartner.uid, 'incoming_call', 'current'), { status: 'cleared' });
            endCallCleanup();
        } else {
            endCallCleanup();
        }
    };

    window.endCall = async () => {
        if (isGroupCall && currentCallId) {
            // Для группового звонка - удаляем себя из участников
            const callDocRef = doc(db, 'artifacts', appId, 'public', 'data', 'group_calls', currentCallId);
            const callDoc = await getDoc(callDocRef);
            
            if (callDoc.exists()) {
                const participants = (callDoc.data().participants || []).filter(id => id !== me.uid);
                
                if (participants.length === 0) {
                    // Последний участник - завершаем звонок
                    await setDoc(callDocRef, { status: 'ended' }, { merge: true });
                } else {
                    await setDoc(callDocRef, { participants }, { merge: true });
                }
            }
            
            // Полностью удаляем документ входящего звонка
            await deleteDoc(doc(db, 'artifacts', appId, 'users', me.uid, 'incoming_call', 'current'));
            
            endGroupCallCleanup();
        } else if (currentCallId) {
            await setDoc(doc(db, 'artifacts', appId, 'public', 'data', 'calls', currentCallId), {
                status: 'ended'
            }, { merge: true });
            
            // Полностью удаляем документ входящего звонка
            await deleteDoc(doc(db, 'artifacts', appId, 'users', me.uid, 'incoming_call', 'current'));
            
            endCallCleanup();
        } else {
            // Полностью удаляем документ входящего звонка на всякий случай
            await deleteDoc(doc(db, 'artifacts', appId, 'users', me.uid, 'incoming_call', 'current'));
            endCallCleanup();
        }
    };

    function showActiveCall(partnerName) {
        // Останавливаем звук исходящего звонка
        dialTone.pause();
        dialTone.currentTime = 0;
        
        document.getElementById('outgoing-call-screen').classList.add('hidden');
        document.getElementById('incoming-call-screen').classList.add('hidden');
        document.getElementById('active-call-screen').classList.remove('hidden');
        
        // Обновляем имя в обоих местах
        const nameEl = document.getElementById('active-call-name');
        const nameAudioEl = document.getElementById('active-call-name-audio');
        
        if (isGroupCall) {
            // Групповой звонок - показываем название группы без @
            if (nameEl) nameEl.innerText = partnerName;
            if (nameAudioEl) nameAudioEl.innerText = partnerName;
            
            // Показываем иконку группы
            const avatarEl = document.getElementById('active-call-avatar');
            if (avatarEl) {
                avatarEl.innerHTML = `<i class="fas fa-users text-3xl"></i>`;
            }
            
            // Обновляем UI группового звонка
            updateGroupCallUI();
        } else {
            // Личный звонок
            if (nameEl) nameEl.innerText = '@' + partnerName;
            if (nameAudioEl) nameAudioEl.innerText = '@' + partnerName;
            
            // Обновляем аватар в аудио-оверлее (сначала буква, потом загружаем из Firebase)
            const avatarEl = document.getElementById('active-call-avatar');
            if (avatarEl) {
                avatarEl.innerHTML = partnerName.charAt(0).toUpperCase();
                
                // Загружаем реальный аватар из Firebase
                if (activeChatPartner && activeChatPartner.uid) {
                    getDoc(doc(db, 'artifacts', appId, 'public', 'data', 'users', activeChatPartner.uid)).then(userDoc => {
                        if (userDoc.exists() && userDoc.data().avatar) {
                            avatarEl.innerHTML = `<img src="${userDoc.data().avatar}" class="w-full h-full object-cover">`;
                        }
                    }).catch(() => {});
                }
            }
        }
        
        // Показываем/скрываем аудио-оверлей в зависимости от типа звонка
        const audioOverlay = document.getElementById('audio-call-overlay');
        const localVideoEl = document.getElementById('local-video');
        const remoteVideoEl = document.getElementById('remote-video');
        const hasVideo = localStream && localStream.getVideoTracks().length > 0 && localStream.getVideoTracks()[0].enabled;
        
        if (isGroupCall) {
            // Для группового звонка скрываем стандартные видео элементы
            if (localVideoEl) localVideoEl.classList.add('hidden');
            if (remoteVideoEl) remoteVideoEl.classList.add('hidden');
            // Аудио оверлей управляется в updateGroupCallUI
        } else {
            if (localVideoEl) localVideoEl.classList.remove('hidden');
            if (remoteVideoEl) remoteVideoEl.classList.remove('hidden');
            if (audioOverlay) {
                audioOverlay.classList.toggle('hidden', hasVideo);
            }
        }
        
        if (localStream && localVideoEl) {
            localVideoEl.srcObject = localStream;
        }
        
        // Таймер звонка
        callStartTime = Date.now();
        callTimerInterval = setInterval(() => {
            const elapsed = Math.floor((Date.now() - callStartTime) / 1000);
            const mins = Math.floor(elapsed / 60).toString().padStart(2, '0');
            const secs = (elapsed % 60).toString().padStart(2, '0');
            
            const timerEl = document.getElementById('call-timer');
            if (timerEl) timerEl.innerText = `${mins}:${secs}`;
            
            const timerAudioEl = document.getElementById('call-timer-audio');
            if (timerAudioEl) timerAudioEl.innerText = `${mins}:${secs}`;
        }, 1000);
    }

    function endCallCleanup() {
        // Воспроизводим звук завершения звонка
        endCallSound.play().catch(() => {});
        
        // Останавливаем все звуки звонка
        dialTone.pause();
        dialTone.currentTime = 0;
        ringtone.pause();
        ringtone.currentTime = 0;
        
        document.getElementById('outgoing-call-screen').classList.add('hidden');
        document.getElementById('incoming-call-screen').classList.add('hidden');
        document.getElementById('active-call-screen').classList.add('hidden');
        
        // Сбрасываем видимость элементов
        const localVideoEl = document.getElementById('local-video');
        const remoteVideoEl = document.getElementById('remote-video');
        const groupContainer = document.getElementById('group-call-participants');
        
        if (localVideoEl) localVideoEl.classList.remove('hidden');
        if (remoteVideoEl) remoteVideoEl.classList.remove('hidden');
        if (groupContainer) groupContainer.classList.add('hidden');
        
        if (callTimerInterval) {
            clearInterval(callTimerInterval);
            callTimerInterval = null;
        }
        
        if (localStream) {
            localStream.getTracks().forEach(track => track.stop());
            localStream = null;
        }
        
        if (peerConnection) {
            peerConnection.close();
            peerConnection = null;
        }
        
        remoteStream = null;
        currentCallId = null;
        isMuted = false;
        isVideoOff = false;
        isSpeakerOff = false;
        
        // Сбрасываем демонстрацию экрана
        if (isScreenSharing) {
            isScreenSharing = false;
            originalVideoTrack = null;
            const screenBtn = document.getElementById('screen-share-btn');
            if (screenBtn) {
                screenBtn.classList.remove('screen-sharing');
                screenBtn.innerHTML = '<i class="fas fa-desktop"></i>';
                screenBtn.title = 'Демонстрация экрана';
            }
        }
        
        // Сбрасываем режим просмотра демонстрации экрана
        if (isWatchingScreen) {
            isWatchingScreen = false;
            const watchBtn = document.getElementById('watch-screen-btn');
            if (watchBtn) {
                watchBtn.textContent = 'Смотреть';
                watchBtn.classList.remove('bg-gray-500', 'hover:bg-gray-600');
                watchBtn.classList.add('bg-blue-500', 'hover:bg-blue-600');
            }
        }
        
        document.getElementById('mute-btn').classList.remove('active');
        document.getElementById('video-btn').classList.remove('active');
        const speakerBtn = document.getElementById('speaker-btn');
        if (speakerBtn) {
            speakerBtn.classList.remove('active');
            speakerBtn.innerHTML = '<i class="fas fa-volume-up"></i>';
        }
        
        // Скрываем мини-плеер при завершении звонка
        document.getElementById('minimized-call').style.display = 'none';
        
        // Скрываем индикатор демонстрации экрана
        const screenIndicator = document.getElementById('screen-share-indicator');
        if (screenIndicator) {
            screenIndicator.classList.add('hidden');
        }
    }
    
    // Сворачивание звонка
    let isCallMinimized = false;
    
    window.minimizeCall = () => {
        if (!currentCallId) return;
        
        isCallMinimized = true;
        document.getElementById('active-call-screen').classList.add('hidden');
        
        const miniCall = document.getElementById('minimized-call');
        miniCall.style.display = 'block';
        
        // Копируем информацию о звонке
        const callName = document.getElementById('active-call-name').innerText;
        document.getElementById('mini-call-name').innerText = callName;
        
        // Копируем аватар
        const avatarEl = document.getElementById('active-call-avatar');
        const miniAvatarEl = document.getElementById('mini-call-avatar');
        if (avatarEl && miniAvatarEl) {
            if (avatarEl.querySelector('img')) {
                miniAvatarEl.innerHTML = avatarEl.innerHTML;
            } else if (avatarEl.querySelector('i')) {
                miniAvatarEl.innerHTML = avatarEl.innerHTML;
            } else {
                miniAvatarEl.innerText = avatarEl.innerText;
            }
        }
        
        // Обновляем таймер в мини-плеере
        updateMiniCallTimer();
    };
    
    function updateMiniCallTimer() {
        if (!isCallMinimized || !callStartTime) return;
        
        const elapsed = Math.floor((Date.now() - callStartTime) / 1000);
        const mins = Math.floor(elapsed / 60).toString().padStart(2, '0');
        const secs = (elapsed % 60).toString().padStart(2, '0');
        
        const miniTimer = document.getElementById('mini-call-timer');
        if (miniTimer) miniTimer.innerText = `${mins}:${secs}`;
    }
    
    // Обновляем таймер мини-плеера каждую секунду
    setInterval(updateMiniCallTimer, 1000);
    
    window.expandCall = () => {
        isCallMinimized = false;
        document.getElementById('minimized-call').style.display = 'none';
        document.getElementById('active-call-screen').classList.remove('hidden');
    };

    window.toggleMute = () => {
        if (!localStream) return;
        isMuted = !isMuted;
        localStream.getAudioTracks().forEach(track => track.enabled = !isMuted);
        
        const btn = document.getElementById('mute-btn');
        btn.classList.toggle('active', isMuted);
        btn.innerHTML = isMuted ? '<i class="fas fa-microphone-slash"></i>' : '<i class="fas fa-microphone"></i>';
    };

    window.toggleVideo = () => {
        if (!localStream) return;
        isVideoOff = !isVideoOff;
        localStream.getVideoTracks().forEach(track => track.enabled = !isVideoOff);
        
        const btn = document.getElementById('video-btn');
        btn.classList.toggle('active', isVideoOff);
        btn.innerHTML = isVideoOff ? '<i class="fas fa-video-slash"></i>' : '<i class="fas fa-video"></i>';
    };

    window.toggleScreenShare = async () => {
        console.log('toggleScreenShare вызвана');
        console.log('peerConnection:', peerConnection);
        console.log('localStream:', localStream);
        
        if (!peerConnection || !localStream) {
            console.error('Нет активного звонка! peerConnection:', !!peerConnection, 'localStream:', !!localStream);
            alert('Нет активного звонка! Сначала начните видеозвонок.');
            return;
        }
        
        const btn = document.getElementById('screen-share-btn');
        
        try {
            if (!isScreenSharing) {
                // Проверяем, это Electron или браузер
                const isElectron = window.electronAPI && window.electronAPI.isElectron;
                
                let screenStream;
                
                if (isElectron) {
                    // Electron: используем desktopCapturer
                    console.log('Используем Electron desktopCapturer');
                    
                    try {
                        const sources = await window.electronAPI.getSources();
                        
                        if (!sources || sources.length === 0) {
                            alert('Не найдено источников для демонстрации экрана');
                            return;
                        }
                        
                        // Показываем диалог выбора источника
                        const selectedSource = await showSourcePicker(sources);
                        
                        if (!selectedSource) {
                            console.log('Пользователь отменил выбор источника');
                            return;
                        }
                        
                        // Получаем поток с выбранного источника
                        screenStream = await navigator.mediaDevices.getUserMedia({
                            audio: false,
                            video: {
                                mandatory: {
                                    chromeMediaSource: 'desktop',
                                    chromeMediaSourceId: selectedSource.id,
                                    maxWidth: 1920,
                                    maxHeight: 1080,
                                    maxFrameRate: 30
                                }
                            }
                        });
                    } catch (err) {
                        console.error('Ошибка Electron screen capture:', err);
                        alert('Не удалось начать демонстрацию экрана: ' + err.message);
                        return;
                    }
                } else {
                    // Браузер: используем getDisplayMedia
                    // Проверяем HTTPS
                    if (location.protocol !== 'https:' && location.hostname !== 'localhost') {
                        alert('Демонстрация экрана требует HTTPS соединения. Откройте сайт через https://');
                        return;
                    }
                    
                    // Проверяем поддержку демонстрации экрана
                    if (!navigator.mediaDevices || !navigator.mediaDevices.getDisplayMedia) {
                        if (isMobileDevice()) {
                            alert('Демонстрация экрана не поддерживается на мобильных устройствах.');
                            return;
                        } else {
                            alert('Ваш браузер не поддерживает демонстрацию экрана.');
                            return;
                        }
                    }
                    
                    screenStream = await navigator.mediaDevices.getDisplayMedia({
                        video: {
                            width: { ideal: 1920, max: 1920 },
                            height: { ideal: 1080, max: 1080 },
                            frameRate: { ideal: 30, max: 30 }
                        },
                        audio: false
                    });
                }
                
                // Сохраняем оригинальный видео трек
                const videoTrack = localStream.getVideoTracks()[0];
                console.log('Текущий видео трек в localStream:', videoTrack);
                console.log('Все треки в localStream:', localStream.getTracks());
                
                // Проверяем, что это видеозвонок
                if (!videoTrack) {
                    alert('Демонстрация экрана доступна только в видеозвонках. Начните видеозвонок, чтобы использовать эту функцию.');
                    screenStream.getTracks().forEach(track => track.stop());
                    return;
                }
                
                originalVideoTrack = videoTrack;
                
                // Заменяем видео трек на демонстрацию экрана
                const screenVideoTrack = screenStream.getVideoTracks()[0];
                console.log('Видео трек демонстрации экрана:', screenVideoTrack);
                
                // Ищем sender для видео
                const sender = peerConnection.getSenders().find(s => 
                    s.track && s.track.kind === 'video'
                );
                
                if (!sender) {
                    console.error('Sender для видео не найден');
                    alert('Ошибка: не удалось найти видео поток. Попробуйте перезапустить звонок.');
                    screenStream.getTracks().forEach(track => track.stop());
                    return;
                }
                
                // Заменяем существующий трек (без пересогласования!)
                console.log('Заменяем видео трек на демонстрацию экрана');
                await sender.replaceTrack(screenVideoTrack);
                console.log('Видео трек заменён успешно');
                
                // Обновляем локальный поток (НЕ останавливаем оригинальный трек!)
                localStream.removeTrack(videoTrack);
                localStream.addTrack(screenVideoTrack);
                // videoTrack НЕ останавливаем - он нужен для восстановления
                
                // Обновляем локальное видео
                document.getElementById('local-video').srcObject = localStream;
                console.log('Локальное видео обновлено');
                
                // replaceTrack() НЕ требует пересогласования!
                // Видео автоматически передаётся удалённой стороне
                
                // Слушаем завершение демонстрации экрана
                screenVideoTrack.addEventListener('ended', () => {
                    stopScreenShare();
                });
                
                isScreenSharing = true;
                btn.classList.add('screen-sharing');
                btn.innerHTML = '<i class="fas fa-desktop"></i>';
                btn.title = 'Остановить демонстрацию экрана';
                
                // Показываем уведомление
                showScreenShareNotification('Демонстрация экрана начата');
                
                // Уведомляем других участников через Firebase (для показа индикатора)
                if (currentCallId) {
                    if (isGroupCall) {
                        await setDoc(doc(db, 'artifacts', appId, 'public', 'data', 'group_calls', currentCallId), {
                            screenSharing: {
                                userId: me.uid,
                                userName: me.username,
                                isSharing: true,
                                timestamp: serverTimestamp()
                            }
                        }, { merge: true });
                    } else {
                        await setDoc(doc(db, 'artifacts', appId, 'public', 'data', 'calls', currentCallId), {
                            screenSharing: {
                                userId: me.uid,
                                userName: me.username,
                                isSharing: true,
                                timestamp: serverTimestamp()
                            }
                        }, { merge: true });
                    }
                }
                
            } else {
                // Останавливаем демонстрацию экрана
                await stopScreenShare();
            }
        } catch (err) {
            console.error('Ошибка демонстрации экрана:', err);
            const isElectronApp = window.electronAPI && window.electronAPI.isElectron;
            
            if (err.name === 'NotAllowedError') {
                alert('Доступ к демонстрации экрана отклонён. Разрешите доступ в браузере.');
            } else if (err.name === 'NotSupportedError') {
                alert('Демонстрация экрана не поддерживается на этом устройстве');
            } else if (err.name === 'NotFoundError') {
                alert('Не найдено устройство для демонстрации экрана');
            } else if (err.name === 'AbortError') {
                // Пользователь отменил выбор экрана - это нормально, не показываем ошибку
                console.log('Пользователь отменил демонстрацию экрана');
            } else if (!isElectronApp && location.protocol !== 'https:' && location.hostname !== 'localhost') {
                alert('Для демонстрации экрана требуется HTTPS соединение');
            } else {
                alert('Не удалось начать демонстрацию экрана: ' + err.message);
            }
        }
    };

    async function stopScreenShare() {
        if (!isScreenSharing || !peerConnection) return;
        
        try {
            // Получаем текущий видео трек (демонстрация экрана)
            const screenTrack = localStream.getVideoTracks()[0];
            
            // Ищем sender для видео
            const sender = peerConnection.getSenders().find(s => 
                s.track && s.track.kind === 'video'
            );
            
            // Возвращаем оригинальную камеру если была сохранена
            if (originalVideoTrack && sender) {
                try {
                    // Проверяем, что оригинальный трек ещё жив
                    if (originalVideoTrack.readyState === 'live') {
                        // Заменяем трек обратно на камеру
                        await sender.replaceTrack(originalVideoTrack);
                        
                        // Обновляем локальный поток
                        if (screenTrack) {
                            localStream.removeTrack(screenTrack);
                            screenTrack.stop();
                        }
                        localStream.addTrack(originalVideoTrack);
                        
                        // Применяем текущее состояние видео
                        originalVideoTrack.enabled = !isVideoOff;
                        
                        console.log('Камера восстановлена');
                    } else {
                        // Оригинальный трек мёртв, нужно запросить новый
                        console.log('Оригинальный трек недоступен, показываем чёрный экран');
                        // Просто останавливаем демонстрацию, камера будет чёрной
                        if (screenTrack) {
                            localStream.removeTrack(screenTrack);
                            screenTrack.stop();
                        }
                    }
                } catch (err) {
                    console.error('Ошибка восстановления камеры:', err);
                    // Просто останавливаем демонстрацию
                    if (screenTrack) {
                        localStream.removeTrack(screenTrack);
                        screenTrack.stop();
                    }
                }
            } else {
                // Нет оригинального трека, просто останавливаем демонстрацию
                if (screenTrack) {
                    localStream.removeTrack(screenTrack);
                    screenTrack.stop();
                }
            }
            
            // Обновляем локальное видео
            document.getElementById('local-video').srcObject = localStream;
            
            isScreenSharing = false;
            originalVideoTrack = null;
            
            const btn = document.getElementById('screen-share-btn');
            btn.classList.remove('screen-sharing');
            btn.innerHTML = '<i class="fas fa-desktop"></i>';
            btn.title = 'Демонстрация экрана';
            
            // Показываем уведомление
            showScreenShareNotification('Демонстрация экрана остановлена');
            
            // Уведомляем других участников через Firebase
            if (currentCallId) {
                if (isGroupCall) {
                    await setDoc(doc(db, 'artifacts', appId, 'public', 'data', 'group_calls', currentCallId), {
                        screenSharing: {
                            userId: me.uid,
                            userName: me.username,
                            isSharing: false,
                            timestamp: serverTimestamp()
                        }
                    }, { merge: true });
                } else {
                    await setDoc(doc(db, 'artifacts', appId, 'public', 'data', 'calls', currentCallId), {
                        screenSharing: {
                            userId: me.uid,
                            userName: me.username,
                            isSharing: false,
                            timestamp: serverTimestamp()
                        }
                    }, { merge: true });
                }
            }
            
        } catch (err) {
            console.error('Ошибка остановки демонстрации экрана:', err);
        }
    }

    // Диалог выбора источника для Electron
    function showSourcePicker(sources) {
        return new Promise((resolve) => {
            // Создаём модальное окно
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 z-[300] flex items-center justify-center bg-black/70';
            modal.innerHTML = `
                <div class="glass-panel rounded-2xl p-6 max-w-2xl w-full mx-4 max-h-[80vh] overflow-hidden flex flex-col">
                    <div class="flex justify-between items-center mb-4">
                        <h3 class="text-lg font-bold">Выберите источник для демонстрации</h3>
                        <button class="close-picker text-2xl opacity-60 hover:opacity-100">&times;</button>
                    </div>
                    <div class="grid grid-cols-2 sm:grid-cols-3 gap-4 overflow-y-auto flex-1 source-grid">
                        ${sources.map(source => `
                            <div class="source-item cursor-pointer rounded-xl border-2 border-transparent hover:border-indigo-500 p-2 transition-all" data-id="${source.id}">
                                <img src="${source.thumbnail}" class="w-full h-24 object-cover rounded-lg bg-gray-800" alt="${source.name}">
                                <p class="text-sm mt-2 truncate text-center">${source.name}</p>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Обработчики
            modal.querySelector('.close-picker').onclick = () => {
                modal.remove();
                resolve(null);
            };
            
            modal.querySelectorAll('.source-item').forEach(item => {
                item.onclick = () => {
                    const id = item.dataset.id;
                    const source = sources.find(s => s.id === id);
                    modal.remove();
                    resolve(source);
                };
            });
            
            // Закрытие по клику на фон
            modal.onclick = (e) => {
                if (e.target === modal) {
                    modal.remove();
                    resolve(null);
                }
            };
        });
    }

    function showScreenShareNotification(message) {
        const notification = document.createElement('div');
        notification.className = 'screen-share-notification';
        notification.innerHTML = `<i class="fas fa-desktop"></i> ${message}`;
        
        const callScreen = document.getElementById('active-call-screen');
        if (callScreen) {
            callScreen.appendChild(notification);
            
            // Удаляем уведомление через 3 секунды
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 3000);
        }
        
        // Обновляем индикатор демонстрации экрана
        const indicator = document.getElementById('screen-share-indicator');
        const userSpan = document.getElementById('screen-share-user');
        
        if (message.includes('демонстрирует экран')) {
            const userName = message.split(' демонстрирует экран')[0];
            userSpan.textContent = userName;
            indicator.classList.remove('hidden');
        } else if (message.includes('остановил демонстрацию') || message.includes('остановлена')) {
            indicator.classList.add('hidden');
        }
    }

    let isWatchingScreen = false;
    window.toggleScreenWatch = () => {
        console.log('toggleScreenWatch вызвана');
        
        const remoteVideo = document.getElementById('remote-video');
        const localVideo = document.getElementById('local-video');
        const watchBtn = document.getElementById('watch-screen-btn');
        const videoContainer = document.getElementById('active-call-screen');
        
        console.log('Элементы:', { remoteVideo, localVideo, watchBtn, videoContainer });
        
        if (!remoteVideo) {
            console.error('remote-video не найден');
            return;
        }
        if (!localVideo) {
            console.error('local-video не найден');
            return;
        }
        if (!watchBtn) {
            console.error('watch-screen-btn не найден');
            return;
        }
        
        isWatchingScreen = !isWatchingScreen;
        console.log('isWatchingScreen:', isWatchingScreen);
        
        if (isWatchingScreen) {
            console.log('Включаем режим просмотра');
            // Переключаемся на полноэкранный просмотр демонстрации
            remoteVideo.style.objectFit = 'contain';
            remoteVideo.style.backgroundColor = '#000';
            localVideo.style.width = '120px';
            localVideo.style.height = '160px';
            localVideo.style.bottom = '20px';
            localVideo.style.right = '20px';
            watchBtn.textContent = 'Свернуть';
            watchBtn.classList.remove('bg-blue-500', 'hover:bg-blue-600');
            watchBtn.classList.add('bg-gray-500', 'hover:bg-gray-600');
            
            // Показываем уведомление
            showScreenShareNotification('Просмотр демонстрации экрана');
            console.log('Режим просмотра включен');
        } else {
            console.log('Выключаем режим просмотра');
            // Возвращаемся к обычному виду
            remoteVideo.style.objectFit = 'cover';
            remoteVideo.style.backgroundColor = '';
            localVideo.style.width = '150px';
            localVideo.style.height = '200px';
            localVideo.style.bottom = '120px';
            localVideo.style.right = '20px';
            watchBtn.textContent = 'Смотреть';
            watchBtn.classList.remove('bg-gray-500', 'hover:bg-gray-600');
            watchBtn.classList.add('bg-blue-500', 'hover:bg-blue-600');
            console.log('Режим просмотра выключен');
        }
    };
    
    // ТЕСТОВАЯ ФУНКЦИЯ - для отладки (удалить после тестирования)
    window.testScreenShareIndicator = () => {
        const indicator = document.getElementById('screen-share-indicator');
        if (indicator) {
            indicator.classList.toggle('hidden');
            console.log('Индикатор демонстрации экрана:', indicator.classList.contains('hidden') ? 'скрыт' : 'показан');
        }
    };

    let isSpeakerOff = false;
    window.toggleSpeaker = () => {
        isSpeakerOff = !isSpeakerOff;
        const remoteVideo = document.getElementById('remote-video');
        if (remoteVideo) {
            remoteVideo.muted = isSpeakerOff;
        }
        
        const btn = document.getElementById('speaker-btn');
        btn.classList.toggle('active', isSpeakerOff);
        btn.innerHTML = isSpeakerOff ? '<i class="fas fa-volume-mute"></i>' : '<i class="fas fa-volume-up"></i>';
    };

    // Запускаем слушатель звонков после авторизации
    const originalShowApp = showApp;
    window.showApp = showApp = function() {
        originalShowApp.call ? originalShowApp.call(this) : originalShowApp();
        listenForCalls();
    };
    
    // Регистрация Service Worker для PWA (отключено для отладки)
    // Раскомментируй для продакшена на HTTPS
    /*
    if ('serviceWorker' in navigator) {
        navigator.serviceWorker.register('sw.js')
            .then(reg => console.log('SW registered'))
            .catch(err => console.log('SW registration failed'));
    }
    */
    
    // Удаляем старый SW если есть
    if ('serviceWorker' in navigator) {
        navigator.serviceWorker.getRegistrations().then(registrations => {
            registrations.forEach(reg => reg.unregister());
        });
    }
    
    // ========== Индикатор "печатает..." ==========
    let typingTimeout = null;
    let amITyping = false;
    let partnerTypingUnsub = null;
    
    // Отправляем статус когда печатаем
    window.onTyping = async () => {
        if (!activeChatPartner || !me) return;
        
        const chatId = [me.uid, activeChatPartner.uid].sort().join('_');
        
        if (!amITyping) {
            amITyping = true;
            try {
                await setDoc(doc(db, 'artifacts', appId, 'public', 'data', 'chats', chatId, 'typing', me.uid), {
                    isTyping: true,
                    timestamp: serverTimestamp()
                });
            } catch (e) {}
        }
        
        clearTimeout(typingTimeout);
        typingTimeout = setTimeout(async () => {
            amITyping = false;
            try {
                await setDoc(doc(db, 'artifacts', appId, 'public', 'data', 'chats', chatId, 'typing', me.uid), {
                    isTyping: false,
                    timestamp: serverTimestamp()
                });
            } catch (e) {}
        }, 2000);
    };
    
    // Слушаем когда собеседник печатает
    function listenToPartnerTyping(partnerId) {
        if (partnerTypingUnsub) {
            partnerTypingUnsub();
            partnerTypingUnsub = null;
        }
        if (!me || !partnerId) return;
        
        const chatId = [me.uid, partnerId].sort().join('_');
        const onlineStatus = document.getElementById('online-status');
        
        partnerTypingUnsub = onSnapshot(doc(db, 'artifacts', appId, 'public', 'data', 'chats', chatId, 'typing', partnerId), (snap) => {
            if (!onlineStatus) return;
            
            let showTyping = false;
            if (snap.exists()) {
                const data = snap.data();
                if (data.isTyping && data.timestamp) {
                    const typingTime = data.timestamp.seconds ? data.timestamp.seconds * 1000 : data.timestamp;
                    // Показываем только если timestamp свежий (менее 3 секунд)
                    showTyping = (Date.now() - typingTime) < 3000;
                }
            }
            
            if (showTyping) {
                onlineStatus.innerHTML = '<span class="text-indigo-500 animate-pulse">' + (currentLang === 'ru' ? 'печатает...' : 'typing...') + '</span>';
            } else {
                // Восстанавливаем онлайн-статус
                if (activeChatPartner) {
                    getDoc(doc(db, 'artifacts', appId, 'public', 'data', 'users', activeChatPartner.uid)).then(userDoc => {
                        if (userDoc.exists()) {
                            const userData = userDoc.data();
                            const isOnline = userData.isOnline === true;
                            if (isOnline) {
                                onlineStatus.innerHTML = '<span class="text-green-500">' + (currentLang === 'ru' ? 'в сети' : 'online') + '</span>';
                            } else {
                                onlineStatus.innerHTML = formatLastSeen(userData.lastSeen);
                            }
                        }
                    }).catch(() => {});
                }
            }
        });
    }
    
    // ========== ФИЧА 2: Быстрые ответы ==========
    window.toggleQuickReplies = () => {
        const panel = document.getElementById('quick-replies-panel');
        panel.classList.toggle('active');
        
        // Закрываем другие панели
        document.getElementById('sticker-panel').classList.remove('active');
        document.getElementById('ai-panel').classList.add('hidden');
    };
    
    window.useQuickReply = (text) => {
        document.getElementById('msg-input').value = text;
        document.getElementById('quick-replies-panel').classList.remove('active');
        document.getElementById('msg-input').focus();
    };
    
    // Закрываем панель при клике вне
    document.addEventListener('click', (e) => {
        const panel = document.getElementById('quick-replies-panel');
        const btn = e.target.closest('[onclick*="toggleQuickReplies"]');
        if (panel && !panel.contains(e.target) && !btn) {
            panel.classList.remove('active');
        }
    });
    
    // Инициализация аудио контекста при первом взаимодействии (важно для iOS)
    let audioContextInitialized = false;
    document.addEventListener('click', async () => {
        if (!audioContextInitialized && isMobileDevice()) {
            await fixIOSAudioContext();
            audioContextInitialized = true;
        }
    }, { once: true });
    
    // Предупреждение о HTTP для демонстрации экрана (только для браузера, не для Electron)
    const isElectronApp = window.electronAPI && window.electronAPI.isElectron;
    if (!isElectronApp && location.protocol !== 'https:' && location.hostname !== 'localhost' && location.protocol !== 'file:') {
        const warning = document.createElement('div');
        warning.className = 'http-warning';
        warning.innerHTML = '<i class="fas fa-exclamation-triangle"></i> Для демонстрации экрана нужен HTTPS';
        document.body.appendChild(warning);
        
        // Скрываем предупреждение через 10 секунд
        setTimeout(() => {
            if (warning.parentNode) {
                warning.parentNode.removeChild(warning);
            }
        }, 10000);
    }
    
    // ========== ФИЧА 3: Закладки сообщений ==========
    let bookmarks = JSON.parse(localStorage.getItem('flickers-bookmarks') || '[]');
    
    window.toggleBookmarks = () => {
        const panel = document.getElementById('bookmarks-panel');
        panel.classList.toggle('active');
        if (panel.classList.contains('active')) {
            renderBookmarks();
        }
        // Закрываем меню чата
        document.getElementById('chat-menu')?.classList.add('hidden');
    };
    
    window.addBookmark = (msgData) => {
        // Проверяем, не добавлено ли уже
        if (bookmarks.find(b => b.msgId === msgData.msgId)) {
            showToast(currentLang === 'ru' ? 'Уже в закладках' : 'Already bookmarked', '📌');
            return;
        }
        
        bookmarks.unshift({
            msgId: msgData.msgId,
            text: msgData.text,
            author: msgData.author,
            chatId: msgData.chatId,
            chatName: msgData.chatName,
            timestamp: Date.now()
        });
        
        localStorage.setItem('flickers-bookmarks', JSON.stringify(bookmarks));
        showToast(currentLang === 'ru' ? 'Добавлено в закладки' : 'Bookmarked', '🔖');
    };
    
    window.removeBookmark = (msgId, e) => {
        if (e) e.stopPropagation();
        bookmarks = bookmarks.filter(b => b.msgId !== msgId);
        localStorage.setItem('flickers-bookmarks', JSON.stringify(bookmarks));
        renderBookmarks();
        showToast(currentLang === 'ru' ? 'Удалено из закладок' : 'Removed from bookmarks', '🗑️');
    };
    
    function renderBookmarks() {
        const list = document.getElementById('bookmarks-list');
        
        if (bookmarks.length === 0) {
            list.innerHTML = `
                <div class="p-8 text-center opacity-50">
                    <i class="fas fa-bookmark text-4xl mb-3"></i>
                    <p class="text-sm">${currentLang === 'ru' ? 'Нет закладок' : 'No bookmarks'}</p>
                    <p class="text-xs mt-2">${currentLang === 'ru' ? 'Нажмите ПКМ на сообщении → Добавить в закладки' : 'Right-click message → Add to bookmarks'}</p>
                </div>
            `;
            return;
        }
        
        list.innerHTML = bookmarks.map(b => `
            <div class="bookmark-item" onclick="goToBookmark('${b.chatId}', '${b.msgId}')">
                <div class="bookmark-item-header">
                    <span class="bookmark-item-author">@${b.author}</span>
                    <div class="flex items-center gap-2">
                        <span class="bookmark-item-time">${formatBookmarkTime(b.timestamp)}</span>
                        <button onclick="removeBookmark('${b.msgId}', event)" class="bookmark-remove w-6 h-6 rounded-full hover:bg-red-100 dark:hover:bg-red-900/30 flex items-center justify-center text-red-500">
                            <i class="fas fa-times text-xs"></i>
                        </button>
                    </div>
                </div>
                <div class="bookmark-item-text">${b.text || '[Медиа]'}</div>
                <div class="text-[10px] opacity-40 mt-1">${b.chatName}</div>
            </div>
        `).join('');
    }
    
    function formatFileSize(bytes) {
        if (bytes === 0) return '0 Б';
        const k = 1024;
        const sizes = ['Б', 'КБ', 'МБ', 'ГБ'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
    }
    
    function formatBookmarkTime(timestamp) {
        const date = new Date(timestamp);
        const now = new Date();
        const diff = now - date;
        
        if (diff < 86400000) { // Меньше суток
            return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        } else if (diff < 604800000) { // Меньше недели
            return date.toLocaleDateString(currentLang === 'ru' ? 'ru-RU' : 'en-US', { weekday: 'short' });
        } else {
            return date.toLocaleDateString(currentLang === 'ru' ? 'ru-RU' : 'en-US', { day: 'numeric', month: 'short' });
        }
    }
    
    window.goToBookmark = async (chatId, msgId) => {
        // Закрываем панель закладок
        document.getElementById('bookmarks-panel').classList.remove('active');
        
        // Прокручиваем к сообщению если чат открыт
        const msgEl = document.querySelector(`[data-msg-id="${msgId}"]`);
        if (msgEl) {
            msgEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
            msgEl.classList.add('highlight-msg');
            setTimeout(() => msgEl.classList.remove('highlight-msg'), 2000);
        } else {
            showToast(currentLang === 'ru' ? 'Откройте нужный чат' : 'Open the chat first', '💬');
        }
    };
    
    // ========== ЗАМЕТКИ (Notes) ==========
    let notes = JSON.parse(localStorage.getItem('flickers-notes') || '[]');
    let currentNoteId = null;
    let currentNoteColor = '#f1f5f9';
    
    window.toggleNotes = () => {
        const panel = document.getElementById('notes-panel');
        const editorPanel = document.getElementById('note-editor-panel');
        editorPanel.classList.remove('active');
        panel.classList.toggle('active');
        if (panel.classList.contains('active')) {
            renderNotes();
        }
        document.getElementById('chat-menu')?.classList.add('hidden');
    };
    
    window.createNewNote = () => {
        currentNoteId = null;
        currentNoteColor = '#f1f5f9';
        document.getElementById('note-title-input').value = '';
        document.getElementById('note-content-input').value = '';
        document.querySelectorAll('.note-color').forEach(c => c.classList.remove('active'));
        document.querySelector('.note-color[data-color="#f1f5f9"]').classList.add('active');
        
        document.getElementById('notes-panel').classList.remove('active');
        document.getElementById('note-editor-panel').classList.add('active');
    };
    
    window.openNote = (noteId) => {
        const note = notes.find(n => n.id === noteId);
        if (!note) return;
        
        currentNoteId = noteId;
        currentNoteColor = note.color || '#f1f5f9';
        document.getElementById('note-title-input').value = note.title || '';
        document.getElementById('note-content-input').value = note.content || '';
        
        document.querySelectorAll('.note-color').forEach(c => {
            c.classList.toggle('active', c.dataset.color === currentNoteColor);
        });
        
        document.getElementById('notes-panel').classList.remove('active');
        document.getElementById('note-editor-panel').classList.add('active');
    };
    
    window.closeNoteEditor = () => {
        document.getElementById('note-editor-panel').classList.remove('active');
        document.getElementById('notes-panel').classList.add('active');
        renderNotes();
    };
    
    window.setNoteColor = (el) => {
        currentNoteColor = el.dataset.color;
        document.querySelectorAll('.note-color').forEach(c => c.classList.remove('active'));
        el.classList.add('active');
    };
    
    window.saveCurrentNote = () => {
        const title = document.getElementById('note-title-input').value.trim() || 'Без названия';
        const content = document.getElementById('note-content-input').value.trim();
        
        if (!content && !title) {
            showToast('Заметка пуста', '⚠️');
            return;
        }
        
        if (currentNoteId) {
            // Редактирование
            const idx = notes.findIndex(n => n.id === currentNoteId);
            if (idx !== -1) {
                notes[idx] = { ...notes[idx], title, content, color: currentNoteColor, updatedAt: Date.now() };
            }
        } else {
            // Новая заметка
            notes.unshift({
                id: 'note_' + Date.now(),
                title,
                content,
                color: currentNoteColor,
                createdAt: Date.now(),
                updatedAt: Date.now()
            });
        }
        
        localStorage.setItem('flickers-notes', JSON.stringify(notes));
        showToast('Заметка сохранена', '✅');
        closeNoteEditor();
    };
    
    window.deleteCurrentNote = () => {
        if (!currentNoteId) {
            closeNoteEditor();
            return;
        }
        
        if (!confirm('Удалить заметку?')) return;
        
        notes = notes.filter(n => n.id !== currentNoteId);
        localStorage.setItem('flickers-notes', JSON.stringify(notes));
        showToast('Заметка удалена', '🗑️');
        closeNoteEditor();
    };
    
    function renderNotes() {
        const list = document.getElementById('notes-list');
        
        if (notes.length === 0) {
            list.innerHTML = `
                <div class="p-8 text-center opacity-50">
                    <i class="fas fa-sticky-note text-4xl mb-3"></i>
                    <p class="text-sm">Нет заметок</p>
                    <p class="text-xs mt-2">Нажмите + чтобы создать</p>
                </div>
            `;
            return;
        }
        
        list.innerHTML = notes.map(n => `
            <div class="note-item" style="border-left: 4px solid ${n.color};" onclick="openNote('${n.id}')">
                <div class="note-item-header">
                    <span class="note-item-title">${n.title || 'Без названия'}</span>
                    <span class="note-item-date">${formatBookmarkTime(n.updatedAt)}</span>
                </div>
                <div class="note-item-preview">${n.content || ''}</div>
            </div>
        `).join('');
    }
    
    // ========== ПРОЧИТАНО (Read receipts) ==========
    // Отслеживание прочтения сообщений
    async function markMessageAsRead(msgId, chatId) {
        if (!me || !chatId) return;
        
        try {
            const msgRef = doc(db, 'artifacts', appId, 'public', 'data', 'chats', chatId, 'messages', msgId);
            await updateDoc(msgRef, {
                readAt: Date.now(),
                readBy: me.uid
            });
        } catch(e) {
            // Игнорируем ошибки
        }
    }
    
    function getReadReceiptHtml(m, isMine) {
        if (!isMine) return '';
        
        if (m.readAt) {
            const readTime = new Date(m.readAt).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            return `<span class="read-receipt read" title="Прочитано в ${readTime}"><i class="fas fa-check-double"></i></span>`;
        } else {
            return `<span class="read-receipt" title="Доставлено"><i class="fas fa-check"></i></span>`;
        }
    }
    
    // ========== РАСШИРЕННЫЙ ПОИСК ==========
    let searchFilter = 'all';
    let searchMessages = [];
    
    window.toggleSearchPanel = () => {
        const panel = document.getElementById('search-panel');
        panel.classList.toggle('active');
        if (panel.classList.contains('active')) {
            document.getElementById('advanced-search-input').focus();
            loadSearchMessages();
        }
        document.getElementById('chat-menu')?.classList.add('hidden');
    };
    
    window.setSearchFilter = (filter) => {
        searchFilter = filter;
        document.querySelectorAll('.search-filter-btn').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.filter === filter);
        });
        performAdvancedSearch();
    };
    
    async function loadSearchMessages() {
        if (!activeChatPartner && !activeGroup) return;
        
        searchMessages = [];
        const container = document.getElementById('messages-container');
        const bubbles = container.querySelectorAll('.message-bubble');
        
        bubbles.forEach(bubble => {
            const msgId = bubble.dataset.msgId;
            const senderId = bubble.dataset.senderId;
            const text = bubble.querySelector('p')?.textContent || '';
            const hasImage = bubble.querySelector('img.chat-image');
            const hasFile = bubble.querySelector('a[download]');
            const hasLink = text.match(/https?:\/\/[^\s]+/);
            const timeEl = bubble.querySelector('.text-\\[9px\\]');
            const time = timeEl?.textContent || '';
            
            searchMessages.push({
                msgId,
                senderId,
                text,
                hasImage: !!hasImage,
                hasFile: !!hasFile,
                hasLink: !!hasLink,
                time,
                element: bubble
            });
        });
    }
    
    window.performAdvancedSearch = () => {
        const query = document.getElementById('advanced-search-input').value.toLowerCase().trim();
        const dateFrom = document.getElementById('search-date-from').value;
        const dateTo = document.getElementById('search-date-to').value;
        const resultsContainer = document.getElementById('search-results');
        
        if (!query && !dateFrom && !dateTo && searchFilter === 'all') {
            resultsContainer.innerHTML = `
                <div class="p-8 text-center opacity-50">
                    <i class="fas fa-search text-4xl mb-3"></i>
                    <p class="text-sm">Введите запрос для поиска</p>
                </div>
            `;
            return;
        }
        
        let results = searchMessages.filter(m => {
            // Фильтр по типу
            if (searchFilter === 'text' && (m.hasImage || m.hasFile)) return false;
            if (searchFilter === 'images' && !m.hasImage) return false;
            if (searchFilter === 'files' && !m.hasFile) return false;
            if (searchFilter === 'links' && !m.hasLink) return false;
            
            // Фильтр по тексту
            if (query && !m.text.toLowerCase().includes(query)) return false;
            
            return true;
        });
        
        if (results.length === 0) {
            resultsContainer.innerHTML = `
                <div class="p-8 text-center opacity-50">
                    <i class="fas fa-search text-4xl mb-3"></i>
                    <p class="text-sm">Ничего не найдено</p>
                </div>
            `;
            return;
        }
        
        resultsContainer.innerHTML = results.map(r => {
            let typeIcon = '<i class="fas fa-comment"></i> Сообщение';
            if (r.hasImage) typeIcon = '<i class="fas fa-image"></i> Фото';
            if (r.hasFile) typeIcon = '<i class="fas fa-file"></i> Файл';
            if (r.hasLink) typeIcon = '<i class="fas fa-link"></i> Ссылка';
            
            let highlightedText = r.text;
            if (query) {
                const regex = new RegExp(`(${query})`, 'gi');
                highlightedText = r.text.replace(regex, '<mark>$1</mark>');
            }
            
            return `
                <div class="search-result-item" onclick="goToSearchResult('${r.msgId}')">
                    <div class="search-result-type">${typeIcon}</div>
                    <div class="search-result-text">${highlightedText || '[Медиа]'}</div>
                    <div class="search-result-meta">${r.time}</div>
                </div>
            `;
        }).join('');
    };
    
    window.goToSearchResult = (msgId) => {
        document.getElementById('search-panel').classList.remove('active');
        
        const msgEl = document.querySelector(`[data-msg-id="${msgId}"]`);
        if (msgEl) {
            msgEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
            msgEl.classList.add('highlight-msg');
            setTimeout(() => msgEl.classList.remove('highlight-msg'), 2000);
        }
    };
</script>
</body>
</html>
